---
date: 2021-04-12
title: Typescript 系列（四）tsconfig
template: post
thumbnail: "../thumbnails/post.png"
slug: typescript-04
categories:
  - Typescript
tags:
  - typescript
---

TS 基础进阶（四）tsconfig 解析

---

# tsconfig

tsconfig.json 是 ts 的编译器（tsc）将 ts 编译为 js 的配置文件，在开发和编译阶段提供支持（语法检查，代码依赖等）

# compilerOptions

### target: "es5",

指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'（"ESNext"表示最新的 ES 语法，包括还处在 stage X 阶段）

### module: "commonjs",

指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'

### lib: [],

指定要包含在编译中的库文件 'es6','dom'

### allowJs: true,

允许 tsc 编译 javascript 文件 默认 false

### checkJs: true,

检查 javascript 文件中的错误 默认 false

### jsx: "preserve",

指定 jsx 代码用于的开发环境 'preserve', 'react-native', or 'react'

### declaration: true,

编译生成相应的 '.d.ts' 文件 如果设为 true,编译每个 ts 文件之后会生成一个 js 文件和一个声明文件，但是 declaration 和 allowJs 不能同时设为 true

### sourceMap: true,

编译生成相应的 '.map' 文件

### declarationMap: true,

编译生成相应的 '.map' 文件

### outFile: "./",

指定输出文件合并为一个文件，只有设置 module 的值为 amd 和 system 模块时才支持这个配置

### outDir: "./",

指定输出文件夹，值为一个文件夹路径字符串，输出的文件都将放置在这个文件夹

### rootDir: "./",

指定编译文件的根目录，编译器会在根目录查找入口文件 默认为 tsconfig.json 所在目录

### composite: true,

是否编译构建引用项目

### removeComments: true,

指定是否将编译后的文件注释删掉，设为 true 的话即删除注释，默认为 false

### noEmit: true,

不生成编译文件

### downlevelIteration: true,

当 target 为"ES5"或"ES3"时，为"for-of" "spread"和"destructuring"中的迭代器提供完全支持

### importHelpers: true,

定是否引入 tslib 里的复制工具函数，默认为 false

### isolatedModules: true,

指定是否将每个文件作为单独的模块，默认为 true，他不可以和 declaration 同时设定（与 'ts.transpileModule' 类似）.

---

检查

### strict: true,

指定是否启动所有类型检查，如果设为 true 这回同时开启下面这几个严格检查，默认为 false

### noImplicitAny: true,

如果我们没有一些值设置明确类型，编译器会默认认为这个值为 any 类型，如果将 noImplicitAny 设为 true,则如果没有设置明确的类型会报错，默认值为 false

### strictNullChecks: true,

设为 true 时，null 和 undefined 值不能赋值给非这两种类型的值，别的类型的值也不能赋给他们，除了 any 类型，还有个例外就是 undefined 可以赋值给 void 类型

### noImplicitThis: true,

不允许 this 为 any

### strictFunctionTypes: false,

指定是否使用函数参数双向协变检查

### alwaysStrict: true,

以严格模式检查每个模块，并在每个文件里加入 'use strict' 用来告诉浏览器该 JS 为严格模式

### noUnusedLocals: true,

不允许声明未使用的变量

### noUnusedParameters: true,

不允许声明未使用的函数入参

### noImplicitReturns: true,

不允许函数没有明确返回值

### noFallthroughCasesInSwitch: true,

检查 switch 中是否有 case 没有使用 break 跳出 switch,默认为 false

---

模块解析选项

### moduleResolution: "node",

选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)。默认是 classic

### baseUrl: "./",

用于设置解析非相对模块名称的基本目录，相对模块不会受到 baseUrl 的影响

### paths

模块名到基于 baseUrl 的路径映射的列表

```ts
paths: {
"*": ["./node_modules/@types", "./typings/*"],
},
```

### rootDirs: [],

指定一个路径列表，在构建时编译器会将这个路径中的内容都放到一个文件夹中

### typeRoots: [],

指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载

### types: [],

指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载

### allowSyntheticDefaultImports: true,

指定允许从没有默认导出的模块中默认导入

### sourceRoot: "./",

指定调试器应该找到 TypeScript 文件而不是源文件的位置，这个值会被写进.map 文件里

### mapRoot: "./",

指定调试器找到映射文件而非生成文件的位置，指定 map 文件的根路径，该选项会影响.map 文件中的 sources 属性

### inlineSourceMap: true,

定是否将 map 文件内容和 js 文件编译在一个同一个 js 文件中，如果设为 true,则 map 的内容会以#soureMappingURL=开头，然后接 base64 字符串的形式插入在 js 文件底部

### inlineSources: true,

指定是否进一步将 ts 文件的内容也包含到输出文件中 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性

### preserveSymlinks: true,

不把符号链接解析为真实路径

### esModuleInterop: true,

通过导入内容创建命名空间，实现 CommonJS 和 ES 模块之间的互操作性

### experimentalDecorators: true,

指定是否启用实验性的装饰器特性

### emitDecoratorMetadata: true,

指定是否为装上去提供元数据支持，关于元数据，也是 ES6 的新标准，可以通过 Reflect 提供的静态方法获取元数据，如果需要使用 Reflect 的一些方法，需要引用 ES2015.Reflect 这个库

# include: ["src/**/*"],

指定要编译的路径列表

# exclude: ["node_modules", "**/*.spec.ts"],

表示要排除的，不编译的文件，它也可以指定一个列表，规则和 include 一样，可以是文件可以是文件夹，可以是相对路径或绝对路径，可以使用通配符

# files: ["core.ts", "sys.ts"],

指定要编译的文件列表

# extends: "./config/base",

指定一个其他的 tsconfig.json 文件路径，来继承这个配置文件里的配置，继承来的文件的配置会覆盖当前文件定义的配置

# compileOnSave: true,

让 IDE 在保存文件的时候根据 tsconfig.json 重新生成文件

支持这个特性需要 Visual Studio 2015， TypeScript1.8.4 以上并且安装 atom-typescript 插件

# references

一个对象数组，指定要引用的项目

```ts
references: [
  {
    path: "../test",
  },
],
```

# 完整的 tsconfig.json

```json
{
  // 基本编译选项
  compilerOptions: {
    // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'（"ESNext"表示最新的 ES 语法，包括还处在 stage X 阶段）
    target: "es5",
    // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'
    module: "commonjs",
    // 指定要包含在编译中的库文件 'es6','dom'
    lib: [],
    // 允许 tsc 编译 javascript 文件 默认 false
    allowJs: true,
    // 检查 javascript 文件中的错误 默认 false
    checkJs: true,
    // 指定jsx代码用于的开发环境 'preserve', 'react-native', or 'react'
    jsx: "preserve",
    // 编译生成相应的 '.d.ts' 文件 如果设为true,编译每个ts文件之后会生成一个js文件和一个声明文件，但是declaration和allowJs不能同时设为true
    declaration: true,
    // 编译生成相应的 '.map' 文件
    sourceMap: true,
    // 编译生成相应的 '.map' 文件
    declarationMap: true,
    // 指定输出文件合并为一个文件，只有设置module的值为amd和system模块时才支持这个配置
    outFile: "./",
    // 指定输出文件夹，值为一个文件夹路径字符串，输出的文件都将放置在这个文件夹
    outDir: "./",
    // 指定编译文件的根目录，编译器会在根目录查找入口文件 默认为tsconfig.json所在目录
    rootDir: "./",
    // 是否编译构建引用项目
    composite: true,
    // 指定是否将编译后的文件注释删掉，设为true的话即删除注释，默认为false
    removeComments: true,
    // 不生成编译文件
    noEmit: true,
    // 当target为"ES5"或"ES3"时，为"for-of" "spread"和"destructuring"中的迭代器提供完全支持
    downlevelIteration: true,
    // 定是否引入tslib里的复制工具函数，默认为false
    importHelpers: true,
    // 指定是否将每个文件作为单独的模块，默认为true，他不可以和declaration同时设定（与 'ts.transpileModule' 类似）.
    isolatedModules: true,

    // 检查
    // 指定是否启动所有类型检查，如果设为true这回同时开启下面这几个严格检查，默认为false
    strict: true,
    // 如果我们没有一些值设置明确类型，编译器会默认认为这个值为any类型，如果将noImplicitAny设为true,则如果没有设置明确的类型会报错，默认值为false
    noImplicitAny: true,
    // 设为true时，null和undefined值不能赋值给非这两种类型的值，别的类型的值也不能赋给他们，除了any类型，还有个例外就是undefined可以赋值给void类型
    strictNullChecks: true,
    // 不允许 this 为 any
    noImplicitThis: true,
    // 指定是否使用函数参数双向协变检查
    strictFunctionTypes: false,
    // 以严格模式检查每个模块，并在每个文件里加入 'use strict' 用来告诉浏览器该JS为严格模式
    alwaysStrict: true,
    // 不允许声明未使用的变量
    noUnusedLocals: true,
    // 不允许声明未使用的函数入参
    noUnusedParameters: true,
    // 不允许函数没有明确返回值
    noImplicitReturns: true,
    // 检查switch中是否有case没有使用break跳出switch,默认为false
    noFallthroughCasesInSwitch: true,

    /* 模块解析选项 */
    // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)。默认是classic
    moduleResolution: "node",
    // 用于设置解析非相对模块名称的基本目录，相对模块不会受到baseUrl的影响
    baseUrl: "./",
    // 模块名到基于 baseUrl 的路径映射的列表
    paths: {
      "*": ["./node_modules/@types", "./typings/*"],
    },
    // 指定一个路径列表，在构建时编译器会将这个路径中的内容都放到一个文件夹中
    rootDirs: [],
    // 指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载
    typeRoots: [],
    // 指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载
    types: [],
    // 指定允许从没有默认导出的模块中默认导入
    allowSyntheticDefaultImports: true,

    // 指定调试器应该找到TypeScript文件而不是源文件的位置，这个值会被写进.map文件里
    sourceRoot: "./",
    // 指定调试器找到映射文件而非生成文件的位置，指定map文件的根路径，该选项会影响.map文件中的sources属性
    mapRoot: "./",
    // 定是否将map文件内容和js文件编译在一个同一个js文件中，如果设为true,则map的内容会以//#soureMappingURL=开头，然后接base64字符串的形式插入在js文件底部
    inlineSourceMap: true,
    // 指定是否进一步将ts文件的内容也包含到输出文件中 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性
    inlineSources: true,

    // 不把符号链接解析为真实路径
    preserveSymlinks: true,
    // 通过导入内容创建命名空间，实现CommonJS和ES模块之间的互操作性
    esModuleInterop: true,
    // 指定是否启用实验性的装饰器特性
    experimentalDecorators: true,
    // 指定是否为装上去提供元数据支持，关于元数据，也是ES6的新标准，可以通过Reflect提供的静态方法获取元数据，如果需要使用Reflect的一些方法，需要引用ES2015.Reflect这个库
    emitDecoratorMetadata: true,
  },
  // 指定要编译的路径列表
  include: ["src/**/*"],
  // 表示要排除的，不编译的文件，它也可以指定一个列表，规则和include一样，可以是文件可以是文件夹，可以是相对路径或绝对路径，可以使用通配符
  exclude: ["node_modules", "**/*.spec.ts"],
  // 指定要编译的文件列表
  files: ["core.ts", "sys.ts"],
  // 指定一个其他的tsconfig.json文件路径，来继承这个配置文件里的配置，继承来的文件的配置会覆盖当前文件定义的配置
  extends: "./config/base",
  // 让 IDE 在保存文件的时候根据 tsconfig.json 重新生成文件，支持这个特性需要 Visual Studio 2015， TypeScript1.8.4 以上并且安装
  compileOnSave: true,atom-typescript 插件
  // 一个对象数组，指定要引用的项目
  references: [
    {
      path: "../test",
    },
  ],
};


```
