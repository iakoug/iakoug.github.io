---
date: 2021-02-01
title: 如何通过 mangling 属性压缩代码体积[译]
template: post
thumbnail: "../thumbnails/post.png"
slug: mangling-property
categories:
  - structure
tags:
  - structure
---

Mangling Property

---

> [Link](https://lihautan.com/reduce-minified-code-size-by-property-mangling/)

# 什么是 Mangling

假设你有下面这段代码

```js
class Human {
  constructor(chewAmount) {
    this.chewAmount = 3;
  }
  eat() {
    for (let amount = 3; amount < this.chewAmount; amount++) {
      this.chew();
    }
  }
  chew() {}
}

function getHumanEating() {
  const lihau = new Human();
  return lihau.eat();
}
```

原始大小为 268 字节

如果使用 [Terser](https://github.com/terser/terser) 的默认配置来压缩这段代码会输如下

```js
class Human {
  constructor(chewAmount) {
    this.chewAmount = 3;
  }
  eat() {
    for (let i = 3; i < this.chewAmount; i++) {
      this.chew();
    }
  }
  chew() {}
}
function getHumanEating() {
  return new Human().eat();
}
```

压缩至 207 字节（77.2%）

> Terser 一般也会将空格进行压缩，这里为了方便阅读维持空格

即使代码中的变量名被改变你的代码的执行依然和之前一致。而这种将变量名进行重命名的压缩方式叫做 Mangle

Terser 提供了一些 [相关的配置项](https://github.com/terser/terser#mangle-options) 来控制是否使用 mangle 来压缩 class name、function name、property name 和一些全局变量以及控制不对一些保留字使用 mangle 压缩

如果上述代码使用 es 标准编写，我们只能通过 import 引用他而不是全局的引用，那么类名就无关紧要

```ts
// Terser option: { mangle: { module: true } }
class H {
  constructor(chewAmount) {
    this.chewAmount = 3;
  }
  eat() {
    for (let i = 3; i < this.chewAmount; i++) {
      this.chew();
    }
  }
  chew() {}
}
function e() {
  return new H().eat();
}
export { H as Human, e as getHumanEating };
```

186 Bytes (69.4%)

还可以进一步压缩吗？代码的 chewAmount 属性名占用了 20 个字符，几乎占用了代码的百分之十，如果把这个属性名变为一个字符的变量，会得到更小体积的代码

```ts
class H {
  constructor(t) {
    this.c = 3;
  }
  a() {
    for (let t = 3; t < this.c; t++) this.s();
  }
  s() {}
}
function e() {
  return new H().a();
}
export { H as Human, e as getHumanEating };
```

107 Bytes (39.9%)

代码体积得到了很大的压缩，我们不应该把我们的属性或者方法名改更短，这会将代码可读性完全破坏

为什么 Terser 默认没有做这件事？

开启 mangling 需要一个前提条件，所以在 [Terser 文档](https://github.com/terser/terser#cli-mangling-property-names---mangle-props) 里面完全开启这个选项是一个非常危险的行为

很简单，如果你的代码中的属性或是方法完全是内部调用那么借助 mangling 压缩没有任何问题，但是如果你的代码的属性或者方法被外部不可预见地方的调用，那么压缩后的代码将会失效且会导致报错

如果你是一个库的作者，或者你写了一个提供给别人使用的模块，如果你压缩库/模块本身，你所有的方法名和对象的属性名会被改变，所以你所有的 api 都会失效

```ts
// filename: source.js
export function doSomething({ paramA, paramB }) {
  return { sum: paramA + paramB };
}
export class Car {
  constructor({ model }) {
    this.model = model;
  }
  drive() {}
}
```

```ts
// filename: source.min.js
export function doSomething({ o: t, t: o }) {
  return { m: t + o };
}
export class Car {
  constructor({ s: t }) {
    this.s = t;
  }
  i() {}
}
```

当你的用户调用 `doSomething({paramA: 1, paramB: 2})` 或者 `car.drive()` 都会失效

同样的方式如果你引入了其他第三方库或者模块，这些代码也都会被压缩

```ts
// filename: source.js
import { doSomething } from "some-library";

doSomething({ paramA: 1, paramB: 2 });
```

```ts
// filename: source.min.js
import { doSomething as r } from "some-library";

r({ m: 1, o: 2 });
```
