{"componentChunkName":"component---src-templates-post-js","path":"/interesting-js/","result":{"data":{"markdownRemark":{"html":"<h3 id=\"js-执行上下文（作用域）以及变量提升\" style=\"position:relative;\"><a href=\"#js-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%89%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87\" aria-label=\"js 执行上下文（作用域）以及变量提升 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JS 执行上下文（作用域）以及变量提升</h3>\n<p>先看题目：以下代码输出分别是什么</p>\n<h5 id=\"平安的一道笔试题\" style=\"position:relative;\"><a href=\"#%E5%B9%B3%E5%AE%89%E7%9A%84%E4%B8%80%E9%81%93%E7%AC%94%E8%AF%95%E9%A2%98\" aria-label=\"平安的一道笔试题 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>平安的一道笔试题</h5>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token string\">' try'</span><span class=\"token punctuation\">)</span>\n    a <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token string\">' catch'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token string\">' inner function fn'</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token string\">' inner function a'</span><span class=\"token punctuation\">)</span>\n    a <span class=\"token operator\">=</span> <span class=\"token number\">1000</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token string\">'outer result'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>题目简单先试着预想一下执行结果</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>输出</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// [Function] inner function a</span>\n<span class=\"token comment\">// 1 catch</span>\n<span class=\"token comment\">// 1 inner function fn</span>\n<span class=\"token comment\">// 10 outer result</span></code></pre></div>\n<p>是否和预想的一致呢？</p>\n<p>先来了解几个概念：</p>\n<ul>\n<li>\n<p>每一个函数都有自己的执行上下文 EC（执行环境 execution context）</p>\n<ul>\n<li>全局脚本是一个全局上下文</li>\n</ul>\n</li>\n<li>\n<p>EC 预解析的时候会有变量提升</p>\n<ul>\n<li>只有关键字声明的变量才会有变量提升</li>\n<li>函数优先级高于普通变量</li>\n</ul>\n</li>\n</ul>\n<p>下面开始分析一下执行结果\n首先 fn 会获得变量提升然后声明并且赋值全局变量 <code class=\"language-text\">var a = 10</code></p>\n<p>执行 fn：</p>\n<ul>\n<li>\n<p>首先 fn 内部进行变量提升</p>\n<ul>\n<li>内部函数 a 提升到当前 EC 顶部</li>\n<li>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token string\">' inner function a'</span><span class=\"token punctuation\">)</span>\na <span class=\"token operator\">=</span> <span class=\"token number\">1000</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>主要的一点：fn 内部的变量 a 已经被重新声明 相当于 <code class=\"language-text\">var a = function () {}</code> 所以此处 fn 内部的 a 相当于局部变量不在和全局上下文的 a 关联，fn 内部改变不会影响到全局</li>\n</ul>\n</li>\n</ul>\n<p>fn 内部输出：</p>\n<ul>\n<li>a 本身是个函数，invoke a() 输出 <code class=\"language-text\">[Function] inner function a</code>，然后将 fn 内部的 a 重新赋值为 1000</li>\n<li>\n<p>执行 try 语句：</p>\n<ul>\n<li>a 是 1000 所以 invoke a()会抛出异常 <code class=\"language-text\">a is not a function</code> 被 catch 语句捕获，当前 try 语句终端不在继续向下执行</li>\n<li><em>try 语句内部的 <code class=\"language-text\">a = 100</code> 只是简单的赋值操作，没有关键字声明所以没有变量提升</em></li>\n</ul>\n</li>\n<li>\n<p>执行 catch 语句</p>\n<ul>\n<li>重新赋值 <code class=\"language-text\">a = 1</code>，输出 <code class=\"language-text\">a catch</code></li>\n</ul>\n</li>\n<li>try catch 语句执行结束继续向下执行, 此时 a 已经被 catch 语句赋值为 1 输出 <code class=\"language-text\">1 inner function fn</code></li>\n</ul>\n<p>fn 执行结束继续执行全局上下文环境中的代码，上面说了 fn 内部的 a 相当于局部变量不在和全局上下文的 a 关联，fn 内部改变不会影响到全局, 所以全局上下文中 a 依旧是 10，输出 10\n运行结束</p>\n<h3 id=\"深入理解连等赋值问题\" style=\"position:relative;\"><a href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%9E%E7%AD%89%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98\" aria-label=\"深入理解连等赋值问题 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>深入理解“连等赋值”问题</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> n<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a\na<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> n<span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token comment\">// --> undefined</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token comment\">// --> { n: 2 }</span></code></pre></div>\n<p>理解该问题需要知道以下两点：</p>\n<ul>\n<li>JS 引擎对赋值表达式的处理过程</li>\n<li>赋值运算的右结合性</li>\n</ul>\n<h5 id=\"js-引擎对赋值表达式的处理过程\" style=\"position:relative;\"><a href=\"#js-%E5%BC%95%E6%93%8E%E5%AF%B9%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B\" aria-label=\"js 引擎对赋值表达式的处理过程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JS 引擎对赋值表达式的处理过程</h5>\n<p>如赋值表达式 <code class=\"language-text\">A = B</code></p>\n<ol>\n<li>计算表达式左表达式 A，得到一个引用 refA</li>\n<li>计算表达式 B，得到一个引用 refB</li>\n<li>通过 <code class=\"language-text\">GetValue(refB)</code> 得到 valueB</li>\n<li>\n<p>进行判断，当如下情况全部符合则抛出语法异常</p>\n<ol>\n<li>refA 是一个引用</li>\n<li>refA 是一个严格引用</li>\n<li>refA 是一个 <code class=\"language-text\">environment records</code>(<strong>这里理解是 refA 是一个声明的变量或者是对象的某个属性</strong>)</li>\n<li>refA 的引用名是’eval‘或’arguments‘</li>\n</ol>\n</li>\n<li>将 valueB 赋给 refA 指向的名称绑定</li>\n<li>返回 valueB</li>\n</ol>\n<p><em><code class=\"language-text\">GetValue(refB)</code> 是通过一系列判断得出 value 值，具体步骤参考<a href=\"http://es5.github.io/#x8.7.1\">GetValue(refB)</a></em></p>\n<p>具体参考：</p>\n<blockquote>\n<p><a href=\"http://es5.github.io/#x11.13.1\">http://es5.github.io/#x11.13.1</a></p>\n</blockquote>\n<h5 id=\"结合性\" style=\"position:relative;\"><a href=\"#%E7%BB%93%E5%90%88%E6%80%A7\" aria-label=\"结合性 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>结合性</h5>\n<p>所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。\n赋值表达式是右结合的。这意味着：<code class=\"language-text\">A1 = A2 = A3 = A4</code> 等价于 <code class=\"language-text\">A1 = (A2 = (A3 = A4))</code></p>\n<p>总的简单 s 来说就是：<strong><em>先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用</em></strong></p>\n<h5 id=\"分析\" style=\"position:relative;\"><a href=\"#%E5%88%86%E6%9E%90\" aria-label=\"分析 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>分析</h5>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">a<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> n<span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>首先得到 a.x 和 a 的两个引用\n得到右表达式是一个对象 <code class=\"language-text\">{ n: 2 }</code>\na.x 和 a 的两个引用并且判断属于 <code class=\"language-text\">environment records</code>（a.x 属于对象的某个属性，a 属于当前上下文的变量 a）\n将 <code class=\"language-text\">{ n: 2 }</code> 赋值给 当前上下文变量 a 的 refA，a 已被重新赋值为 <code class=\"language-text\">{ n: 2 }</code>\n将 <code class=\"language-text\">{ n: 2 }</code> 赋值给 当前上下文变量 a.x 的 ref（a.x）<em>ref（a.x）与 ref（b.x）是同一个</em>, refA 已经与 <code class=\"language-text\">{ n: 2 }</code> 重新绑定，所以此时 b 为 <code class=\"language-text\">{ n: 1, x: { n: 2 } }</code></p>\n<p>所以最终结果：a 为 <code class=\"language-text\">{ n：2 }</code>，b 为 <code class=\"language-text\">{ n: 1, x: { n: 2 } }</code>, 并且由于是同一个对象 <code class=\"language-text\">{ n: 2 }</code> 赋值给 b.x 以及 a 获得的引用相同，所以 <code class=\"language-text\">b.x === a</code></p>\n<p>所以 <code class=\"language-text\">a.x</code> 为 <code class=\"language-text\">undefined</code>, <code class=\"language-text\">b.x</code> 为 <code class=\"language-text\">{ n: 2 }</code></p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000004224719\">由 ES 规范学 JavaScript(二)：深入理解“连等赋值”问题</a></p>\n</blockquote>\n<h3 id=\"立即执行的函数immediately-invoked-function的具名函数表达式named-function-expression-nfe\" style=\"position:relative;\"><a href=\"#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0immediately-invoked-function%E7%9A%84%E5%85%B7%E5%90%8D%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8Fnamed-function-expression-nfe\" aria-label=\"立即执行的函数immediately invoked function的具名函数表达式named function expression nfe permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// [Function A]</span>\n  <span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span><span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// undefined</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// [Function A]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>上面立即执行函数中直接将 1 赋值给一个未声明的变量，正常逻辑下我们知道会将他绑定的全局作为全局变量，但是上面的输出显然不是如此，原因在于匿名执行函数有了名字且和赋值的变量 A 同名</p>\n<p>有了名字的函数（NFE）有两个特性：</p>\n<ul>\n<li>作为函数名的标识符（在这里是 A ）只能从函数体内部访问，在函数外部访问不到 (IE9+)</li>\n<li>绑定为函数名的标识符（在这里是 A）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），所以在 NFE 函数体内对 A 重新赋值是无效的</li>\n</ul>\n<p>创建 NFE 的机制：</p>\n<blockquote>\n<p>The production FunctionExpression : function Identifier (\nFormalParameterListopt ) { FunctionBody }\nis evaluated as follows:</p>\n</blockquote>\n<ul>\n<li>Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument</li>\n<li>Let envRec be funcEnv’s environment record.</li>\n<li>Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.</li>\n<li>Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.</li>\n<li>Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.</li>\n<li>Return closure.</li>\n</ul>\n<p>注意步骤 3 和 5，分别调用了 createImmutableBinding 和 InitializeImmutableBinding 内部方法，<strong>创建的是不可更改的绑定</strong></p>\n<p>要理解这两个特性，最重要的是搞清楚标识符 A 的绑定记录保存在哪里。让我们问自己几个问题：</p>\n<ol>\n<li>标识符 A 与 该 NFE 是什么关系？ 两层关系：首先，该 NFE 的 name 属性是 字符串 'A'；更重要的是，A 是该 NFE 的一个自由变量。在函数体内部，我们引用了 A，但 A 既不是该 NFE 的形参，又不是它的局部变量，那它不是自由变量是什么！解析自由变量，要从函数的 [[scope]] 内部属性所保存的词法环境 (Lexical Environment) 中查找变量的绑定记录。</li>\n<li>标识符 A 保存在全局执行环境（Global Execution Context）的词法环境(Lexical Environment)中吗？ 答案是否。如果你仔细看过 ES5 Section 13 这一节，会发现创建 NFE 比创建 匿名函数表达式 （Anonymous Function Expression, AFE） 和 函数声明 (Function Declaration) 的过程要复杂得多</li>\n</ol>\n<p>那么为何创建 NFE 要搞得那么复杂呢？就是为了实现 NFE 的只能从函数内部访问 A，而不能从外部访问这一特性！咋实现的？ 创建 NFE 时，创建了一个专门的词法环境用于保存 A 的绑定记录(见上面步骤 1~3)！对于 NFE, 有如下关系：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token constant\">A</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>scope<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n  <span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>  Lexical Environment <span class=\"token punctuation\">{</span><span class=\"token string\">'environment record'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token function-variable function\">A</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> outer<span class=\"token operator\">:</span> <span class=\"token operator\">--</span><span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span> Lexical Environment <span class=\"token keyword\">of</span> Global Context <span class=\"token punctuation\">{</span><span class=\"token string\">'environment record'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> outer <span class=\"token operator\">--</span><span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token keyword\">null</span></code></pre></div>\n<p>可见，A 的绑定记录不在全局执行上下文的词法环境中，故不能从外部访问</p>\n<p>但是有个疑问：如果内部输出的时候进行赋值呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 100</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>却可以打印出 100，<a href=\"#JS引擎对赋值表达式的处理过程\">JS 引擎对赋值表达式的处理过程</a>中我们知道赋值表达式最终结果是返回这个值，如果 NFE 内部没有成功赋值为何可以打印出 100 呢？</p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/q/1010000002810093\">在 JavaScript 的立即执行的具名函数 A 内修改 A 的值时到底发生了什么</a></p>\n</blockquote>","timeToRead":6,"excerpt":"JS 执行上下文（作用域）以及变量提升 先看题目：以下代码输出分别是什么 平安的一道笔试题 题目简单先试着预想一下执行结果 . . . 输出 是否和预想的一致呢？ 先来了解几个概念： 每一个函数都有自己的执行上下文 EC（执行环境 execution context…","frontmatter":{"title":"Interesting js","thumbnail":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAADHUlEQVQ4y5VUbUhTURg+26JfQb8F9Z5t9+7jujk/tmuZaGppGWZ+pGSoGKalpaLO/P6MpWJUgoFR9LNCsgwUpSxLMW2bUwkxzZWa5QdpJlpkcTvnuPzXpgcuz3uel/vwPO859wJgZ31McgefMlhSf6tlRBh/3Ja6rTVKl1au0gl4v3pdKlw2MGBbazJWQ/BrhVyIcaVO6rTeRE/z92T86g26G3N/HkgESNyx2Ii3FjwGQWAuV7nFzeXJe5HTXz8bGH7ZQLdj7ns9LUC1Y0GzmNt0GedOok6dURtm0lT850zl7EYJy8/lMhmYn9czImu03L6YCfoQHAvxJFHHIz11E1Eev63xmomFVA0/c041vVik2IN7sxdZgV2xHugP+ig/MCTWgrlmNeGG3bUDo8Fei+MRngtTcZ689ZQmFvMfTm+6Xyiwcygv4CGbS05ki540AvfxFlY3PObF8SMe2vlBRueEexaFTjCvl9mP2wGPAROlI/UbSisyQp9JJD5jorgvE9CXN1PcXdwzUpzA7MwBNFfHB9ILA4i7Xiog0Sz25weo/SYLcmmE3JJJwrmRBBQndCjUIM0ET+ER0EMdJIPugiF9aAQLaG99Kwnk+6FvJ+b7oJ+w3/UAsMh0/xerleWBGpketMHjROwJPCFvg+EbHTBs8BkMXTdJjvKvYCC5Ki9hsMg2Z8dxm8VxuzC2wJh09Ky3iiOH++hYHs12qIsKJUKdMAwYHYlhd3XIZatrFJnNLcnZO/dhvPUhPLn0CEZbW8Qx7KbzSNJ/Tfk6dlfL5Als6FLD6C03JemDTZLU99forCzMj7q4C5w178BzeBjFDrIvls9WgTJlCREsVZYylYqi7kpF8Vq1vHD1iizfA/OV8mIhj7Adhjt2hwWRCKmL2HKPYra8FAmnVCsKyWdQpSgkvUZpxvZ+VXImGeSo64jDbFWNU7bKIP7Xuyy/tPW91jM5YNsrwa2KvJimrvM+r67di+sSZRk5hAuaGiRcAAxM/jYdypIJqmQpu30VmeTGRij1hCtgKwAaAdjRwpFt6CSlE8ncaCZJgOLvSOcvuDsP7YSsLpgAAAAASUVORK5CYII=","width":150,"height":150,"src":"/static/15b1871ea4c811121febad33ed4becb6/4148e/post.png","srcSet":"/static/15b1871ea4c811121febad33ed4becb6/4148e/post.png 1x"}}},"slug":"interesting-js","date":"2019-03-12T00:00:00.000Z","categories":["Language"],"tags":["js"],"template":"post"},"fields":{"slug":"/interesting-js/","date":"2019-03-12T00:00:00.000Z"}}},"pageContext":{"slug":"/interesting-js/"}}}