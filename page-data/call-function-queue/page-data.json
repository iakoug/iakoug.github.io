{"componentChunkName":"component---src-templates-post-js","path":"/call-function-queue/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"实现-axios-的拦截器\" style=\"position:relative;\"><a href=\"#%E5%AE%9E%E7%8E%B0-axios-%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8\" aria-label=\"实现 axios 的拦截器 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实现 axios 的拦截器</h2>\n<p>如何实现 axios 的拦截器听起来很空泛，可以换个问法：有若干个函数，如何保证他们彼此依次按顺序调用？\n这里借助 Promise 的链式调用的小技巧，分别把每一个函数包装为 Promise 链上的每一个回调。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 函数队列</span>\n<span class=\"token keyword\">const</span> fns <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">// 借助 reduce</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">generatePromiseChain</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fns</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> fns<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">promises<span class=\"token punctuation\">,</span> fn</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    promises <span class=\"token operator\">=</span> promises<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> promises\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// invoke execution</span>\n<span class=\"token function\">generatePromiseChain</span><span class=\"token punctuation\">(</span>fns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'end'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这样我们就得到了一条按顺序执行的 Promise 链。\n进行简单测试：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> fns <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'3'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span>\n\n<span class=\"token function\">generatePromiseChain</span><span class=\"token punctuation\">(</span>fns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'end'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// output:</span>\n<span class=\"token comment\">// 1</span>\n<span class=\"token comment\">// 2</span>\n<span class=\"token comment\">// 3</span>\n<span class=\"token comment\">// end</span></code></pre></div>\n<p>上面已经实现一条按序调用的函数队列了，但是函数的执行是一次性完成的而无法由用户主动控制，那么如何控制这条 Promise 链，让每次的函数调用依赖用户的控制呢？换句话说就是每一个函数的调用需要一个开关，当开关打开的时候才发起调用。</p>\n<h2 id=\"实现-vue-router-的路由拦截\" style=\"position:relative;\"><a href=\"#%E5%AE%9E%E7%8E%B0-vue-router-%E7%9A%84%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA\" aria-label=\"实现 vue router 的路由拦截 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实现 vue-router 的路由拦截</h2>\n<p>这里的实现方式的关键在于这个“开关”。\n既然开关打开是才开启下一个函数的调用，那么就把开关设计为一个函数，把下一个函数的的调用包装在这个开关内部（类似装饰者模式）即可，那么每次调用开关这个函数就是开启下一个函数的调用。\n下面封装一个 compose 函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 构造 compose 函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fns</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 初始化调用函数队列 从第一个开始自调用</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">order <span class=\"token operator\">=</span> <span class=\"token number\">0</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 队列存在当前项函数便发起调用 同时在当前项函数入参新增开关回调函数 开关内部包装下一个函数的调用</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      fns<span class=\"token punctuation\">[</span>order<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span>\n      fns<span class=\"token punctuation\">[</span>order<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 函数队列索引自加1进行下一个函数调用</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>order <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>compose 已经基本完成封装，测试结果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> fns <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token parameter\">next</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token parameter\">next</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'end'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'3'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span>\n\n<span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>fns<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 由于函数队列的第三个参数没有开启下一个函数调用的开关，所以输出结果如下：</span>\n\n<span class=\"token comment\">// output:</span>\n<span class=\"token comment\">// 1</span>\n<span class=\"token comment\">// 2</span>\n<span class=\"token comment\">// end</span></code></pre></div>\n<p>上面已经说了函数队列调用的两种模式：</p>\n<ul>\n<li>链式同步调用</li>\n<li>开关式同步调用</li>\n</ul>\n<p>下面再继续说说第三种洋葱模型式函数队列调用（第三次提到了 🤣，但既然是统一归档，那么精粹的同类型函数队列的调用岂能不放在一起）</p>\n<h2 id=\"实现-koa2-洋葱模型\" style=\"position:relative;\"><a href=\"#%E5%AE%9E%E7%8E%B0-koa2-%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B\" aria-label=\"实现 koa2 洋葱模型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实现 Koa2 洋葱模型</h2>\n<p>简单的来说洋葱模型式调用就是相当于给每一个函数调用增加了一个支持后续处理的容错机制，属于由外向内调用处理一部分业务逻辑（或出现问题时）再由内向外可以处理后续逻辑的机制。\n具体的细节很简单不再赘述。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 构造 compose 函数（ctx 为 Koa 的上下文对象）</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">compose</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">ctx</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">async</span> <span class=\"token parameter\">middlewares</span> <span class=\"token operator\">=></span>\n  <span class=\"token comment\">// 接受函数队列借助 reduceRight 方法由由向左进行包装（这样才可以保证最外层函数是队列的第一个最先执行）</span>\n  <span class=\"token keyword\">await</span> middlewares<span class=\"token punctuation\">.</span><span class=\"token function\">reduceRight</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token parameter\">next<span class=\"token punctuation\">,</span> middleware</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n      <span class=\"token comment\">// 从右向左将队列的每个函数包装为下一个函数的 next 开关</span>\n      <span class=\"token punctuation\">(</span>next <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ctx<span class=\"token punctuation\">,</span> middleware<span class=\"token punctuation\">,</span> oldNext</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n        <span class=\"token keyword\">await</span> <span class=\"token function\">middleware</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> oldNext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> middleware<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>以上便简单封装完毕了。\n下面进行测试：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> middlewares <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ctx<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ctx<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ctx<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span>\n\n<span class=\"token function\">compose</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>middlewares<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// output:</span>\n<span class=\"token comment\">// 1</span>\n<span class=\"token comment\">// 3</span>\n<span class=\"token comment\">// 5</span>\n<span class=\"token comment\">// 6</span>\n<span class=\"token comment\">// 4</span>\n<span class=\"token comment\">// 2</span></code></pre></div>\n<h2 id=\"last\" style=\"position:relative;\"><a href=\"#last\" aria-label=\"last permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Last</h2>\n<p>以上便是本文归档的三种函数队列简单调用的模式：</p>\n<ul>\n<li>链式调用</li>\n<li>开关式调用</li>\n<li>洋葱模型式调用</li>\n</ul>\n<p>The End.🎆</p>","timeToRead":2,"excerpt":"实现 axios 的拦截器 如何实现 axios 的拦截器听起来很空泛，可以换个问法：有若干个函数，如何保证他们彼此依次按顺序调用？\n这里借助 Promise 的链式调用的小技巧，分别把每一个函数包装为 Promise…","frontmatter":{"title":"Call function queue - 三种函数队列调用问题的归档","thumbnail":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAADHUlEQVQ4y5VUbUhTURg+26JfQb8F9Z5t9+7jujk/tmuZaGppGWZ+pGSoGKalpaLO/P6MpWJUgoFR9LNCsgwUpSxLMW2bUwkxzZWa5QdpJlpkcTvnuPzXpgcuz3uel/vwPO859wJgZ31McgefMlhSf6tlRBh/3Ja6rTVKl1au0gl4v3pdKlw2MGBbazJWQ/BrhVyIcaVO6rTeRE/z92T86g26G3N/HkgESNyx2Ii3FjwGQWAuV7nFzeXJe5HTXz8bGH7ZQLdj7ns9LUC1Y0GzmNt0GedOok6dURtm0lT850zl7EYJy8/lMhmYn9czImu03L6YCfoQHAvxJFHHIz11E1Eev63xmomFVA0/c041vVik2IN7sxdZgV2xHugP+ig/MCTWgrlmNeGG3bUDo8Fei+MRngtTcZ689ZQmFvMfTm+6Xyiwcygv4CGbS05ki540AvfxFlY3PObF8SMe2vlBRueEexaFTjCvl9mP2wGPAROlI/UbSisyQp9JJD5jorgvE9CXN1PcXdwzUpzA7MwBNFfHB9ILA4i7Xiog0Sz25weo/SYLcmmE3JJJwrmRBBQndCjUIM0ET+ER0EMdJIPugiF9aAQLaG99Kwnk+6FvJ+b7oJ+w3/UAsMh0/xerleWBGpketMHjROwJPCFvg+EbHTBs8BkMXTdJjvKvYCC5Ki9hsMg2Z8dxm8VxuzC2wJh09Ky3iiOH++hYHs12qIsKJUKdMAwYHYlhd3XIZatrFJnNLcnZO/dhvPUhPLn0CEZbW8Qx7KbzSNJ/Tfk6dlfL5Als6FLD6C03JemDTZLU99forCzMj7q4C5w178BzeBjFDrIvls9WgTJlCREsVZYylYqi7kpF8Vq1vHD1iizfA/OV8mIhj7Adhjt2hwWRCKmL2HKPYra8FAmnVCsKyWdQpSgkvUZpxvZ+VXImGeSo64jDbFWNU7bKIP7Xuyy/tPW91jM5YNsrwa2KvJimrvM+r67di+sSZRk5hAuaGiRcAAxM/jYdypIJqmQpu30VmeTGRij1hCtgKwAaAdjRwpFt6CSlE8ncaCZJgOLvSOcvuDsP7YSsLpgAAAAASUVORK5CYII=","width":150,"height":150,"src":"/static/15b1871ea4c811121febad33ed4becb6/4148e/post.png","srcSet":"/static/15b1871ea4c811121febad33ed4becb6/4148e/post.png 1x"}}},"slug":"call-function-queue","date":"2019-10-08T00:00:00.000Z","categories":["Algorithm","Popular"],"tags":["interceptor","reduce","compose","functional","vue-router","redux"],"template":"post"},"fields":{"slug":"/call-function-queue/","date":"2019-10-08T00:00:00.000Z"}}},"pageContext":{"slug":"/call-function-queue/"}}}