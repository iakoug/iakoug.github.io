{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/archer/source/CNAME","path":"CNAME","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/logo-36.png","path":"assets/logo-36.png","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/logo-48.png","path":"assets/logo-48.png","modified":1,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/logo-64.png","path":"assets/logo-64.png","modified":1,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":1,"renderable":1},{"_id":"themes/archer/source/images/avatar_.png","path":"images/avatar_.png","modified":1,"renderable":1},{"_id":"themes/archer/source/images/wechat_.jpg","path":"images/wechat_.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":1,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":1,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/archer/source/images/post_.JPG","path":"images/post_.JPG","modified":1,"renderable":1},{"_id":"themes/archer/source/images/site_.JPG","path":"images/site_.JPG","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550808959469},{"_id":"source/404.md","hash":"577791aa24ecec4b33d17acca505d4e0849bfc02","modified":1549801924000},{"_id":"themes/archer/.DS_Store","hash":"4e15ba49a799d94b130c2b5413f1289de3d41ca6","modified":1550812864070},{"_id":"source/manifest.json","hash":"77bf0e97fabb77a4b3157589567da236006500c2","modified":1550744372310},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1549801924000},{"_id":"themes/archer/_config.yml","hash":"bb20bfd2b7a75a9129a668fbf7cccd64f82ec06c","modified":1567498055808},{"_id":"source/.DS_Store","hash":"7a8f97280a3f1166befbf8e8d2d3f50d4a962af4","modified":1551000245177},{"_id":"themes/archer/package.json","hash":"80a1d936e347e61d9a41a4303ee32dc236017242","modified":1549801924000},{"_id":"themes/archer/README.md","hash":"fa398e05b0318ae4a657256e6ec6738791358d4f","modified":1549801924000},{"_id":"themes/archer/gulpfile.js","hash":"88e2615c21ca95ae7bcdba499e50a54aebcd9f56","modified":1549801924000},{"_id":"themes/archer/webpack.config.js","hash":"d20b6350c50e2981484cb9356a3e21a2124bcd72","modified":1549801924000},{"_id":"themes/archer/webpack.prod.js","hash":"48de76cfa6274895801d3afc89ecbf04ee182a1c","modified":1549801924000},{"_id":"themes/archer/source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550809083470},{"_id":"source/_posts/.DS_Store","hash":"30c1819b0677463110854153e8ebd10f3a6a03ff","modified":1552281310332},{"_id":"source/about/index.md","hash":"fb3569b1e15f42215a1a6c95a020ed1ac07ae250","modified":1552297087279},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"0bb09c3c9d5f56820cb84e3316f60352b731d70c","modified":1549801924000},{"_id":"themes/archer/docs/README-en.md","hash":"ebd8845724cc9c524f1bdc617567bec2223abed6","modified":1549801924000},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"effc2bc9e0cecfd228b19283337ff29649ea5985","modified":1549801924000},{"_id":"themes/archer/layout/404.ejs","hash":"879641b1b5e49c43f2e096cad281f7d74df05127","modified":1549801924000},{"_id":"themes/archer/layout/about.ejs","hash":"06019d835c0a51fed8aa086d1dfcf368f9921b42","modified":1549801924000},{"_id":"themes/archer/layout/index.ejs","hash":"716ba4a30860e36077dfdfffa02c1cd60301d8a3","modified":1549801924000},{"_id":"themes/archer/layout/layout.ejs","hash":"d6f0fc8b3538e02bd7eabd452a33f75a9c6e5b13","modified":1557972351133},{"_id":"themes/archer/layout/site-meta.ejs","hash":"1a200814c7ef027582ab9e4972726ef4a3347aed","modified":1549801924000},{"_id":"themes/archer/layout/post.ejs","hash":"bf95400cec8f533c11115490a54546a74a718984","modified":1551940260207},{"_id":"themes/archer/source/.DS_Store","hash":"bbef7070c1f1b3c72d8eba78dd8fa12181268346","modified":1552734206041},{"_id":"source/_posts/humanbeings/IsLifeAlwaysThisHard.md","hash":"c1ad1e75be140e86ed03a830115091ba2e21b93c","modified":1554269719911},{"_id":"source/_posts/about/HowAnEconomyGrowsAndWhyItCrashes.md","hash":"cc3a67a888c1c7b53a75f461ccdd667ac957c331","modified":1553838929760},{"_id":"source/_posts/humanbeings/alive.md","hash":"861f1ffcc2b612baa1615dfe53205af5b905742f","modified":1552733303054},{"_id":"source/_posts/humanbeings/IsThisInternetWinter.md","hash":"d7d817b7ca589c03f8e3c8f31cde6c56ce71593a","modified":1552381479008},{"_id":"source/_posts/humanbeings/lost.md","hash":"fcb7875afa0dc859d5029e02d02f8f9bb1242d42","modified":1567495072396},{"_id":"source/_posts/humanbeings/death.md","hash":"75d303feb2eb0d3baca66d2ad577f221514aca53","modified":1557127365720},{"_id":"source/_posts/humanbeings/人生天地间 忽如远行客.md","hash":"72fdfc906560317cc390118974d773b4faae78d6","modified":1550976773596},{"_id":"source/_posts/humanbeings/thoughts.md","hash":"503484f8cfd20850f2f882b93016d190463d5f57","modified":1559380770319},{"_id":"source/_posts/todolist/index.md","hash":"0882a719352b1cf31092cd31c37379a087bc2325","modified":1557715471865},{"_id":"source/_posts/humanbeings/人间失格.md","hash":"ca684eff9b646b78f95b5e9d114afc133919e268","modified":1556085347271},{"_id":"source/_posts/writeSomething/.DS_Store","hash":"108ea65da4a855e78040390aa38d5c8432a3a83d","modified":1552297226109},{"_id":"source/_posts/writeSomething/AboutAjax.md","hash":"a14ab9e1f38417a1f5a398aa6824caa9d7e12f31","modified":1562226323161},{"_id":"source/_posts/writeSomething/Fetch_2.md","hash":"30d26e3f6f6eb9ba652b8cd4368419d927ac0137","modified":1558422077457},{"_id":"source/_posts/writeSomething/EventLoop.md","hash":"ab8e1ad979154b5747e52bf5611068a7e64ee7e0","modified":1551948950419},{"_id":"source/_posts/writeSomething/AlgorithmComplexity.md","hash":"12565d00bd8c36ed6ed718385382774f1003c507","modified":1551866807159},{"_id":"source/_posts/writeSomething/Fetch_1.md","hash":"1b87d50ce07d4181d6653e36159d9c6b0b3111f5","modified":1555641053116},{"_id":"source/_posts/writeSomething/FunctionalEventEmitter.md","hash":"be5fba2bddb97091c87d69178a9287d731943ff9","modified":1553838929763},{"_id":"source/_posts/writeSomething/Webpack_1.md","hash":"207480076f18bce612462b512f282fb3e0d54ed2","modified":1567495072398},{"_id":"source/_posts/writeSomething/Fetch_3_concurrency.md","hash":"12b56f994bb636002c1f890ee3a831abd5dc8731","modified":1560422718358},{"_id":"source/_posts/writeSomething/Programming2Advanced.md","hash":"4a533ad1284fd36b6e726309f2842661f3339839","modified":1558604963386},{"_id":"source/_posts/writeSomething/PayAttentionToThoseJs.md","hash":"38df11ebb682fb4191a12b01d62bf12326408e95","modified":1552291085368},{"_id":"source/_posts/writeSomething/WorkEnvConfig.md","hash":"c8b73e04a36e3f931436dcab6be094fd07849a69","modified":1554269303947},{"_id":"source/_posts/writeSomething/appletRouter.md","hash":"6826225840489523a6db8962e24bc300751f7320","modified":1562556190123},{"_id":"source/_posts/writeSomething/dynamicProgrammingAndRecursion.md","hash":"ad26d0ee4f5cbed7be72b4993b03aa98ffd4ee23","modified":1552282841554},{"_id":"source/_posts/writeSomething/http_tcp.md","hash":"3781363d64fabc98fe34dc27a89f048c0bb19f29","modified":1567495072398},{"_id":"source/_posts/writeSomething/jsDesignPattern.md","hash":"9b274890402a387bdad10b3bec520824b97bbf0a","modified":1551774516180},{"_id":"source/_posts/writeSomething/interestingCode.md","hash":"abc8a5c3f14eb7b3703ae612392691e06ac54af2","modified":1552731335344},{"_id":"source/_posts/writeSomething/koa2OnionModel.md","hash":"90851b0113db084b22b1b1e9c740cf48d9c32645","modified":1552286751190},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"2f5f9073378f628a9124792b5301c1540bc5a264","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"457d2c8efcbdd08eccc5ea14c7e89f151a5a4088","modified":1550824601490},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"f5a054ed072971223ca9d5737cfea05644074a7c","modified":1552207412000},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"2aea84cb43f4479131620b3c3dfd7cebe9be36ba","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"efde86772642dff2bb777556775b516f0cdc6e99","modified":1550823882959},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"12e28693dc53cab5f6fd389f15ea0f811c9c37e9","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"d2a8ae42792ffd391f591dbcda3bdbc6fddebe02","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"2d068432031b3bebf9438c775370a2d1b4492d6b","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"418559ab11726f69621c3a58cd21903adff1e48e","modified":1549801924000},{"_id":"themes/archer/layout/_partial/google-adsense.ejs","hash":"8d86c7decc6f39bc6eef13feafe4a1a820f7374b","modified":1549801924000},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"cd0d34a811dc4666980d57c00d70dd82bd5450eb","modified":1549801924000},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1549801924000},{"_id":"themes/archer/source/assets/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550809961832},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1549801924000},{"_id":"themes/archer/source/assets/favicon.ico","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/assets/logo-36.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/assets/logo-48.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/css/mobile.css","hash":"0b7ac34da7d703064423480fc0526d91fa5716bc","modified":1549801924000},{"_id":"themes/archer/source/assets/logo-64.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/css/style.css","hash":"4e9c01e927d36359bd716c25ea03a79974c18df5","modified":1557885651077},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1549801924000},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1549801924000},{"_id":"themes/archer/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1552734354504},{"_id":"themes/archer/source/images/avatar_.png","hash":"390c3efba7f1db0aa7841686cfb5e11bf6ca33a7","modified":1554269719913},{"_id":"themes/archer/source/images/wechat_.jpg","hash":"e49b9ddc8799b4302d36f75ed5749415ce4e62b0","modified":1554269719918},{"_id":"themes/archer/source/images/favicon.ico","hash":"6484806109ed1950f6700639a86b96c6681d6f9e","modified":1547608978327},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1549801924000},{"_id":"themes/archer/source/scripts/main.js","hash":"258b08f308c2a78f6cc0a81cf353994da771966a","modified":1549801924000},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1549801924000},{"_id":"themes/archer/src/js/browser.js","hash":"03017b1e89b59346e681464c7609593c9aafa54c","modified":1549801924000},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1549801924000},{"_id":"themes/archer/src/js/fancybox.js","hash":"0ce36efa325767c0ee7d5e5dfa174c68dd606e72","modified":1549801924000},{"_id":"themes/archer/src/js/init.js","hash":"989dea03ce93962b6a52818ee770ca3891679322","modified":1549801924000},{"_id":"themes/archer/src/js/main.js","hash":"58329fe74df0d4411d9486ebfc4c5fbc457f073f","modified":1549801924000},{"_id":"themes/archer/src/js/scroll.js","hash":"11ae5ca33f6f84897ef4a01697a624770bea2025","modified":1549801924000},{"_id":"themes/archer/src/js/mobile.js","hash":"3c826a4385dc58ee878e5ea9bf3a25fac5d2b307","modified":1549801924000},{"_id":"themes/archer/src/js/initSidebar.js","hash":"522aba19524b49efd323a2199f6eaa7396f1bd48","modified":1551678880702},{"_id":"themes/archer/src/js/search.js","hash":"af9bdbff06987fdca8340ea49ccd91e993b9be53","modified":1549801924000},{"_id":"themes/archer/src/js/share.js","hash":"dff48b27ac212c4ea8e0c4c5ee323862c06c2882","modified":1549801924000},{"_id":"themes/archer/src/js/sidebar.js","hash":"ee761637d37b9b1c7934984438b38d39aeca53eb","modified":1551679019908},{"_id":"themes/archer/src/js/tag.js","hash":"156547cad5230c899cac12d3d29e60f5a103b7c4","modified":1549801924000},{"_id":"themes/archer/src/js/toc.js","hash":"2a01f07f302ccea3d36787571e34fd070ac42797","modified":1549801924000},{"_id":"themes/archer/src/js/util.js","hash":"1c244b8def678df797ab3c049a03998db4f9dabb","modified":1549801924000},{"_id":"themes/archer/src/scss/_common.scss","hash":"71aa8bf9d5c66a432fd32b96a0953d53fcb533d2","modified":1549801924000},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"27d5380e6a190071c0877a3651f3d877b91e03a1","modified":1549801924000},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"b33d0d7e2e2807f50735f43e742f3c33471d38f7","modified":1549801924000},{"_id":"themes/archer/src/scss/_variables.scss","hash":"edd9e3dd34837f9c4e5f45eee8dc051b4caa8d28","modified":1549801924000},{"_id":"themes/archer/src/scss/mobile.scss","hash":"76a65f93c8bbcd5bc5fb7fca55919a12e7543a2b","modified":1549801924000},{"_id":"themes/archer/src/scss/style.scss","hash":"2d959b9c6a3a5b70df1bfa4ba0a6b8b758454e74","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549801924000},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1549801924000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1549801924000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1549801924000},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1549801924000},{"_id":"themes/archer/package-lock.json","hash":"229960bd92beff7974f422f7cb2025ae610a2191","modified":1549801924000},{"_id":"source/_posts/writeSomething/http_tcp/ssl_1.jpg","hash":"48c8b1e722e987d123087b7923a2649ba768beeb","modified":1567495072399},{"_id":"source/_posts/writeSomething/http_tcp/http2.jpg","hash":"11915710b8184f8e4470964f45c9c26904c71bde","modified":1567495072398},{"_id":"source/_posts/writeSomething/http_tcp/ssl_2.jpg","hash":"d05edd77b332b0bdb2a9f8b8d11733a3093605ef","modified":1567495072399},{"_id":"source/_posts/writeSomething/koa2OnionModel/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550838469096},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"13d9ccd31f59773caa29e6c9c1fcfe9d468051d2","modified":1567497516995},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"7691642fb9375607e0ac988a7420999e242cb2c9","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"b27469f19f35ec2037c7bce736a12e9dfb5e360b","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cadd97820a23d01d8b7e2f19a86e5290cef5a8a6","modified":1550824477536},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"6bf59f01235c87cbca1555e4e027139de06688c2","modified":1550824322941},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"790d76f2667377db78a7d04bad8d629e47e7aab0","modified":1549801924000},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"731d3980ac665d96dc6a40d31c2f8b86a221a8bb","modified":1549801924000},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"291cc0a4a444a93b93c32e2c39383c70e36e46de","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"2d38af7cb5aabc0af99de239bd180c516ec4c56c","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"daa78b17a773bca569f1c8ca2c916495ca138da6","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"147214469c4909eb94943599883f9fa0f3cc090d","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"d6e1a192cac5dcf365ce1a52df4f23feafeeb849","modified":1549801924000},{"_id":"themes/archer/source/images/post_.JPG","hash":"d61433de0fe446d53c899eaf18e29a1242471c1c","modified":1554269719915},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"64a721c19c8c4d5b2b07d6aedcde1565be734e6d","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"75776d8b85c8d2edc27eb7ed60d7c371f5109da0","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"8a74f79686e327b0566ea606fd7625eb57daf898","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"97171c34f9b0676cf9113a1d637955415770f89b","modified":1549801924000},{"_id":"source/_posts/writeSomething/PayAttentionToThoseJs/virturedom.png","hash":"8414992181ff755e9295fb4e1c84c2373968f5a9","modified":1552281270917},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1549801924000},{"_id":"themes/archer/source/images/site_.JPG","hash":"eacf841a16154745769ab2c03d855611e59f2e30","modified":1554269719917},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"65efbfbaec7d09120ba62fee6e4643e6108098f6","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"73caccbe2634ff84e386d58e7f6ecd52d5ca2151","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"dbd7f802f3812f7e15c12885e495296f3697c580","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"e69b62df7c36d938cc4cf8e1fdcbc7109be41119","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"eaff5b3e942e461109cdb6fd52f1d124b5a11951","modified":1551678648607},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"1229364f7c3484cc2ada6f118c859e3fd1dd9129","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"9f7a3877adccbfaf66ad574dbe2c8dc85fbf2f5a","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a25960d1d9f501e50cb1fe86328dbc65faa29d22","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"9226a04dd9ea8389f88ced34962f1f55192d7a1a","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"fe42459805e4caa303df08964184548c33507d23","modified":1549801924000},{"_id":"source/_posts/writeSomething/koa2OnionModel/onion.png","hash":"64ed5f85efbca9cda0ecb5737edf3430f044f733","modified":1550835653175},{"_id":"source/_posts/about/HowAnEconomyGrowsAndWhyItCrashes/economy_1.png","hash":"82de229d9cc94528dbeca4e9819822847950ef92","modified":1553838929761}],"Category":[{"name":"经济学","_id":"ck03jyxw70005ax4884t5lz1v"},{"name":"当我在扯淡","_id":"ck03jyxwd000aax48d0nhhe6r"},{"name":"思维","_id":"ck03jyxws0013ax48wqbqt245"},{"name":"to do list","_id":"ck03jyxwv001aax484jhdmwr0"},{"name":"ajax","_id":"ck03jyxwy001gax48a4ej8uja"},{"name":"算法","_id":"ck03jyxx0001nax487hfxwavp"},{"name":"封装","_id":"ck03jyxx2001sax48b716nwze"},{"name":"webpack","_id":"ck03jyxx4001zax488b628kz1"},{"name":"技术分享","_id":"ck03jyxx80026ax489fr68s3p"},{"name":"开发环境搭建","_id":"ck03jyxxc002bax482md115wv"},{"name":"计算机网络","_id":"ck03jyxxg002jax48j2gm6vfy"},{"name":"你应该知道的","_id":"ck03jyxy1003cax48y9xpwuoe"}],"Data":[],"Page":[{"layout":"404","title":"[404]","description":"May the Force be with you :&#41;","_content":"","source":"404.md","raw":"---\nlayout: 404\ntitle: \"[404]\"\ndescription: \"May the Force be with you :&#41;\"\n---","date":"2019-02-21T09:46:42.749Z","updated":"2019-02-10T12:32:04.000Z","path":"404.html","comments":1,"_id":"ck03jyxv00000ax48it9b5493","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"{\n    \"dir\": \"auto\",\n    \"lang\": \"zh\",\n    \"name\": \"kwok io\",\n    \"scope\": \"/\",\n    \"display\": \"standalone\",\n    \"start_url\": \"/\",\n    \"short_name\": \"kwok io\",\n    \"theme_color\": \"transparent\",\n    \"description\": \"- kwok io\",\n    \"orientation\": \"any\",\n    \"background_color\": \"transparent\",\n    \"related_applications\": [],\n    \"prefer_related_applications\": false,\n    \"gcm_sender_id\": \"482941778795\",\n    \"gcm_sender_id_comment\": \"Do not change the GCM Sender ID\",\n    \"icons\": [{\n      \"src\": \"/assets/logo-32.png\",\n      \"sizes\": \"32x32\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"/assets/logo-48.png\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/png\"\n    },\n    {\n        \"src\": \"/assets/logo-64.png\",\n        \"sizes\": \"64x64\",\n        \"type\": \"image/png\"\n      }\n    ]\n  }","source":"manifest.json","raw":"{\n    \"dir\": \"auto\",\n    \"lang\": \"zh\",\n    \"name\": \"kwok io\",\n    \"scope\": \"/\",\n    \"display\": \"standalone\",\n    \"start_url\": \"/\",\n    \"short_name\": \"kwok io\",\n    \"theme_color\": \"transparent\",\n    \"description\": \"- kwok io\",\n    \"orientation\": \"any\",\n    \"background_color\": \"transparent\",\n    \"related_applications\": [],\n    \"prefer_related_applications\": false,\n    \"gcm_sender_id\": \"482941778795\",\n    \"gcm_sender_id_comment\": \"Do not change the GCM Sender ID\",\n    \"icons\": [{\n      \"src\": \"/assets/logo-32.png\",\n      \"sizes\": \"32x32\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"/assets/logo-48.png\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/png\"\n    },\n    {\n        \"src\": \"/assets/logo-64.png\",\n        \"sizes\": \"64x64\",\n        \"type\": \"image/png\"\n      }\n    ]\n  }","date":"2019-02-21T10:19:32.310Z","updated":"2019-02-21T10:19:32.310Z","path":"manifest.json","layout":"false","title":"","comments":1,"_id":"ck03jyxv10001ax48eo3r73d2","content":"{\"dir\":\"auto\",\"lang\":\"zh\",\"name\":\"kwok io\",\"scope\":\"/\",\"display\":\"standalone\",\"start_url\":\"/\",\"short_name\":\"kwok io\",\"theme_color\":\"transparent\",\"description\":\"- kwok io\",\"orientation\":\"any\",\"background_color\":\"transparent\",\"related_applications\":[],\"prefer_related_applications\":false,\"gcm_sender_id\":\"482941778795\",\"gcm_sender_id_comment\":\"Do not change the GCM Sender ID\",\"icons\":[{\"src\":\"/assets/logo-32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-64.png\",\"sizes\":\"64x64\",\"type\":\"image/png\"}]}","site":{"data":{}},"excerpt":"","more":"{\"dir\":\"auto\",\"lang\":\"zh\",\"name\":\"kwok io\",\"scope\":\"/\",\"display\":\"standalone\",\"start_url\":\"/\",\"short_name\":\"kwok io\",\"theme_color\":\"transparent\",\"description\":\"- kwok io\",\"orientation\":\"any\",\"background_color\":\"transparent\",\"related_applications\":[],\"prefer_related_applications\":false,\"gcm_sender_id\":\"482941778795\",\"gcm_sender_id_comment\":\"Do not change the GCM Sender ID\",\"icons\":[{\"src\":\"/assets/logo-32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-64.png\",\"sizes\":\"64x64\",\"type\":\"image/png\"}]}"},{"title":"chris kwok","layout":"about","_content":"hi\n\nhere is chris kwok\n\nas a front-end coder\n\nin shanghai\n\n","source":"about/index.md","raw":"---\ntitle: chris kwok\nlayout: about\n---\nhi\n\nhere is chris kwok\n\nas a front-end coder\n\nin shanghai\n\n","date":"2019-03-11T09:38:07.279Z","updated":"2019-03-11T09:38:07.279Z","path":"about/index.html","comments":1,"_id":"ck03jyxvi0002ax48exxtaw4g","content":"<p>hi</p>\n<p>here is chris kwok</p>\n<p>as a front-end coder</p>\n<p>in shanghai</p>\n","site":{"data":{}},"excerpt":"","more":"<p>hi</p>\n<p>here is chris kwok</p>\n<p>as a front-end coder</p>\n<p>in shanghai</p>\n"}],"Post":[{"title":"小岛经济学","date":"2019-03-27T08:53:00.000Z","_content":"读小岛经济学，简单了解经济学概念\n<!-- more -->\n\n这本书的作者是美国经济学家彼得.D.希夫和安德鲁.J.希夫。本书的价值有人形象地用一个等式比喻为：《小岛经济学》=《经济学原理》+《经济学概论》+《国富论》。它让沉闷枯燥的经济学变得如此通俗易懂，经济学本身并不复杂，是经济学家们的解释太复杂了。\n\n# 产出=消费\n故事发生在一个小岛上，这个小岛上有三个人——艾伯、贝克和查理，这座小岛地处热带，却不是天堂。这里的人们生活艰苦，没有任何奢侈品，而且食物种类极少，他们的菜单上只有一道菜：鱼。然而由于他们的生产力的低下，没有任何工具捕鱼，靠着双手捕鱼每天只能捕捞一条鱼，正好满足自己的需求。\n\n小岛上的他们没有存款、借贷、投资也就是 产出=消费 的生产模式。\n\n# 资本\n艾伯突发奇想，他想到了做一个捕鱼器提高捕鱼效率来提高自己生活水平。\n但是问题是，制作渔网需要一天的时间，意味着那一天艾伯将没有食物，而且制作渔网未必能够成功。艾伯决定冒险试一试。忍受着旁人不理解的目光在那天傍晚的夕阳下终于织完了渔网。通过自我牺牲，他创造了资本——渔网。从此，艾伯每天可以捕两条鱼，他的生产力从而翻了一倍。而他的消费水平还是每天一条鱼，这时他的时间就非常充裕，他可以用这些时间做很多其他的事情。\n\n![pic](./economy_1.png)\n\n书中告诉我们资本有时候很容易获得，就看你有没有勇气面对风险忍饥挨饿和他人的嘲笑。\n\n这个故事向我们揭示了一个简单而又深刻的经济原则，也就是：\n\n**通过延迟消费+冒险可以提高人们的生活水平**。艾伯选择暂时不吃鱼，是为了将来可以捕到更多的鱼。而通过冒险，艾伯最终获得了新的资本，也就是渔网，而渔网会为他带来更多的鱼。\n\n**努力使得有限的资源（每一种资源都是有限的）产生最大的效益以尽可能地满足人的需求，这就是我们一直提到的——经济一词，最简单的定义。**\n\n而工具、资本与创新是实现这一目标的关键因素。\n\n# 借贷和储蓄\n艾伯的前途看起来一片光明。但是，另外两个人的情况如何呢？我们是不是创造了一个贫富分化的等级体系？当然不是如此。\n\n\n这时贝克和查理看到艾伯拥有了更多鱼，第一时间想到的是把渔网借过来，可是艾伯并不太相信这两个人，而是建议他们自己也编织一张渔网。可他们俩却担心自己不能编出，而且担心编不出的挨饿。他们俩就想先借艾伯的鱼吃，等织好渔网再还给艾伯。可其中的风险让他们不得不得做数字研究。于是金融思维在这诞生了！贝克向艾伯许诺借一条鱼还两条，这么高的回报率让艾伯心动了，可风险很大。他经过深思熟虑后，决定把渔网借出去。\n\n书中告诉我们：这种借鱼的方式就像商业贷款，而商业贷款是资本的最佳用途，因为这样可以扩大生产。当然，通过借钱或借鱼的做法创业，无法保证企业一定会成功，因为借款人可能无法完全实现自己最初的计划。也就是说，查理和贝克如果不能成功地编织出自己的渔网，艾伯借出的鱼就打了水漂。而这种贷款方式在政府和企业上经常体现，为了让借款能够收回，于是有了信用和信用卡。\n\n\n接下来就是消费贷款的产生，假设艾伯不是把鱼借给贝克和查理，让他们去织自己的网，而是满足两人的借款需求，他们因此可以去度假，情况就会有所不同。\n\n这时艾伯就应该拒绝贷款给他们，因为这样的风险太大，当度假回来贝克和查理无法偿还这些贷款。所以这笔贷款无论是对贷款人还是借款人都是一种负担。如果艾伯承受住他们的冷嘲热讽拒绝贷款就规避了风来的风险。\n\n而应急贷款也是这样产生的，事实证明艾伯拒绝贷款给贝克和查理是明智的。一周之后，这两人都生了一种奇怪的谁都，双双病倒，一个星期都不能去捕鱼，而此时艾伯就把自己储蓄的鱼拿出来借给他们吃，尽管这次“贷款”可能血本无归，不过如果艾伯不提供这份应急贷款，两人可能丧命，而这座岛就失去生产能力了。\n\n如果之前艾伯把自己的储蓄作为没有收益的消费贷款借出的话，这次就无法拿出这份应急贷款了。\n\n事实上，在社会生死攸关之时，储蓄显得至关重要。现在社会，人们都认为信贷市场的有效运作所需要的就是有意愿的借款人，然而，与其他资源一样，在发放贷款前必须先积累储蓄才行。\n\n# 储蓄的价值&消费和生产\n小岛上的故事还在继续，几周后，艾伯、贝克和查理凭借新织的网迅速捕到大量的鱼，从而导致岛上的储蓄迅速膨胀。他们三个从天天捕鱼中解脱出来，终于可以去参加些有创意、有意思的活动了。艾伯可以话些时间设计和制造更实用也更漂亮的棕榈叶服装；贝克采摘椰子，丰富了菜谱以提高了厨艺；查理则盖起了小岛上的第一座小茅屋。\n\n贝尔这时有了个宏伟的计划——建造一个巨型捕鱼器，可靠他一个人不能够完成，于是他提议创立一家合伙公司，三人位合伙人，拿出一周时间建造这个巨型捕鱼器。\n\n三个人朝着目标前进，由于生产力的提升，岛上的储蓄迅速增加，捕鱼器很快建造出来。现在他们又可以实施其他计划了。查理制作了一块冲浪板，开创了一项很酷的新式休闲活动；艾伯创立了一家服装，他还开始筹划自己的一个人的舞台剧，贝克则利用自己的空闲时间考虑小岛上恼人的交通问题，开始设计岛上的第一条独木舟和第一辆手推车。\n\n故事到这里，这说明了一些经济学知识，储蓄不只是提高个人消费能力的手段，还是防止经济受到意外因素影响的重要缓冲器。一笔备用的储蓄会防止经济崩溃，可以迅速重建受损的资产。\n\n书中说道：而美国经济也是如此，过去，美国以储蓄大国而著称，这种丰富的储蓄资本为不断推进的工业活动提供了金融支持，同时也帮助美国的家庭和社区克服意外的困难。可近些年来美国人总是入不敷出。在自给自足的经济中，入小岛经济，这样做根本不可能。但在现实生活中很常见。O8年的金融危机爆发后，政府和经济学家放射性的寻找各种方法，让消费者花得更多、存的更少。而这样的做法却适得其反。作者告诉我们，消费只是我们用来衡量生产的尺度，因为所有生产出来的东西最终都是用于消费的。而生产呢？如果没有生产，也就没有东西可消费的。因此，生产时有价值的。\n\n还有就是，储蓄创造了资本，而资本使生产扩大成为可能，所以储蓄起来的一美元对经济产生的积极影响要大于消费掉的一美元。\n\n他这些观点我不好评判对错，不过确实有道理，而且再一次刷新了我的对于消费和生产的认知观，还可以逐渐形成自己的经济学思维，我觉得这是本书带给我们最大的价值。\n\nlink:\n[https://baijiahao.baidu.com/s?id=1593100704367037405](https://baijiahao.baidu.com/s?id=1593100704367037405)\n","source":"_posts/about/HowAnEconomyGrowsAndWhyItCrashes.md","raw":"---\ntitle: 小岛经济学\ntags:\n  - 经济学\ndate: 2019-03-27 16:53:00\ncategories: 经济学\n---\n读小岛经济学，简单了解经济学概念\n<!-- more -->\n\n这本书的作者是美国经济学家彼得.D.希夫和安德鲁.J.希夫。本书的价值有人形象地用一个等式比喻为：《小岛经济学》=《经济学原理》+《经济学概论》+《国富论》。它让沉闷枯燥的经济学变得如此通俗易懂，经济学本身并不复杂，是经济学家们的解释太复杂了。\n\n# 产出=消费\n故事发生在一个小岛上，这个小岛上有三个人——艾伯、贝克和查理，这座小岛地处热带，却不是天堂。这里的人们生活艰苦，没有任何奢侈品，而且食物种类极少，他们的菜单上只有一道菜：鱼。然而由于他们的生产力的低下，没有任何工具捕鱼，靠着双手捕鱼每天只能捕捞一条鱼，正好满足自己的需求。\n\n小岛上的他们没有存款、借贷、投资也就是 产出=消费 的生产模式。\n\n# 资本\n艾伯突发奇想，他想到了做一个捕鱼器提高捕鱼效率来提高自己生活水平。\n但是问题是，制作渔网需要一天的时间，意味着那一天艾伯将没有食物，而且制作渔网未必能够成功。艾伯决定冒险试一试。忍受着旁人不理解的目光在那天傍晚的夕阳下终于织完了渔网。通过自我牺牲，他创造了资本——渔网。从此，艾伯每天可以捕两条鱼，他的生产力从而翻了一倍。而他的消费水平还是每天一条鱼，这时他的时间就非常充裕，他可以用这些时间做很多其他的事情。\n\n![pic](./economy_1.png)\n\n书中告诉我们资本有时候很容易获得，就看你有没有勇气面对风险忍饥挨饿和他人的嘲笑。\n\n这个故事向我们揭示了一个简单而又深刻的经济原则，也就是：\n\n**通过延迟消费+冒险可以提高人们的生活水平**。艾伯选择暂时不吃鱼，是为了将来可以捕到更多的鱼。而通过冒险，艾伯最终获得了新的资本，也就是渔网，而渔网会为他带来更多的鱼。\n\n**努力使得有限的资源（每一种资源都是有限的）产生最大的效益以尽可能地满足人的需求，这就是我们一直提到的——经济一词，最简单的定义。**\n\n而工具、资本与创新是实现这一目标的关键因素。\n\n# 借贷和储蓄\n艾伯的前途看起来一片光明。但是，另外两个人的情况如何呢？我们是不是创造了一个贫富分化的等级体系？当然不是如此。\n\n\n这时贝克和查理看到艾伯拥有了更多鱼，第一时间想到的是把渔网借过来，可是艾伯并不太相信这两个人，而是建议他们自己也编织一张渔网。可他们俩却担心自己不能编出，而且担心编不出的挨饿。他们俩就想先借艾伯的鱼吃，等织好渔网再还给艾伯。可其中的风险让他们不得不得做数字研究。于是金融思维在这诞生了！贝克向艾伯许诺借一条鱼还两条，这么高的回报率让艾伯心动了，可风险很大。他经过深思熟虑后，决定把渔网借出去。\n\n书中告诉我们：这种借鱼的方式就像商业贷款，而商业贷款是资本的最佳用途，因为这样可以扩大生产。当然，通过借钱或借鱼的做法创业，无法保证企业一定会成功，因为借款人可能无法完全实现自己最初的计划。也就是说，查理和贝克如果不能成功地编织出自己的渔网，艾伯借出的鱼就打了水漂。而这种贷款方式在政府和企业上经常体现，为了让借款能够收回，于是有了信用和信用卡。\n\n\n接下来就是消费贷款的产生，假设艾伯不是把鱼借给贝克和查理，让他们去织自己的网，而是满足两人的借款需求，他们因此可以去度假，情况就会有所不同。\n\n这时艾伯就应该拒绝贷款给他们，因为这样的风险太大，当度假回来贝克和查理无法偿还这些贷款。所以这笔贷款无论是对贷款人还是借款人都是一种负担。如果艾伯承受住他们的冷嘲热讽拒绝贷款就规避了风来的风险。\n\n而应急贷款也是这样产生的，事实证明艾伯拒绝贷款给贝克和查理是明智的。一周之后，这两人都生了一种奇怪的谁都，双双病倒，一个星期都不能去捕鱼，而此时艾伯就把自己储蓄的鱼拿出来借给他们吃，尽管这次“贷款”可能血本无归，不过如果艾伯不提供这份应急贷款，两人可能丧命，而这座岛就失去生产能力了。\n\n如果之前艾伯把自己的储蓄作为没有收益的消费贷款借出的话，这次就无法拿出这份应急贷款了。\n\n事实上，在社会生死攸关之时，储蓄显得至关重要。现在社会，人们都认为信贷市场的有效运作所需要的就是有意愿的借款人，然而，与其他资源一样，在发放贷款前必须先积累储蓄才行。\n\n# 储蓄的价值&消费和生产\n小岛上的故事还在继续，几周后，艾伯、贝克和查理凭借新织的网迅速捕到大量的鱼，从而导致岛上的储蓄迅速膨胀。他们三个从天天捕鱼中解脱出来，终于可以去参加些有创意、有意思的活动了。艾伯可以话些时间设计和制造更实用也更漂亮的棕榈叶服装；贝克采摘椰子，丰富了菜谱以提高了厨艺；查理则盖起了小岛上的第一座小茅屋。\n\n贝尔这时有了个宏伟的计划——建造一个巨型捕鱼器，可靠他一个人不能够完成，于是他提议创立一家合伙公司，三人位合伙人，拿出一周时间建造这个巨型捕鱼器。\n\n三个人朝着目标前进，由于生产力的提升，岛上的储蓄迅速增加，捕鱼器很快建造出来。现在他们又可以实施其他计划了。查理制作了一块冲浪板，开创了一项很酷的新式休闲活动；艾伯创立了一家服装，他还开始筹划自己的一个人的舞台剧，贝克则利用自己的空闲时间考虑小岛上恼人的交通问题，开始设计岛上的第一条独木舟和第一辆手推车。\n\n故事到这里，这说明了一些经济学知识，储蓄不只是提高个人消费能力的手段，还是防止经济受到意外因素影响的重要缓冲器。一笔备用的储蓄会防止经济崩溃，可以迅速重建受损的资产。\n\n书中说道：而美国经济也是如此，过去，美国以储蓄大国而著称，这种丰富的储蓄资本为不断推进的工业活动提供了金融支持，同时也帮助美国的家庭和社区克服意外的困难。可近些年来美国人总是入不敷出。在自给自足的经济中，入小岛经济，这样做根本不可能。但在现实生活中很常见。O8年的金融危机爆发后，政府和经济学家放射性的寻找各种方法，让消费者花得更多、存的更少。而这样的做法却适得其反。作者告诉我们，消费只是我们用来衡量生产的尺度，因为所有生产出来的东西最终都是用于消费的。而生产呢？如果没有生产，也就没有东西可消费的。因此，生产时有价值的。\n\n还有就是，储蓄创造了资本，而资本使生产扩大成为可能，所以储蓄起来的一美元对经济产生的积极影响要大于消费掉的一美元。\n\n他这些观点我不好评判对错，不过确实有道理，而且再一次刷新了我的对于消费和生产的认知观，还可以逐渐形成自己的经济学思维，我觉得这是本书带给我们最大的价值。\n\nlink:\n[https://baijiahao.baidu.com/s?id=1593100704367037405](https://baijiahao.baidu.com/s?id=1593100704367037405)\n","slug":"about/HowAnEconomyGrowsAndWhyItCrashes","published":1,"updated":"2019-03-29T05:55:29.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxw30003ax48k36c4omv","content":"<p>读小岛经济学，简单了解经济学概念<br><a id=\"more\"></a></p>\n<p>这本书的作者是美国经济学家彼得.D.希夫和安德鲁.J.希夫。本书的价值有人形象地用一个等式比喻为：《小岛经济学》=《经济学原理》+《经济学概论》+《国富论》。它让沉闷枯燥的经济学变得如此通俗易懂，经济学本身并不复杂，是经济学家们的解释太复杂了。</p>\n<h1 id=\"产出-消费\"><a href=\"#产出-消费\" class=\"headerlink\" title=\"产出=消费\"></a>产出=消费</h1><p>故事发生在一个小岛上，这个小岛上有三个人——艾伯、贝克和查理，这座小岛地处热带，却不是天堂。这里的人们生活艰苦，没有任何奢侈品，而且食物种类极少，他们的菜单上只有一道菜：鱼。然而由于他们的生产力的低下，没有任何工具捕鱼，靠着双手捕鱼每天只能捕捞一条鱼，正好满足自己的需求。</p>\n<p>小岛上的他们没有存款、借贷、投资也就是 产出=消费 的生产模式。</p>\n<h1 id=\"资本\"><a href=\"#资本\" class=\"headerlink\" title=\"资本\"></a>资本</h1><p>艾伯突发奇想，他想到了做一个捕鱼器提高捕鱼效率来提高自己生活水平。<br>但是问题是，制作渔网需要一天的时间，意味着那一天艾伯将没有食物，而且制作渔网未必能够成功。艾伯决定冒险试一试。忍受着旁人不理解的目光在那天傍晚的夕阳下终于织完了渔网。通过自我牺牲，他创造了资本——渔网。从此，艾伯每天可以捕两条鱼，他的生产力从而翻了一倍。而他的消费水平还是每天一条鱼，这时他的时间就非常充裕，他可以用这些时间做很多其他的事情。</p>\n<p><img src=\"/2019/03/27/about/HowAnEconomyGrowsAndWhyItCrashes/./economy_1.png\" alt=\"pic\"></p>\n<p>书中告诉我们资本有时候很容易获得，就看你有没有勇气面对风险忍饥挨饿和他人的嘲笑。</p>\n<p>这个故事向我们揭示了一个简单而又深刻的经济原则，也就是：</p>\n<p><strong>通过延迟消费+冒险可以提高人们的生活水平</strong>。艾伯选择暂时不吃鱼，是为了将来可以捕到更多的鱼。而通过冒险，艾伯最终获得了新的资本，也就是渔网，而渔网会为他带来更多的鱼。</p>\n<p><strong>努力使得有限的资源（每一种资源都是有限的）产生最大的效益以尽可能地满足人的需求，这就是我们一直提到的——经济一词，最简单的定义。</strong></p>\n<p>而工具、资本与创新是实现这一目标的关键因素。</p>\n<h1 id=\"借贷和储蓄\"><a href=\"#借贷和储蓄\" class=\"headerlink\" title=\"借贷和储蓄\"></a>借贷和储蓄</h1><p>艾伯的前途看起来一片光明。但是，另外两个人的情况如何呢？我们是不是创造了一个贫富分化的等级体系？当然不是如此。</p>\n<p>这时贝克和查理看到艾伯拥有了更多鱼，第一时间想到的是把渔网借过来，可是艾伯并不太相信这两个人，而是建议他们自己也编织一张渔网。可他们俩却担心自己不能编出，而且担心编不出的挨饿。他们俩就想先借艾伯的鱼吃，等织好渔网再还给艾伯。可其中的风险让他们不得不得做数字研究。于是金融思维在这诞生了！贝克向艾伯许诺借一条鱼还两条，这么高的回报率让艾伯心动了，可风险很大。他经过深思熟虑后，决定把渔网借出去。</p>\n<p>书中告诉我们：这种借鱼的方式就像商业贷款，而商业贷款是资本的最佳用途，因为这样可以扩大生产。当然，通过借钱或借鱼的做法创业，无法保证企业一定会成功，因为借款人可能无法完全实现自己最初的计划。也就是说，查理和贝克如果不能成功地编织出自己的渔网，艾伯借出的鱼就打了水漂。而这种贷款方式在政府和企业上经常体现，为了让借款能够收回，于是有了信用和信用卡。</p>\n<p>接下来就是消费贷款的产生，假设艾伯不是把鱼借给贝克和查理，让他们去织自己的网，而是满足两人的借款需求，他们因此可以去度假，情况就会有所不同。</p>\n<p>这时艾伯就应该拒绝贷款给他们，因为这样的风险太大，当度假回来贝克和查理无法偿还这些贷款。所以这笔贷款无论是对贷款人还是借款人都是一种负担。如果艾伯承受住他们的冷嘲热讽拒绝贷款就规避了风来的风险。</p>\n<p>而应急贷款也是这样产生的，事实证明艾伯拒绝贷款给贝克和查理是明智的。一周之后，这两人都生了一种奇怪的谁都，双双病倒，一个星期都不能去捕鱼，而此时艾伯就把自己储蓄的鱼拿出来借给他们吃，尽管这次“贷款”可能血本无归，不过如果艾伯不提供这份应急贷款，两人可能丧命，而这座岛就失去生产能力了。</p>\n<p>如果之前艾伯把自己的储蓄作为没有收益的消费贷款借出的话，这次就无法拿出这份应急贷款了。</p>\n<p>事实上，在社会生死攸关之时，储蓄显得至关重要。现在社会，人们都认为信贷市场的有效运作所需要的就是有意愿的借款人，然而，与其他资源一样，在发放贷款前必须先积累储蓄才行。</p>\n<h1 id=\"储蓄的价值-amp-消费和生产\"><a href=\"#储蓄的价值-amp-消费和生产\" class=\"headerlink\" title=\"储蓄的价值&amp;消费和生产\"></a>储蓄的价值&amp;消费和生产</h1><p>小岛上的故事还在继续，几周后，艾伯、贝克和查理凭借新织的网迅速捕到大量的鱼，从而导致岛上的储蓄迅速膨胀。他们三个从天天捕鱼中解脱出来，终于可以去参加些有创意、有意思的活动了。艾伯可以话些时间设计和制造更实用也更漂亮的棕榈叶服装；贝克采摘椰子，丰富了菜谱以提高了厨艺；查理则盖起了小岛上的第一座小茅屋。</p>\n<p>贝尔这时有了个宏伟的计划——建造一个巨型捕鱼器，可靠他一个人不能够完成，于是他提议创立一家合伙公司，三人位合伙人，拿出一周时间建造这个巨型捕鱼器。</p>\n<p>三个人朝着目标前进，由于生产力的提升，岛上的储蓄迅速增加，捕鱼器很快建造出来。现在他们又可以实施其他计划了。查理制作了一块冲浪板，开创了一项很酷的新式休闲活动；艾伯创立了一家服装，他还开始筹划自己的一个人的舞台剧，贝克则利用自己的空闲时间考虑小岛上恼人的交通问题，开始设计岛上的第一条独木舟和第一辆手推车。</p>\n<p>故事到这里，这说明了一些经济学知识，储蓄不只是提高个人消费能力的手段，还是防止经济受到意外因素影响的重要缓冲器。一笔备用的储蓄会防止经济崩溃，可以迅速重建受损的资产。</p>\n<p>书中说道：而美国经济也是如此，过去，美国以储蓄大国而著称，这种丰富的储蓄资本为不断推进的工业活动提供了金融支持，同时也帮助美国的家庭和社区克服意外的困难。可近些年来美国人总是入不敷出。在自给自足的经济中，入小岛经济，这样做根本不可能。但在现实生活中很常见。O8年的金融危机爆发后，政府和经济学家放射性的寻找各种方法，让消费者花得更多、存的更少。而这样的做法却适得其反。作者告诉我们，消费只是我们用来衡量生产的尺度，因为所有生产出来的东西最终都是用于消费的。而生产呢？如果没有生产，也就没有东西可消费的。因此，生产时有价值的。</p>\n<p>还有就是，储蓄创造了资本，而资本使生产扩大成为可能，所以储蓄起来的一美元对经济产生的积极影响要大于消费掉的一美元。</p>\n<p>他这些观点我不好评判对错，不过确实有道理，而且再一次刷新了我的对于消费和生产的认知观，还可以逐渐形成自己的经济学思维，我觉得这是本书带给我们最大的价值。</p>\n<p>link:<br><a href=\"https://baijiahao.baidu.com/s?id=1593100704367037405\" target=\"_blank\" rel=\"noopener\">https://baijiahao.baidu.com/s?id=1593100704367037405</a></p>\n","site":{"data":{}},"excerpt":"<p>读小岛经济学，简单了解经济学概念<br></p>","more":"<p></p>\n<p>这本书的作者是美国经济学家彼得.D.希夫和安德鲁.J.希夫。本书的价值有人形象地用一个等式比喻为：《小岛经济学》=《经济学原理》+《经济学概论》+《国富论》。它让沉闷枯燥的经济学变得如此通俗易懂，经济学本身并不复杂，是经济学家们的解释太复杂了。</p>\n<h1 id=\"产出-消费\"><a href=\"#产出-消费\" class=\"headerlink\" title=\"产出=消费\"></a>产出=消费</h1><p>故事发生在一个小岛上，这个小岛上有三个人——艾伯、贝克和查理，这座小岛地处热带，却不是天堂。这里的人们生活艰苦，没有任何奢侈品，而且食物种类极少，他们的菜单上只有一道菜：鱼。然而由于他们的生产力的低下，没有任何工具捕鱼，靠着双手捕鱼每天只能捕捞一条鱼，正好满足自己的需求。</p>\n<p>小岛上的他们没有存款、借贷、投资也就是 产出=消费 的生产模式。</p>\n<h1 id=\"资本\"><a href=\"#资本\" class=\"headerlink\" title=\"资本\"></a>资本</h1><p>艾伯突发奇想，他想到了做一个捕鱼器提高捕鱼效率来提高自己生活水平。<br>但是问题是，制作渔网需要一天的时间，意味着那一天艾伯将没有食物，而且制作渔网未必能够成功。艾伯决定冒险试一试。忍受着旁人不理解的目光在那天傍晚的夕阳下终于织完了渔网。通过自我牺牲，他创造了资本——渔网。从此，艾伯每天可以捕两条鱼，他的生产力从而翻了一倍。而他的消费水平还是每天一条鱼，这时他的时间就非常充裕，他可以用这些时间做很多其他的事情。</p>\n<p><img src=\"/2019/03/27/about/HowAnEconomyGrowsAndWhyItCrashes/./economy_1.png\" alt=\"pic\"></p>\n<p>书中告诉我们资本有时候很容易获得，就看你有没有勇气面对风险忍饥挨饿和他人的嘲笑。</p>\n<p>这个故事向我们揭示了一个简单而又深刻的经济原则，也就是：</p>\n<p><strong>通过延迟消费+冒险可以提高人们的生活水平</strong>。艾伯选择暂时不吃鱼，是为了将来可以捕到更多的鱼。而通过冒险，艾伯最终获得了新的资本，也就是渔网，而渔网会为他带来更多的鱼。</p>\n<p><strong>努力使得有限的资源（每一种资源都是有限的）产生最大的效益以尽可能地满足人的需求，这就是我们一直提到的——经济一词，最简单的定义。</strong></p>\n<p>而工具、资本与创新是实现这一目标的关键因素。</p>\n<h1 id=\"借贷和储蓄\"><a href=\"#借贷和储蓄\" class=\"headerlink\" title=\"借贷和储蓄\"></a>借贷和储蓄</h1><p>艾伯的前途看起来一片光明。但是，另外两个人的情况如何呢？我们是不是创造了一个贫富分化的等级体系？当然不是如此。</p>\n<p>这时贝克和查理看到艾伯拥有了更多鱼，第一时间想到的是把渔网借过来，可是艾伯并不太相信这两个人，而是建议他们自己也编织一张渔网。可他们俩却担心自己不能编出，而且担心编不出的挨饿。他们俩就想先借艾伯的鱼吃，等织好渔网再还给艾伯。可其中的风险让他们不得不得做数字研究。于是金融思维在这诞生了！贝克向艾伯许诺借一条鱼还两条，这么高的回报率让艾伯心动了，可风险很大。他经过深思熟虑后，决定把渔网借出去。</p>\n<p>书中告诉我们：这种借鱼的方式就像商业贷款，而商业贷款是资本的最佳用途，因为这样可以扩大生产。当然，通过借钱或借鱼的做法创业，无法保证企业一定会成功，因为借款人可能无法完全实现自己最初的计划。也就是说，查理和贝克如果不能成功地编织出自己的渔网，艾伯借出的鱼就打了水漂。而这种贷款方式在政府和企业上经常体现，为了让借款能够收回，于是有了信用和信用卡。</p>\n<p>接下来就是消费贷款的产生，假设艾伯不是把鱼借给贝克和查理，让他们去织自己的网，而是满足两人的借款需求，他们因此可以去度假，情况就会有所不同。</p>\n<p>这时艾伯就应该拒绝贷款给他们，因为这样的风险太大，当度假回来贝克和查理无法偿还这些贷款。所以这笔贷款无论是对贷款人还是借款人都是一种负担。如果艾伯承受住他们的冷嘲热讽拒绝贷款就规避了风来的风险。</p>\n<p>而应急贷款也是这样产生的，事实证明艾伯拒绝贷款给贝克和查理是明智的。一周之后，这两人都生了一种奇怪的谁都，双双病倒，一个星期都不能去捕鱼，而此时艾伯就把自己储蓄的鱼拿出来借给他们吃，尽管这次“贷款”可能血本无归，不过如果艾伯不提供这份应急贷款，两人可能丧命，而这座岛就失去生产能力了。</p>\n<p>如果之前艾伯把自己的储蓄作为没有收益的消费贷款借出的话，这次就无法拿出这份应急贷款了。</p>\n<p>事实上，在社会生死攸关之时，储蓄显得至关重要。现在社会，人们都认为信贷市场的有效运作所需要的就是有意愿的借款人，然而，与其他资源一样，在发放贷款前必须先积累储蓄才行。</p>\n<h1 id=\"储蓄的价值-amp-消费和生产\"><a href=\"#储蓄的价值-amp-消费和生产\" class=\"headerlink\" title=\"储蓄的价值&amp;消费和生产\"></a>储蓄的价值&amp;消费和生产</h1><p>小岛上的故事还在继续，几周后，艾伯、贝克和查理凭借新织的网迅速捕到大量的鱼，从而导致岛上的储蓄迅速膨胀。他们三个从天天捕鱼中解脱出来，终于可以去参加些有创意、有意思的活动了。艾伯可以话些时间设计和制造更实用也更漂亮的棕榈叶服装；贝克采摘椰子，丰富了菜谱以提高了厨艺；查理则盖起了小岛上的第一座小茅屋。</p>\n<p>贝尔这时有了个宏伟的计划——建造一个巨型捕鱼器，可靠他一个人不能够完成，于是他提议创立一家合伙公司，三人位合伙人，拿出一周时间建造这个巨型捕鱼器。</p>\n<p>三个人朝着目标前进，由于生产力的提升，岛上的储蓄迅速增加，捕鱼器很快建造出来。现在他们又可以实施其他计划了。查理制作了一块冲浪板，开创了一项很酷的新式休闲活动；艾伯创立了一家服装，他还开始筹划自己的一个人的舞台剧，贝克则利用自己的空闲时间考虑小岛上恼人的交通问题，开始设计岛上的第一条独木舟和第一辆手推车。</p>\n<p>故事到这里，这说明了一些经济学知识，储蓄不只是提高个人消费能力的手段，还是防止经济受到意外因素影响的重要缓冲器。一笔备用的储蓄会防止经济崩溃，可以迅速重建受损的资产。</p>\n<p>书中说道：而美国经济也是如此，过去，美国以储蓄大国而著称，这种丰富的储蓄资本为不断推进的工业活动提供了金融支持，同时也帮助美国的家庭和社区克服意外的困难。可近些年来美国人总是入不敷出。在自给自足的经济中，入小岛经济，这样做根本不可能。但在现实生活中很常见。O8年的金融危机爆发后，政府和经济学家放射性的寻找各种方法，让消费者花得更多、存的更少。而这样的做法却适得其反。作者告诉我们，消费只是我们用来衡量生产的尺度，因为所有生产出来的东西最终都是用于消费的。而生产呢？如果没有生产，也就没有东西可消费的。因此，生产时有价值的。</p>\n<p>还有就是，储蓄创造了资本，而资本使生产扩大成为可能，所以储蓄起来的一美元对经济产生的积极影响要大于消费掉的一美元。</p>\n<p>他这些观点我不好评判对错，不过确实有道理，而且再一次刷新了我的对于消费和生产的认知观，还可以逐渐形成自己的经济学思维，我觉得这是本书带给我们最大的价值。</p>\n<p>link:<br><a href=\"https://baijiahao.baidu.com/s?id=1593100704367037405\" target=\"_blank\" rel=\"noopener\">https://baijiahao.baidu.com/s?id=1593100704367037405</a></p>"},{"title":"君为何故泪纵横","date":"2019-04-01T12:59:00.000Z","_content":"“人类的悲欢并不相通。”\n<!-- more -->\n\n他看起来也太难过了。\n\n摔出的手机像是肩头的重物，可紧接着还是要捡回来，满腔的委屈的自己吞咽消化。\n\n内心沙城暴卷走了一座又一座城市，残垣断壁又被海啸冲刷，心碎成了沙子，就算捡起来都根本没法拼。溺水了以后又被鲨鱼吞掉，等了三夜都没有等到天明，无人生还。这种程度，说出来的却是，没什么啊，怎么了？\n\n他在“牢笼”和“规矩”里不断道歉，他肩膀上背负了多少的压力，内心压抑了多少辛酸。\n\n这就是现代都市文明。\n\n我原先就知道生活艰难，可没想到居然这么他妈的难。\n\n“我只是想哭一下”。\n\n他还是哭了出来，叫了出来，哭喊着说自己疯了，可是很多时候，很多人，崩溃都是悄无声息的。\n\n有多少人都在崩溃的他的身上看到了那个相似的，即将爆发崩溃的自己。\n\n曾在深夜里痛哭过的人啊。\n\n生活本身就很多无奈。\n\n生活的琐碎，已经快让我们没力气了。\n\n哭完之后，我们还能怎么办？\n\n社会不只是要磨平你的棱角，它还要吃了你的人。\n\n怀有希望的人啊，那一丝光亮会一直存在吗？\n\n“人类的悲欢并不相通。”可是崩溃的他却让无数“苟活于世”的年轻人同悲。\n\nFucking life！\n","source":"_posts/humanbeings/IsLifeAlwaysThisHard.md","raw":"---\ntitle: 君为何故泪纵横\ntags:\n  - 当我在扯淡\ndate: 2019-04-01 20:59:00\ncategories: 当我在扯淡\n---\n“人类的悲欢并不相通。”\n<!-- more -->\n\n他看起来也太难过了。\n\n摔出的手机像是肩头的重物，可紧接着还是要捡回来，满腔的委屈的自己吞咽消化。\n\n内心沙城暴卷走了一座又一座城市，残垣断壁又被海啸冲刷，心碎成了沙子，就算捡起来都根本没法拼。溺水了以后又被鲨鱼吞掉，等了三夜都没有等到天明，无人生还。这种程度，说出来的却是，没什么啊，怎么了？\n\n他在“牢笼”和“规矩”里不断道歉，他肩膀上背负了多少的压力，内心压抑了多少辛酸。\n\n这就是现代都市文明。\n\n我原先就知道生活艰难，可没想到居然这么他妈的难。\n\n“我只是想哭一下”。\n\n他还是哭了出来，叫了出来，哭喊着说自己疯了，可是很多时候，很多人，崩溃都是悄无声息的。\n\n有多少人都在崩溃的他的身上看到了那个相似的，即将爆发崩溃的自己。\n\n曾在深夜里痛哭过的人啊。\n\n生活本身就很多无奈。\n\n生活的琐碎，已经快让我们没力气了。\n\n哭完之后，我们还能怎么办？\n\n社会不只是要磨平你的棱角，它还要吃了你的人。\n\n怀有希望的人啊，那一丝光亮会一直存在吗？\n\n“人类的悲欢并不相通。”可是崩溃的他却让无数“苟活于世”的年轻人同悲。\n\nFucking life！\n","slug":"humanbeings/IsLifeAlwaysThisHard","published":1,"updated":"2019-04-03T05:35:19.911Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxw60004ax48rta5s0hi","content":"<p>“人类的悲欢并不相通。”<br><a id=\"more\"></a></p>\n<p>他看起来也太难过了。</p>\n<p>摔出的手机像是肩头的重物，可紧接着还是要捡回来，满腔的委屈的自己吞咽消化。</p>\n<p>内心沙城暴卷走了一座又一座城市，残垣断壁又被海啸冲刷，心碎成了沙子，就算捡起来都根本没法拼。溺水了以后又被鲨鱼吞掉，等了三夜都没有等到天明，无人生还。这种程度，说出来的却是，没什么啊，怎么了？</p>\n<p>他在“牢笼”和“规矩”里不断道歉，他肩膀上背负了多少的压力，内心压抑了多少辛酸。</p>\n<p>这就是现代都市文明。</p>\n<p>我原先就知道生活艰难，可没想到居然这么他妈的难。</p>\n<p>“我只是想哭一下”。</p>\n<p>他还是哭了出来，叫了出来，哭喊着说自己疯了，可是很多时候，很多人，崩溃都是悄无声息的。</p>\n<p>有多少人都在崩溃的他的身上看到了那个相似的，即将爆发崩溃的自己。</p>\n<p>曾在深夜里痛哭过的人啊。</p>\n<p>生活本身就很多无奈。</p>\n<p>生活的琐碎，已经快让我们没力气了。</p>\n<p>哭完之后，我们还能怎么办？</p>\n<p>社会不只是要磨平你的棱角，它还要吃了你的人。</p>\n<p>怀有希望的人啊，那一丝光亮会一直存在吗？</p>\n<p>“人类的悲欢并不相通。”可是崩溃的他却让无数“苟活于世”的年轻人同悲。</p>\n<p>Fucking life！</p>\n","site":{"data":{}},"excerpt":"<p>“人类的悲欢并不相通。”<br></p>","more":"<p></p>\n<p>他看起来也太难过了。</p>\n<p>摔出的手机像是肩头的重物，可紧接着还是要捡回来，满腔的委屈的自己吞咽消化。</p>\n<p>内心沙城暴卷走了一座又一座城市，残垣断壁又被海啸冲刷，心碎成了沙子，就算捡起来都根本没法拼。溺水了以后又被鲨鱼吞掉，等了三夜都没有等到天明，无人生还。这种程度，说出来的却是，没什么啊，怎么了？</p>\n<p>他在“牢笼”和“规矩”里不断道歉，他肩膀上背负了多少的压力，内心压抑了多少辛酸。</p>\n<p>这就是现代都市文明。</p>\n<p>我原先就知道生活艰难，可没想到居然这么他妈的难。</p>\n<p>“我只是想哭一下”。</p>\n<p>他还是哭了出来，叫了出来，哭喊着说自己疯了，可是很多时候，很多人，崩溃都是悄无声息的。</p>\n<p>有多少人都在崩溃的他的身上看到了那个相似的，即将爆发崩溃的自己。</p>\n<p>曾在深夜里痛哭过的人啊。</p>\n<p>生活本身就很多无奈。</p>\n<p>生活的琐碎，已经快让我们没力气了。</p>\n<p>哭完之后，我们还能怎么办？</p>\n<p>社会不只是要磨平你的棱角，它还要吃了你的人。</p>\n<p>怀有希望的人啊，那一丝光亮会一直存在吗？</p>\n<p>“人类的悲欢并不相通。”可是崩溃的他却让无数“苟活于世”的年轻人同悲。</p>\n<p>Fucking life！</p>"},{"title":"Alive","date":"2018-12-07T06:36:00.000Z","_content":"你选择了生活还是被生活选择\n<!-- more -->\n\n昨晚下班\n淅淅沥沥的雨\n走出泗泾站到金地三期4#楼下需要1110步\n\n我究竟是活了365天还是活了一天却重复了365次","source":"_posts/humanbeings/alive.md","raw":"---\ntitle: Alive\ntags:\n  - 当我在扯淡\ndate: 2018-12-07 14:36:00\ncategories: 当我在扯淡\n---\n你选择了生活还是被生活选择\n<!-- more -->\n\n昨晚下班\n淅淅沥沥的雨\n走出泗泾站到金地三期4#楼下需要1110步\n\n我究竟是活了365天还是活了一天却重复了365次","slug":"humanbeings/alive","published":1,"updated":"2019-03-16T10:48:23.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxw90007ax484ka53e7d","content":"<p>你选择了生活还是被生活选择<br><a id=\"more\"></a></p>\n<p>昨晚下班<br>淅淅沥沥的雨<br>走出泗泾站到金地三期4#楼下需要1110步</p>\n<p>我究竟是活了365天还是活了一天却重复了365次</p>\n","site":{"data":{}},"excerpt":"<p>你选择了生活还是被生活选择<br></p>","more":"<p></p>\n<p>昨晚下班<br>淅淅沥沥的雨<br>走出泗泾站到金地三期4#楼下需要1110步</p>\n<p>我究竟是活了365天还是活了一天却重复了365次</p>"},{"title":"关于互联网寒冬","date":"2019-02-28T11:14:00.000Z","_content":"\n当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽\n<!-- more -->\n\n“面了好多家没拿到一个offer”\n“唉，一直接不到面试邀请”\n“外面行情是真的差啊，大厂都在裁员”\n.\n.\n.\n# winter of internet\n\n互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说\n\n有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧\n\n没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比\n\n然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？\n\n京东执行末尾淘汰机制。如何执行？裁员35%\n\n年后回到上海，朋友告诉我沪江教育裁了整两层楼\n\n前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人\n\n我肯定是麻木了\n\n# added fuel to the fire\n\n裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？\n\n老板：“996是一个好计划，just do it”\n\n大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢\n\n要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’\n白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”\n\n还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？\n\n# I'm such a pain in the neck\n\n当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中\n\n从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立...但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：无知带来的是自信不是知识，一个名词：*达克效应*\n\n这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）\n\n以前认识的一个老大私聊我：有想法吗\n\n且行且看容我想一想\n\n我是人间惆怅客\n\n# last\n\n下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”\n\nend\n","source":"_posts/humanbeings/IsThisInternetWinter.md","raw":"---\ntitle: 关于互联网寒冬\ntags:\n  - 当我在扯淡\ndate: 2019-02-28 19:14:00\ncategories: 当我在扯淡\n---\n\n当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽\n<!-- more -->\n\n“面了好多家没拿到一个offer”\n“唉，一直接不到面试邀请”\n“外面行情是真的差啊，大厂都在裁员”\n.\n.\n.\n# winter of internet\n\n互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说\n\n有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧\n\n没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比\n\n然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？\n\n京东执行末尾淘汰机制。如何执行？裁员35%\n\n年后回到上海，朋友告诉我沪江教育裁了整两层楼\n\n前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人\n\n我肯定是麻木了\n\n# added fuel to the fire\n\n裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？\n\n老板：“996是一个好计划，just do it”\n\n大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢\n\n要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’\n白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”\n\n还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？\n\n# I'm such a pain in the neck\n\n当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中\n\n从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立...但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：无知带来的是自信不是知识，一个名词：*达克效应*\n\n这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）\n\n以前认识的一个老大私聊我：有想法吗\n\n且行且看容我想一想\n\n我是人间惆怅客\n\n# last\n\n下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”\n\nend\n","slug":"humanbeings/IsThisInternetWinter","published":1,"updated":"2019-03-12T09:04:39.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwb0008ax48sqphnnww","content":"<p>当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽<br><a id=\"more\"></a></p>\n<p>“面了好多家没拿到一个offer”<br>“唉，一直接不到面试邀请”<br>“外面行情是真的差啊，大厂都在裁员”<br>.<br>.<br>.</p>\n<h1 id=\"winter-of-internet\"><a href=\"#winter-of-internet\" class=\"headerlink\" title=\"winter of internet\"></a>winter of internet</h1><p>互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说</p>\n<p>有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧</p>\n<p>没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比</p>\n<p>然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？</p>\n<p>京东执行末尾淘汰机制。如何执行？裁员35%</p>\n<p>年后回到上海，朋友告诉我沪江教育裁了整两层楼</p>\n<p>前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人</p>\n<p>我肯定是麻木了</p>\n<h1 id=\"added-fuel-to-the-fire\"><a href=\"#added-fuel-to-the-fire\" class=\"headerlink\" title=\"added fuel to the fire\"></a>added fuel to the fire</h1><p>裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？</p>\n<p>老板：“996是一个好计划，just do it”</p>\n<p>大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢</p>\n<p>要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’<br>白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”</p>\n<p>还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？</p>\n<h1 id=\"I’m-such-a-pain-in-the-neck\"><a href=\"#I’m-such-a-pain-in-the-neck\" class=\"headerlink\" title=\"I’m such a pain in the neck\"></a>I’m such a pain in the neck</h1><p>当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中</p>\n<p>从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立…但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：无知带来的是自信不是知识，一个名词：<em>达克效应</em></p>\n<p>这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）</p>\n<p>以前认识的一个老大私聊我：有想法吗</p>\n<p>且行且看容我想一想</p>\n<p>我是人间惆怅客</p>\n<h1 id=\"last\"><a href=\"#last\" class=\"headerlink\" title=\"last\"></a>last</h1><p>下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”</p>\n<p>end</p>\n","site":{"data":{}},"excerpt":"<p>当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽<br></p>","more":"<p></p>\n<p>“面了好多家没拿到一个offer”<br>“唉，一直接不到面试邀请”<br>“外面行情是真的差啊，大厂都在裁员”<br>.<br>.<br>.</p>\n<h1 id=\"winter-of-internet\"><a href=\"#winter-of-internet\" class=\"headerlink\" title=\"winter of internet\"></a>winter of internet</h1><p>互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说</p>\n<p>有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧</p>\n<p>没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比</p>\n<p>然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？</p>\n<p>京东执行末尾淘汰机制。如何执行？裁员35%</p>\n<p>年后回到上海，朋友告诉我沪江教育裁了整两层楼</p>\n<p>前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人</p>\n<p>我肯定是麻木了</p>\n<h1 id=\"added-fuel-to-the-fire\"><a href=\"#added-fuel-to-the-fire\" class=\"headerlink\" title=\"added fuel to the fire\"></a>added fuel to the fire</h1><p>裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？</p>\n<p>老板：“996是一个好计划，just do it”</p>\n<p>大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢</p>\n<p>要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’<br>白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”</p>\n<p>还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？</p>\n<h1 id=\"I’m-such-a-pain-in-the-neck\"><a href=\"#I’m-such-a-pain-in-the-neck\" class=\"headerlink\" title=\"I’m such a pain in the neck\"></a>I’m such a pain in the neck</h1><p>当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中</p>\n<p>从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立…但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：无知带来的是自信不是知识，一个名词：<em>达克效应</em></p>\n<p>这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）</p>\n<p>以前认识的一个老大私聊我：有想法吗</p>\n<p>且行且看容我想一想</p>\n<p>我是人间惆怅客</p>\n<h1 id=\"last\"><a href=\"#last\" class=\"headerlink\" title=\"last\"></a>last</h1><p>下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”</p>\n<p>end</p>"},{"title":"生活不易 当砥砺前行","date":"2019-07-16T14:04:00.000Z","_content":"`生活不易 当砥砺前行`\n<!-- more -->\n\n下午和政委（美丽而又有思想高度的女子）在Costa闲聊了很多， 貌似让Tracy当做了我的倾诉对象（/抚脸）\n\n迷茫充斥整个大脑，“我好想逃，却逃不掉”\n\n# What kind of road are you on\n\n很多人不知道当下的自己最应该做什么（比如现阶段的自己），我有想过很多方法，然而仿佛即将在迷失的道路上彻底失去方向\n\n问过北森的一个朋友，我和她说了我当前所处的困境，我之前两年的经历，被告知需要“沉淀”，以至差点陷入一个误区：如Tracy说的‘沉淀并不是时间的积累’\n\n以前有过“阅历是时间的积累，是经历的总结”的想法，后来仔细想想过于简单和片面。悟性非常的人就是能抓住属于(甚至不属于)他们的机运，从被常人忽略的经历中总结出经验和教训。天才到处都有，勿要自以为是\n\n# Who am I? Where am I from? What am I going to do? Where am I going?\n\n人不自知，必生疑惑如同人无远虑必有近忧，真正从内心认知自己，审视自己的优缺点，然后找到自己当前最该做的事情（尚且不知）然后完成它\n\n缺点如同虚荣、懒惰、贪婪一般当做人类劣根性，勿要被其所支配那么在大的方向上即使避免不了也无伤大雅\n\n\n\n# 思想层次“思想维度以及高度”\n很多人都缺少一定的思想高度以及维度，目光和思考偏居一偶且片面，没有在一定的高度以及更多的角度思考问题。如同我现在所思所想可能仅仅在稍微高一些的层次上只是鼠目寸光。但是思想维度和高度真的是人际深层次交往之间的纽带和桥梁：一个无法get到你所要展现内容的要义甚至潜在意思的人是不可能从心底取得你的认可的\n\n深层次的对话在于思想层次的对等否则仅是高维对低维的俯视，内心笑看低维的“表演”\n\n有句话大概是：如果你觉得自己和某一个人相处很舒服，很可能并不是你们合得来，而是因为对方的情商远高于你\n\nTracy是我所见不多有思想有灵魂的理性女子（再次鼓吹，接受Tracy的降维打击）\n\n# Evolution\n有思想有灵魂的人是必不会缺乏“个性”的，不需张扬但必心有锦绣\n很多人\"泯然众人\"于染缸之中，维持“个性”何其可贵，否则哪里会有思想层次的跃迁\n\n和有思想、有灵魂的人做朋友简直是太棒了\n\n# Back to the subject\n扯远了，回到上面关于如何度过迷茫期再次提升自己的问题，Tracy和小寺桃都和我提过尝试摆脱固有惯性（思维、方法、态度等）\n深以为然却无以为继\n\n主动寻求改变最令人细思极恐的莫过于你以为的“改变”不过是“不变”的延伸，如何确定自己走在正确的路上现阶段大概只能用感觉来回答了\n\n# 方法论\n作为“方法论”布道者，万物皆有规律可寻，保持能力的不断蜕变，底蕴的积累，人生何处无捷径\n\n作为阶段性的“成长”的衍生物，迷茫期不会只在当下出现，但寻找度过迷茫期的方法一定是相通的\n\n# Keep thinking & keep questioning\n保持思考，保持质疑是一直秉持的“真理”\n突然想到今天Tracy说的：迷茫期当停止思考，切换关注点可能会有新的切入点（大概原话如此？我记性很好，只是会忘 /抚脸）\n“停止思考”？！ 惊呆！\n作为一名胡思乱想爱好者，我的左脑完全不受到我的控制\n\n博学之，审问之，慎思之，明辨之，笃行之\n\n# Last\n花了一两个小时写出这么一丢丢形而上学的东西，但是貌似好像似乎发现新的切入点了\n\nGood night.\n","source":"_posts/humanbeings/lost.md","raw":"---\ntitle: 生活不易 当砥砺前行\ntags:\n  - 当我在扯淡\ndate: 2019-07-16 22:04:00\ncategories: 当我在扯淡\n---\n`生活不易 当砥砺前行`\n<!-- more -->\n\n下午和政委（美丽而又有思想高度的女子）在Costa闲聊了很多， 貌似让Tracy当做了我的倾诉对象（/抚脸）\n\n迷茫充斥整个大脑，“我好想逃，却逃不掉”\n\n# What kind of road are you on\n\n很多人不知道当下的自己最应该做什么（比如现阶段的自己），我有想过很多方法，然而仿佛即将在迷失的道路上彻底失去方向\n\n问过北森的一个朋友，我和她说了我当前所处的困境，我之前两年的经历，被告知需要“沉淀”，以至差点陷入一个误区：如Tracy说的‘沉淀并不是时间的积累’\n\n以前有过“阅历是时间的积累，是经历的总结”的想法，后来仔细想想过于简单和片面。悟性非常的人就是能抓住属于(甚至不属于)他们的机运，从被常人忽略的经历中总结出经验和教训。天才到处都有，勿要自以为是\n\n# Who am I? Where am I from? What am I going to do? Where am I going?\n\n人不自知，必生疑惑如同人无远虑必有近忧，真正从内心认知自己，审视自己的优缺点，然后找到自己当前最该做的事情（尚且不知）然后完成它\n\n缺点如同虚荣、懒惰、贪婪一般当做人类劣根性，勿要被其所支配那么在大的方向上即使避免不了也无伤大雅\n\n\n\n# 思想层次“思想维度以及高度”\n很多人都缺少一定的思想高度以及维度，目光和思考偏居一偶且片面，没有在一定的高度以及更多的角度思考问题。如同我现在所思所想可能仅仅在稍微高一些的层次上只是鼠目寸光。但是思想维度和高度真的是人际深层次交往之间的纽带和桥梁：一个无法get到你所要展现内容的要义甚至潜在意思的人是不可能从心底取得你的认可的\n\n深层次的对话在于思想层次的对等否则仅是高维对低维的俯视，内心笑看低维的“表演”\n\n有句话大概是：如果你觉得自己和某一个人相处很舒服，很可能并不是你们合得来，而是因为对方的情商远高于你\n\nTracy是我所见不多有思想有灵魂的理性女子（再次鼓吹，接受Tracy的降维打击）\n\n# Evolution\n有思想有灵魂的人是必不会缺乏“个性”的，不需张扬但必心有锦绣\n很多人\"泯然众人\"于染缸之中，维持“个性”何其可贵，否则哪里会有思想层次的跃迁\n\n和有思想、有灵魂的人做朋友简直是太棒了\n\n# Back to the subject\n扯远了，回到上面关于如何度过迷茫期再次提升自己的问题，Tracy和小寺桃都和我提过尝试摆脱固有惯性（思维、方法、态度等）\n深以为然却无以为继\n\n主动寻求改变最令人细思极恐的莫过于你以为的“改变”不过是“不变”的延伸，如何确定自己走在正确的路上现阶段大概只能用感觉来回答了\n\n# 方法论\n作为“方法论”布道者，万物皆有规律可寻，保持能力的不断蜕变，底蕴的积累，人生何处无捷径\n\n作为阶段性的“成长”的衍生物，迷茫期不会只在当下出现，但寻找度过迷茫期的方法一定是相通的\n\n# Keep thinking & keep questioning\n保持思考，保持质疑是一直秉持的“真理”\n突然想到今天Tracy说的：迷茫期当停止思考，切换关注点可能会有新的切入点（大概原话如此？我记性很好，只是会忘 /抚脸）\n“停止思考”？！ 惊呆！\n作为一名胡思乱想爱好者，我的左脑完全不受到我的控制\n\n博学之，审问之，慎思之，明辨之，笃行之\n\n# Last\n花了一两个小时写出这么一丢丢形而上学的东西，但是貌似好像似乎发现新的切入点了\n\nGood night.\n","slug":"humanbeings/lost","published":1,"updated":"2019-09-03T07:17:52.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwc0009ax48wrv0rdtf","content":"<p><code>生活不易 当砥砺前行</code><br><a id=\"more\"></a></p>\n<p>下午和政委（美丽而又有思想高度的女子）在Costa闲聊了很多， 貌似让Tracy当做了我的倾诉对象（/抚脸）</p>\n<p>迷茫充斥整个大脑，“我好想逃，却逃不掉”</p>\n<h1 id=\"What-kind-of-road-are-you-on\"><a href=\"#What-kind-of-road-are-you-on\" class=\"headerlink\" title=\"What kind of road are you on\"></a>What kind of road are you on</h1><p>很多人不知道当下的自己最应该做什么（比如现阶段的自己），我有想过很多方法，然而仿佛即将在迷失的道路上彻底失去方向</p>\n<p>问过北森的一个朋友，我和她说了我当前所处的困境，我之前两年的经历，被告知需要“沉淀”，以至差点陷入一个误区：如Tracy说的‘沉淀并不是时间的积累’</p>\n<p>以前有过“阅历是时间的积累，是经历的总结”的想法，后来仔细想想过于简单和片面。悟性非常的人就是能抓住属于(甚至不属于)他们的机运，从被常人忽略的经历中总结出经验和教训。天才到处都有，勿要自以为是</p>\n<h1 id=\"Who-am-I-Where-am-I-from-What-am-I-going-to-do-Where-am-I-going\"><a href=\"#Who-am-I-Where-am-I-from-What-am-I-going-to-do-Where-am-I-going\" class=\"headerlink\" title=\"Who am I? Where am I from? What am I going to do? Where am I going?\"></a>Who am I? Where am I from? What am I going to do? Where am I going?</h1><p>人不自知，必生疑惑如同人无远虑必有近忧，真正从内心认知自己，审视自己的优缺点，然后找到自己当前最该做的事情（尚且不知）然后完成它</p>\n<p>缺点如同虚荣、懒惰、贪婪一般当做人类劣根性，勿要被其所支配那么在大的方向上即使避免不了也无伤大雅</p>\n<h1 id=\"思想层次“思想维度以及高度”\"><a href=\"#思想层次“思想维度以及高度”\" class=\"headerlink\" title=\"思想层次“思想维度以及高度”\"></a>思想层次“思想维度以及高度”</h1><p>很多人都缺少一定的思想高度以及维度，目光和思考偏居一偶且片面，没有在一定的高度以及更多的角度思考问题。如同我现在所思所想可能仅仅在稍微高一些的层次上只是鼠目寸光。但是思想维度和高度真的是人际深层次交往之间的纽带和桥梁：一个无法get到你所要展现内容的要义甚至潜在意思的人是不可能从心底取得你的认可的</p>\n<p>深层次的对话在于思想层次的对等否则仅是高维对低维的俯视，内心笑看低维的“表演”</p>\n<p>有句话大概是：如果你觉得自己和某一个人相处很舒服，很可能并不是你们合得来，而是因为对方的情商远高于你</p>\n<p>Tracy是我所见不多有思想有灵魂的理性女子（再次鼓吹，接受Tracy的降维打击）</p>\n<h1 id=\"Evolution\"><a href=\"#Evolution\" class=\"headerlink\" title=\"Evolution\"></a>Evolution</h1><p>有思想有灵魂的人是必不会缺乏“个性”的，不需张扬但必心有锦绣<br>很多人”泯然众人”于染缸之中，维持“个性”何其可贵，否则哪里会有思想层次的跃迁</p>\n<p>和有思想、有灵魂的人做朋友简直是太棒了</p>\n<h1 id=\"Back-to-the-subject\"><a href=\"#Back-to-the-subject\" class=\"headerlink\" title=\"Back to the subject\"></a>Back to the subject</h1><p>扯远了，回到上面关于如何度过迷茫期再次提升自己的问题，Tracy和小寺桃都和我提过尝试摆脱固有惯性（思维、方法、态度等）<br>深以为然却无以为继</p>\n<p>主动寻求改变最令人细思极恐的莫过于你以为的“改变”不过是“不变”的延伸，如何确定自己走在正确的路上现阶段大概只能用感觉来回答了</p>\n<h1 id=\"方法论\"><a href=\"#方法论\" class=\"headerlink\" title=\"方法论\"></a>方法论</h1><p>作为“方法论”布道者，万物皆有规律可寻，保持能力的不断蜕变，底蕴的积累，人生何处无捷径</p>\n<p>作为阶段性的“成长”的衍生物，迷茫期不会只在当下出现，但寻找度过迷茫期的方法一定是相通的</p>\n<h1 id=\"Keep-thinking-amp-keep-questioning\"><a href=\"#Keep-thinking-amp-keep-questioning\" class=\"headerlink\" title=\"Keep thinking &amp; keep questioning\"></a>Keep thinking &amp; keep questioning</h1><p>保持思考，保持质疑是一直秉持的“真理”<br>突然想到今天Tracy说的：迷茫期当停止思考，切换关注点可能会有新的切入点（大概原话如此？我记性很好，只是会忘 /抚脸）<br>“停止思考”？！ 惊呆！<br>作为一名胡思乱想爱好者，我的左脑完全不受到我的控制</p>\n<p>博学之，审问之，慎思之，明辨之，笃行之</p>\n<h1 id=\"Last\"><a href=\"#Last\" class=\"headerlink\" title=\"Last\"></a>Last</h1><p>花了一两个小时写出这么一丢丢形而上学的东西，但是貌似好像似乎发现新的切入点了</p>\n<p>Good night.</p>\n","site":{"data":{}},"excerpt":"<p><code>生活不易 当砥砺前行</code><br></p>","more":"<p></p>\n<p>下午和政委（美丽而又有思想高度的女子）在Costa闲聊了很多， 貌似让Tracy当做了我的倾诉对象（/抚脸）</p>\n<p>迷茫充斥整个大脑，“我好想逃，却逃不掉”</p>\n<h1 id=\"What-kind-of-road-are-you-on\"><a href=\"#What-kind-of-road-are-you-on\" class=\"headerlink\" title=\"What kind of road are you on\"></a>What kind of road are you on</h1><p>很多人不知道当下的自己最应该做什么（比如现阶段的自己），我有想过很多方法，然而仿佛即将在迷失的道路上彻底失去方向</p>\n<p>问过北森的一个朋友，我和她说了我当前所处的困境，我之前两年的经历，被告知需要“沉淀”，以至差点陷入一个误区：如Tracy说的‘沉淀并不是时间的积累’</p>\n<p>以前有过“阅历是时间的积累，是经历的总结”的想法，后来仔细想想过于简单和片面。悟性非常的人就是能抓住属于(甚至不属于)他们的机运，从被常人忽略的经历中总结出经验和教训。天才到处都有，勿要自以为是</p>\n<h1 id=\"Who-am-I-Where-am-I-from-What-am-I-going-to-do-Where-am-I-going\"><a href=\"#Who-am-I-Where-am-I-from-What-am-I-going-to-do-Where-am-I-going\" class=\"headerlink\" title=\"Who am I? Where am I from? What am I going to do? Where am I going?\"></a>Who am I? Where am I from? What am I going to do? Where am I going?</h1><p>人不自知，必生疑惑如同人无远虑必有近忧，真正从内心认知自己，审视自己的优缺点，然后找到自己当前最该做的事情（尚且不知）然后完成它</p>\n<p>缺点如同虚荣、懒惰、贪婪一般当做人类劣根性，勿要被其所支配那么在大的方向上即使避免不了也无伤大雅</p>\n<h1 id=\"思想层次“思想维度以及高度”\"><a href=\"#思想层次“思想维度以及高度”\" class=\"headerlink\" title=\"思想层次“思想维度以及高度”\"></a>思想层次“思想维度以及高度”</h1><p>很多人都缺少一定的思想高度以及维度，目光和思考偏居一偶且片面，没有在一定的高度以及更多的角度思考问题。如同我现在所思所想可能仅仅在稍微高一些的层次上只是鼠目寸光。但是思想维度和高度真的是人际深层次交往之间的纽带和桥梁：一个无法get到你所要展现内容的要义甚至潜在意思的人是不可能从心底取得你的认可的</p>\n<p>深层次的对话在于思想层次的对等否则仅是高维对低维的俯视，内心笑看低维的“表演”</p>\n<p>有句话大概是：如果你觉得自己和某一个人相处很舒服，很可能并不是你们合得来，而是因为对方的情商远高于你</p>\n<p>Tracy是我所见不多有思想有灵魂的理性女子（再次鼓吹，接受Tracy的降维打击）</p>\n<h1 id=\"Evolution\"><a href=\"#Evolution\" class=\"headerlink\" title=\"Evolution\"></a>Evolution</h1><p>有思想有灵魂的人是必不会缺乏“个性”的，不需张扬但必心有锦绣<br>很多人”泯然众人”于染缸之中，维持“个性”何其可贵，否则哪里会有思想层次的跃迁</p>\n<p>和有思想、有灵魂的人做朋友简直是太棒了</p>\n<h1 id=\"Back-to-the-subject\"><a href=\"#Back-to-the-subject\" class=\"headerlink\" title=\"Back to the subject\"></a>Back to the subject</h1><p>扯远了，回到上面关于如何度过迷茫期再次提升自己的问题，Tracy和小寺桃都和我提过尝试摆脱固有惯性（思维、方法、态度等）<br>深以为然却无以为继</p>\n<p>主动寻求改变最令人细思极恐的莫过于你以为的“改变”不过是“不变”的延伸，如何确定自己走在正确的路上现阶段大概只能用感觉来回答了</p>\n<h1 id=\"方法论\"><a href=\"#方法论\" class=\"headerlink\" title=\"方法论\"></a>方法论</h1><p>作为“方法论”布道者，万物皆有规律可寻，保持能力的不断蜕变，底蕴的积累，人生何处无捷径</p>\n<p>作为阶段性的“成长”的衍生物，迷茫期不会只在当下出现，但寻找度过迷茫期的方法一定是相通的</p>\n<h1 id=\"Keep-thinking-amp-keep-questioning\"><a href=\"#Keep-thinking-amp-keep-questioning\" class=\"headerlink\" title=\"Keep thinking &amp; keep questioning\"></a>Keep thinking &amp; keep questioning</h1><p>保持思考，保持质疑是一直秉持的“真理”<br>突然想到今天Tracy说的：迷茫期当停止思考，切换关注点可能会有新的切入点（大概原话如此？我记性很好，只是会忘 /抚脸）<br>“停止思考”？！ 惊呆！<br>作为一名胡思乱想爱好者，我的左脑完全不受到我的控制</p>\n<p>博学之，审问之，慎思之，明辨之，笃行之</p>\n<h1 id=\"Last\"><a href=\"#Last\" class=\"headerlink\" title=\"Last\"></a>Last</h1><p>花了一两个小时写出这么一丢丢形而上学的东西，但是貌似好像似乎发现新的切入点了</p>\n<p>Good night.</p>"},{"title":"生亦何欢 死亦何苦","date":"2019-05-06T07:02:00.000Z","_content":"“生亦何欢 死亦何苦”\n<!-- more -->\n\n我妈突然在微信上和我说：“你大姨走了，我正在去辽宁的高铁上”。\n\n印象中对于大姨的印象并不深刻，二十多年仅见过寥寥几面，只知道很多年前就从徐州搬家到锦州定居。\n\n我回复我妈：“走就走吧，走了可能也是一种解脱，和病魔斗争那么多年”。\n\n我大姨有糖尿病，很多年了，听说以前有几次发病时候非常危险，我妈曾经在大姨家生活过三年，我所认识的大姨大都在我妈的只言片语中所了解。\n\n印象中那个有着自然卷长头发的似乎是我妈眼中一直是一面墙的女人就这样走了。\n\n我妈会非常伤心吧。\n\n我大概是没心没肺，听闻大姨走了的消息，竟然没有太大的波澜，呵，真是冷血。\n\n人生如逆旅。\n\n如果没有病魔缠身，她大概会幸福生活一生吧。年轻的时候和丈夫打拼在外地立足累且幸福，儿女现已长大成人事业有成，然而命运总是这样，给你想要的，却拿走了你的身体。\n\n普通人的一生\n\n再好也是桃花扇\n\n撞破了头\n\n血溅到扇子上\n\n就在这上面略加一点染成一枝桃花。\n\n活着的人都不知道死去的世界是什么。\n\n苟活于世，生亦何欢？\n\n拥抱沉沦，死亦何苦？\n\n“以你的名义单独送一个花圈吧”\n\n“好”\n","source":"_posts/humanbeings/death.md","raw":"---\ntitle: 生亦何欢 死亦何苦\ntags:\n  - 当我在扯淡\ndate: 2019-05-06 15:02:00\ncategories: 当我在扯淡\n---\n“生亦何欢 死亦何苦”\n<!-- more -->\n\n我妈突然在微信上和我说：“你大姨走了，我正在去辽宁的高铁上”。\n\n印象中对于大姨的印象并不深刻，二十多年仅见过寥寥几面，只知道很多年前就从徐州搬家到锦州定居。\n\n我回复我妈：“走就走吧，走了可能也是一种解脱，和病魔斗争那么多年”。\n\n我大姨有糖尿病，很多年了，听说以前有几次发病时候非常危险，我妈曾经在大姨家生活过三年，我所认识的大姨大都在我妈的只言片语中所了解。\n\n印象中那个有着自然卷长头发的似乎是我妈眼中一直是一面墙的女人就这样走了。\n\n我妈会非常伤心吧。\n\n我大概是没心没肺，听闻大姨走了的消息，竟然没有太大的波澜，呵，真是冷血。\n\n人生如逆旅。\n\n如果没有病魔缠身，她大概会幸福生活一生吧。年轻的时候和丈夫打拼在外地立足累且幸福，儿女现已长大成人事业有成，然而命运总是这样，给你想要的，却拿走了你的身体。\n\n普通人的一生\n\n再好也是桃花扇\n\n撞破了头\n\n血溅到扇子上\n\n就在这上面略加一点染成一枝桃花。\n\n活着的人都不知道死去的世界是什么。\n\n苟活于世，生亦何欢？\n\n拥抱沉沦，死亦何苦？\n\n“以你的名义单独送一个花圈吧”\n\n“好”\n","slug":"humanbeings/death","published":1,"updated":"2019-05-06T07:22:45.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwe000dax48wzt0ifte","content":"<p>“生亦何欢 死亦何苦”<br><a id=\"more\"></a></p>\n<p>我妈突然在微信上和我说：“你大姨走了，我正在去辽宁的高铁上”。</p>\n<p>印象中对于大姨的印象并不深刻，二十多年仅见过寥寥几面，只知道很多年前就从徐州搬家到锦州定居。</p>\n<p>我回复我妈：“走就走吧，走了可能也是一种解脱，和病魔斗争那么多年”。</p>\n<p>我大姨有糖尿病，很多年了，听说以前有几次发病时候非常危险，我妈曾经在大姨家生活过三年，我所认识的大姨大都在我妈的只言片语中所了解。</p>\n<p>印象中那个有着自然卷长头发的似乎是我妈眼中一直是一面墙的女人就这样走了。</p>\n<p>我妈会非常伤心吧。</p>\n<p>我大概是没心没肺，听闻大姨走了的消息，竟然没有太大的波澜，呵，真是冷血。</p>\n<p>人生如逆旅。</p>\n<p>如果没有病魔缠身，她大概会幸福生活一生吧。年轻的时候和丈夫打拼在外地立足累且幸福，儿女现已长大成人事业有成，然而命运总是这样，给你想要的，却拿走了你的身体。</p>\n<p>普通人的一生</p>\n<p>再好也是桃花扇</p>\n<p>撞破了头</p>\n<p>血溅到扇子上</p>\n<p>就在这上面略加一点染成一枝桃花。</p>\n<p>活着的人都不知道死去的世界是什么。</p>\n<p>苟活于世，生亦何欢？</p>\n<p>拥抱沉沦，死亦何苦？</p>\n<p>“以你的名义单独送一个花圈吧”</p>\n<p>“好”</p>\n","site":{"data":{}},"excerpt":"<p>“生亦何欢 死亦何苦”<br></p>","more":"<p></p>\n<p>我妈突然在微信上和我说：“你大姨走了，我正在去辽宁的高铁上”。</p>\n<p>印象中对于大姨的印象并不深刻，二十多年仅见过寥寥几面，只知道很多年前就从徐州搬家到锦州定居。</p>\n<p>我回复我妈：“走就走吧，走了可能也是一种解脱，和病魔斗争那么多年”。</p>\n<p>我大姨有糖尿病，很多年了，听说以前有几次发病时候非常危险，我妈曾经在大姨家生活过三年，我所认识的大姨大都在我妈的只言片语中所了解。</p>\n<p>印象中那个有着自然卷长头发的似乎是我妈眼中一直是一面墙的女人就这样走了。</p>\n<p>我妈会非常伤心吧。</p>\n<p>我大概是没心没肺，听闻大姨走了的消息，竟然没有太大的波澜，呵，真是冷血。</p>\n<p>人生如逆旅。</p>\n<p>如果没有病魔缠身，她大概会幸福生活一生吧。年轻的时候和丈夫打拼在外地立足累且幸福，儿女现已长大成人事业有成，然而命运总是这样，给你想要的，却拿走了你的身体。</p>\n<p>普通人的一生</p>\n<p>再好也是桃花扇</p>\n<p>撞破了头</p>\n<p>血溅到扇子上</p>\n<p>就在这上面略加一点染成一枝桃花。</p>\n<p>活着的人都不知道死去的世界是什么。</p>\n<p>苟活于世，生亦何欢？</p>\n<p>拥抱沉沦，死亦何苦？</p>\n<p>“以你的名义单独送一个花圈吧”</p>\n<p>“好”</p>"},{"title":"人生天地间 忽如远行客","date":"2019-01-03T16:00:00.000Z","_content":"\n我是人间惆怅客\n知君何事泪纵横\n\n<!--more-->\n\n## 原来18年已经结束了\n\n已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧\n\n从途虎到鱼泡泡\n\n结识不少新朋友\n\n和 [曹少](https://github.com/kailcc) 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍\n\n感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住\n\n心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事\n\n\n依然单身，这城市太空\n\n依旧经常胡思乱想，上至宇宙下至微尘，人事物景情\n\n之后再补上吧\n\n最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛\n","source":"_posts/humanbeings/人生天地间 忽如远行客.md","raw":"---\ntitle: 人生天地间 忽如远行客\ntags:\n  - 当我在扯淡\ndate: 2019-01-04 00:00:00\ncategories: 当我在扯淡\n---\n\n我是人间惆怅客\n知君何事泪纵横\n\n<!--more-->\n\n## 原来18年已经结束了\n\n已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧\n\n从途虎到鱼泡泡\n\n结识不少新朋友\n\n和 [曹少](https://github.com/kailcc) 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍\n\n感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住\n\n心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事\n\n\n依然单身，这城市太空\n\n依旧经常胡思乱想，上至宇宙下至微尘，人事物景情\n\n之后再补上吧\n\n最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛\n","slug":"humanbeings/人生天地间 忽如远行客","published":1,"updated":"2019-02-24T02:52:53.596Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwg000eax48t8k4iwln","content":"<p>我是人间惆怅客<br>知君何事泪纵横</p>\n<a id=\"more\"></a>\n<h2 id=\"原来18年已经结束了\"><a href=\"#原来18年已经结束了\" class=\"headerlink\" title=\"原来18年已经结束了\"></a>原来18年已经结束了</h2><p>已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧</p>\n<p>从途虎到鱼泡泡</p>\n<p>结识不少新朋友</p>\n<p>和 <a href=\"https://github.com/kailcc\" target=\"_blank\" rel=\"noopener\">曹少</a> 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍</p>\n<p>感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住</p>\n<p>心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事</p>\n<p>依然单身，这城市太空</p>\n<p>依旧经常胡思乱想，上至宇宙下至微尘，人事物景情</p>\n<p>之后再补上吧</p>\n<p>最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛</p>\n","site":{"data":{}},"excerpt":"<p>我是人间惆怅客<br>知君何事泪纵横</p>","more":"<h2 id=\"原来18年已经结束了\"><a href=\"#原来18年已经结束了\" class=\"headerlink\" title=\"原来18年已经结束了\"></a>原来18年已经结束了</h2><p>已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧</p>\n<p>从途虎到鱼泡泡</p>\n<p>结识不少新朋友</p>\n<p>和 <a href=\"https://github.com/kailcc\" target=\"_blank\" rel=\"noopener\">曹少</a> 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍</p>\n<p>感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住</p>\n<p>心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事</p>\n<p>依然单身，这城市太空</p>\n<p>依旧经常胡思乱想，上至宇宙下至微尘，人事物景情</p>\n<p>之后再补上吧</p>\n<p>最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛</p>"},{"title":"批判性思维","date":"2019-06-01T09:14:00.000Z","_content":"批判性思维\n\n<!-- more -->\n\n1. 凡事明确概念，明确定义，不讨论定义模糊的事情。\n2. 演绎与归纳的严密性。分辨观点与事实，假设与结论。\n3. 尽量去除情绪对思考的影响，只是尽量，实际上很难。如恐慌，贪婪的情绪对人影响很大。\n4. 从更高纬度寻找通用性，普适性规律。思考问题的本质，且持续迭代思考。因为1-2次的思考可能是不够深刻的。\n5. 保持独立思考，保留尽量多的独处时间，内心平静。不附和他人，附和自己判断错误的观点是用羞耻换取资源。不执着自己，因为自己的思考可能是有瑕疵的。说话前要过脑子，宁愿说的慢一点。\n6. 怀疑大部分的一切。尤其是习以为常的观点，如群众的眼睛是雪亮的，和真理掌握在少数人手里，就会推演出既然群众那么雪亮为何看不到真理？\n7. 不和思维混乱的人辩论，保持沉默即可。\n8. 大量的阅读，否则思辨缺乏原材料。哲学类，自然科学类，社会学，历史，宗教。\n\n思维习惯的形成是一个强制定形到灵活掌握的过程，一开始需要很机械的按一个模板来思考问题。会耗费大量时间。\n","source":"_posts/humanbeings/thoughts.md","raw":"---\ntitle: 批判性思维\ntags:\n  - 思维\ndate: 2019-06-01 17:14:00\ncategories: 思维\n---\n批判性思维\n\n<!-- more -->\n\n1. 凡事明确概念，明确定义，不讨论定义模糊的事情。\n2. 演绎与归纳的严密性。分辨观点与事实，假设与结论。\n3. 尽量去除情绪对思考的影响，只是尽量，实际上很难。如恐慌，贪婪的情绪对人影响很大。\n4. 从更高纬度寻找通用性，普适性规律。思考问题的本质，且持续迭代思考。因为1-2次的思考可能是不够深刻的。\n5. 保持独立思考，保留尽量多的独处时间，内心平静。不附和他人，附和自己判断错误的观点是用羞耻换取资源。不执着自己，因为自己的思考可能是有瑕疵的。说话前要过脑子，宁愿说的慢一点。\n6. 怀疑大部分的一切。尤其是习以为常的观点，如群众的眼睛是雪亮的，和真理掌握在少数人手里，就会推演出既然群众那么雪亮为何看不到真理？\n7. 不和思维混乱的人辩论，保持沉默即可。\n8. 大量的阅读，否则思辨缺乏原材料。哲学类，自然科学类，社会学，历史，宗教。\n\n思维习惯的形成是一个强制定形到灵活掌握的过程，一开始需要很机械的按一个模板来思考问题。会耗费大量时间。\n","slug":"humanbeings/thoughts","published":1,"updated":"2019-06-01T09:19:30.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwj000jax48jiuxypcc","content":"<p>批判性思维</p>\n<a id=\"more\"></a>\n<ol>\n<li>凡事明确概念，明确定义，不讨论定义模糊的事情。</li>\n<li>演绎与归纳的严密性。分辨观点与事实，假设与结论。</li>\n<li>尽量去除情绪对思考的影响，只是尽量，实际上很难。如恐慌，贪婪的情绪对人影响很大。</li>\n<li>从更高纬度寻找通用性，普适性规律。思考问题的本质，且持续迭代思考。因为1-2次的思考可能是不够深刻的。</li>\n<li>保持独立思考，保留尽量多的独处时间，内心平静。不附和他人，附和自己判断错误的观点是用羞耻换取资源。不执着自己，因为自己的思考可能是有瑕疵的。说话前要过脑子，宁愿说的慢一点。</li>\n<li>怀疑大部分的一切。尤其是习以为常的观点，如群众的眼睛是雪亮的，和真理掌握在少数人手里，就会推演出既然群众那么雪亮为何看不到真理？</li>\n<li>不和思维混乱的人辩论，保持沉默即可。</li>\n<li>大量的阅读，否则思辨缺乏原材料。哲学类，自然科学类，社会学，历史，宗教。</li>\n</ol>\n<p>思维习惯的形成是一个强制定形到灵活掌握的过程，一开始需要很机械的按一个模板来思考问题。会耗费大量时间。</p>\n","site":{"data":{}},"excerpt":"<p>批判性思维</p>","more":"<ol>\n<li>凡事明确概念，明确定义，不讨论定义模糊的事情。</li>\n<li>演绎与归纳的严密性。分辨观点与事实，假设与结论。</li>\n<li>尽量去除情绪对思考的影响，只是尽量，实际上很难。如恐慌，贪婪的情绪对人影响很大。</li>\n<li>从更高纬度寻找通用性，普适性规律。思考问题的本质，且持续迭代思考。因为1-2次的思考可能是不够深刻的。</li>\n<li>保持独立思考，保留尽量多的独处时间，内心平静。不附和他人，附和自己判断错误的观点是用羞耻换取资源。不执着自己，因为自己的思考可能是有瑕疵的。说话前要过脑子，宁愿说的慢一点。</li>\n<li>怀疑大部分的一切。尤其是习以为常的观点，如群众的眼睛是雪亮的，和真理掌握在少数人手里，就会推演出既然群众那么雪亮为何看不到真理？</li>\n<li>不和思维混乱的人辩论，保持沉默即可。</li>\n<li>大量的阅读，否则思辨缺乏原材料。哲学类，自然科学类，社会学，历史，宗教。</li>\n</ol>\n<p>思维习惯的形成是一个强制定形到灵活掌握的过程，一开始需要很机械的按一个模板来思考问题。会耗费大量时间。</p>"},{"title":"The to do list of 2019","date":"2019-12-29T16:00:00.000Z","_content":"The to do list of 2019.\n\n<!-- more -->\n\n**Material things:**\n\n- React lifecycle/上下文API/指针事件/Lazy/React.memo/React Hooks/Suspense API.\n\n- Typescript to advanced.\n\n- Webpack to advanced.\n\n- Node.js to advanced.\n\n\n**Essential things:**\n\n- Logical ability to advanced.\n\n- Architectural ability to advanced.\n\n- More complete knowledge system.\n\n.\n.\n.\n.\n\nDivergent thinking.\n\nKeep moving.\n\nTO BE A ARCHITECT.","source":"_posts/todolist/index.md","raw":"---\ntitle: The to do list of 2019\ntags:\n  - to do list\ndate: 2019-12-30 00:00:00\ncategories: to do list\n---\nThe to do list of 2019.\n\n<!-- more -->\n\n**Material things:**\n\n- React lifecycle/上下文API/指针事件/Lazy/React.memo/React Hooks/Suspense API.\n\n- Typescript to advanced.\n\n- Webpack to advanced.\n\n- Node.js to advanced.\n\n\n**Essential things:**\n\n- Logical ability to advanced.\n\n- Architectural ability to advanced.\n\n- More complete knowledge system.\n\n.\n.\n.\n.\n\nDivergent thinking.\n\nKeep moving.\n\nTO BE A ARCHITECT.","slug":"todolist/index","published":1,"updated":"2019-05-13T02:44:31.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwk000lax48huu85tsk","content":"<p>The to do list of 2019.</p>\n<a id=\"more\"></a>\n<p><strong>Material things:</strong></p>\n<ul>\n<li><p>React lifecycle/上下文API/指针事件/Lazy/React.memo/React Hooks/Suspense API.</p>\n</li>\n<li><p>Typescript to advanced.</p>\n</li>\n<li><p>Webpack to advanced.</p>\n</li>\n<li><p>Node.js to advanced.</p>\n</li>\n</ul>\n<p><strong>Essential things:</strong></p>\n<ul>\n<li><p>Logical ability to advanced.</p>\n</li>\n<li><p>Architectural ability to advanced.</p>\n</li>\n<li><p>More complete knowledge system.</p>\n</li>\n</ul>\n<p>.<br>.<br>.<br>.</p>\n<p>Divergent thinking.</p>\n<p>Keep moving.</p>\n<p>TO BE A ARCHITECT.</p>\n","site":{"data":{}},"excerpt":"<p>The to do list of 2019.</p>","more":"<p><strong>Material things:</strong></p>\n<ul>\n<li><p>React lifecycle/上下文API/指针事件/Lazy/React.memo/React Hooks/Suspense API.</p>\n</li>\n<li><p>Typescript to advanced.</p>\n</li>\n<li><p>Webpack to advanced.</p>\n</li>\n<li><p>Node.js to advanced.</p>\n</li>\n</ul>\n<p><strong>Essential things:</strong></p>\n<ul>\n<li><p>Logical ability to advanced.</p>\n</li>\n<li><p>Architectural ability to advanced.</p>\n</li>\n<li><p>More complete knowledge system.</p>\n</li>\n</ul>\n<p>.<br>.<br>.<br>.</p>\n<p>Divergent thinking.</p>\n<p>Keep moving.</p>\n<p>TO BE A ARCHITECT.</p>"},{"title":"人间失格","date":"2019-04-24T05:41:00.000Z","_content":"“生而为人，我很抱歉”\n<!-- more -->\n\n大庭叶藏，生于一个家风严谨的日本家族。\n\n叶藏以为天桥复杂的结构是为了让车站像国外的游乐场那样妙趣横生，地铁的建造仅仅是觉得坐地下的车比坐地上的车更有趣。但实际上，公共设施的诞生都是为了方便人类活动。“不吃饭会死的，”在他眼中，这无疑是一种恐吓。\n\n由此他得出一个结论：我不知道人为什么活着，我的幸福观和世人的风马牛不相及，我很不安。\n\n为了摆脱内心的不安和恐惧，叶藏选择扮演小丑来逗笑。面具一旦戴上，叶藏再也摘不下来，他必须收起自己所有的意愿，去当家人、仆人以及同学的笑料。然而假的永远真不了，他被识破了，为了掩饰，他又必须哄好这个拆穿者。假装对他好，假装关心他，安抚他，颤栗度过初中后，认识同为画画的学生堀木。后来一步步跟着堀木堕落，因为整天戴着面具做人太辛苦了，所以叶藏不得不用酒精麻醉自己，用女人安抚自己，他有时觉得自己真该去死，做爱醒来又觉得自己无能为力，连画画都丢掉了，肉体都拿去卖了，靠女人生活。酗酒，做爱，吸毒，要整天为金钱奔波，虽然后来叶藏最后一任妻子良子出现了，但还是拯救不到他，亲眼看着良子被歹心的商人玷污却没有任何动作。\n\n叶藏是如此与这个虚伪的世界格格不入，他正深处在人间的地狱中。正如后记老板娘所说的：我认识的小叶非常坦率，也十分机灵。要是他不喝酒的话……不，就算是他喝了酒，也依然是个像神一样的好孩子。我不知道面前的你对此有何看法。\n\n人间失格借一个受害者的口吻来讲述人类的丑恶，自私自利，好逸恶劳……同样，我也不觉得现实的太宰治是个带坏头的作家，他只不过自杀了，去寻求解脱，但更重要的是他终于能替自己做一回选择，终于不用带着面具生活。\n\n太宰治在《晚年》写过一句话，大意是“我本想这个冬日就去死的，可最近拿到一套鼠灰色细条纹的麻质和服，是适合夏天穿的和服，所以我还是先活到夏天吧。” 而我一想到好多好看的衣服没穿过，好多好吃的食物没吃过，好多好玩的地方没去过，好多好心的人没见过，好多豪车没坐过，我稍稍喜欢这个世界了。那些一味想着死的事，一定是太过认真的活吧！\n\n夜晚酣睡一宿，早晨便神清气爽吗？做过什么梦？行走的时候在思考什么？金钱？总不至于仅仅如此吧？我仿佛听说过人是为了吃饭而活着的学说，但却不曾听说过是为了金钱而活着。然而。。。或许，我也不清楚，越是思考，我就越加茫然。\n\n自还提时代起，即便是对骨肉至亲，我也全然不了解他们的生活是何等的痛楚，不了解他们在思考些什么。\n\n我在愤怒者脸上看出比狮子比鳄鱼比毒龙更为可怖的动物本性。平时将着本性隐藏起来，一旦有了机会，好比温文尔雅地躺在草地上的牛，突如其来的地狂甩尾巴打杀肚皮上的牛虻一般，会因为愤怒而意想不到地暴露人类可怕的原型。看到这些，我便会毛发倒竖战栗不已，想到这本性或许也是人类赖以生存下去的资格之一。\n\n对幼小者做那种事，是人类所能够犯下的罪恶中最为丑恶下流、残酷无比的恶性。 实际上包括那些发出嘲笑的人在内，人类不正是在彼此的互不信任中，根本不是将什么耶和华之类放在心上，无动于衷地苟且度日的吗？\n\n迄今为止我还从未与年幼于我的处女睡过觉呢！结婚吧！无论将有多么巨大的悲哀接踵而至！哪怕此生此世只有这么一次巨大粗暴的快乐！\n\n一旦我将要遗忘，便会有怪鸟拍起翅膀来，用它那利喙啄破记忆的伤口。顷刻之间，过去的耻辱与罪孽便清晰的涌现在眼前，我恐怖的几乎叫出声，再也坐不住了。\n\n良子那纯洁的信赖，就如同绿叶的瀑布一般，清新宜人。可一夜之间，它就变成了黄色的污水。\n\n信任即乎罪？\n\n纯真之信任心，即罪乎？\n\n不抵抗即乎罪？\n","source":"_posts/humanbeings/人间失格.md","raw":"---\ntitle: 人间失格\ntags:\n  - 当我在扯淡\ndate: 2019-04-24 13:41:00\ncategories: 当我在扯淡\n---\n“生而为人，我很抱歉”\n<!-- more -->\n\n大庭叶藏，生于一个家风严谨的日本家族。\n\n叶藏以为天桥复杂的结构是为了让车站像国外的游乐场那样妙趣横生，地铁的建造仅仅是觉得坐地下的车比坐地上的车更有趣。但实际上，公共设施的诞生都是为了方便人类活动。“不吃饭会死的，”在他眼中，这无疑是一种恐吓。\n\n由此他得出一个结论：我不知道人为什么活着，我的幸福观和世人的风马牛不相及，我很不安。\n\n为了摆脱内心的不安和恐惧，叶藏选择扮演小丑来逗笑。面具一旦戴上，叶藏再也摘不下来，他必须收起自己所有的意愿，去当家人、仆人以及同学的笑料。然而假的永远真不了，他被识破了，为了掩饰，他又必须哄好这个拆穿者。假装对他好，假装关心他，安抚他，颤栗度过初中后，认识同为画画的学生堀木。后来一步步跟着堀木堕落，因为整天戴着面具做人太辛苦了，所以叶藏不得不用酒精麻醉自己，用女人安抚自己，他有时觉得自己真该去死，做爱醒来又觉得自己无能为力，连画画都丢掉了，肉体都拿去卖了，靠女人生活。酗酒，做爱，吸毒，要整天为金钱奔波，虽然后来叶藏最后一任妻子良子出现了，但还是拯救不到他，亲眼看着良子被歹心的商人玷污却没有任何动作。\n\n叶藏是如此与这个虚伪的世界格格不入，他正深处在人间的地狱中。正如后记老板娘所说的：我认识的小叶非常坦率，也十分机灵。要是他不喝酒的话……不，就算是他喝了酒，也依然是个像神一样的好孩子。我不知道面前的你对此有何看法。\n\n人间失格借一个受害者的口吻来讲述人类的丑恶，自私自利，好逸恶劳……同样，我也不觉得现实的太宰治是个带坏头的作家，他只不过自杀了，去寻求解脱，但更重要的是他终于能替自己做一回选择，终于不用带着面具生活。\n\n太宰治在《晚年》写过一句话，大意是“我本想这个冬日就去死的，可最近拿到一套鼠灰色细条纹的麻质和服，是适合夏天穿的和服，所以我还是先活到夏天吧。” 而我一想到好多好看的衣服没穿过，好多好吃的食物没吃过，好多好玩的地方没去过，好多好心的人没见过，好多豪车没坐过，我稍稍喜欢这个世界了。那些一味想着死的事，一定是太过认真的活吧！\n\n夜晚酣睡一宿，早晨便神清气爽吗？做过什么梦？行走的时候在思考什么？金钱？总不至于仅仅如此吧？我仿佛听说过人是为了吃饭而活着的学说，但却不曾听说过是为了金钱而活着。然而。。。或许，我也不清楚，越是思考，我就越加茫然。\n\n自还提时代起，即便是对骨肉至亲，我也全然不了解他们的生活是何等的痛楚，不了解他们在思考些什么。\n\n我在愤怒者脸上看出比狮子比鳄鱼比毒龙更为可怖的动物本性。平时将着本性隐藏起来，一旦有了机会，好比温文尔雅地躺在草地上的牛，突如其来的地狂甩尾巴打杀肚皮上的牛虻一般，会因为愤怒而意想不到地暴露人类可怕的原型。看到这些，我便会毛发倒竖战栗不已，想到这本性或许也是人类赖以生存下去的资格之一。\n\n对幼小者做那种事，是人类所能够犯下的罪恶中最为丑恶下流、残酷无比的恶性。 实际上包括那些发出嘲笑的人在内，人类不正是在彼此的互不信任中，根本不是将什么耶和华之类放在心上，无动于衷地苟且度日的吗？\n\n迄今为止我还从未与年幼于我的处女睡过觉呢！结婚吧！无论将有多么巨大的悲哀接踵而至！哪怕此生此世只有这么一次巨大粗暴的快乐！\n\n一旦我将要遗忘，便会有怪鸟拍起翅膀来，用它那利喙啄破记忆的伤口。顷刻之间，过去的耻辱与罪孽便清晰的涌现在眼前，我恐怖的几乎叫出声，再也坐不住了。\n\n良子那纯洁的信赖，就如同绿叶的瀑布一般，清新宜人。可一夜之间，它就变成了黄色的污水。\n\n信任即乎罪？\n\n纯真之信任心，即罪乎？\n\n不抵抗即乎罪？\n","slug":"humanbeings/人间失格","published":1,"updated":"2019-04-24T05:55:47.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwm000qax48yt9ah98u","content":"<p>“生而为人，我很抱歉”<br><a id=\"more\"></a></p>\n<p>大庭叶藏，生于一个家风严谨的日本家族。</p>\n<p>叶藏以为天桥复杂的结构是为了让车站像国外的游乐场那样妙趣横生，地铁的建造仅仅是觉得坐地下的车比坐地上的车更有趣。但实际上，公共设施的诞生都是为了方便人类活动。“不吃饭会死的，”在他眼中，这无疑是一种恐吓。</p>\n<p>由此他得出一个结论：我不知道人为什么活着，我的幸福观和世人的风马牛不相及，我很不安。</p>\n<p>为了摆脱内心的不安和恐惧，叶藏选择扮演小丑来逗笑。面具一旦戴上，叶藏再也摘不下来，他必须收起自己所有的意愿，去当家人、仆人以及同学的笑料。然而假的永远真不了，他被识破了，为了掩饰，他又必须哄好这个拆穿者。假装对他好，假装关心他，安抚他，颤栗度过初中后，认识同为画画的学生堀木。后来一步步跟着堀木堕落，因为整天戴着面具做人太辛苦了，所以叶藏不得不用酒精麻醉自己，用女人安抚自己，他有时觉得自己真该去死，做爱醒来又觉得自己无能为力，连画画都丢掉了，肉体都拿去卖了，靠女人生活。酗酒，做爱，吸毒，要整天为金钱奔波，虽然后来叶藏最后一任妻子良子出现了，但还是拯救不到他，亲眼看着良子被歹心的商人玷污却没有任何动作。</p>\n<p>叶藏是如此与这个虚伪的世界格格不入，他正深处在人间的地狱中。正如后记老板娘所说的：我认识的小叶非常坦率，也十分机灵。要是他不喝酒的话……不，就算是他喝了酒，也依然是个像神一样的好孩子。我不知道面前的你对此有何看法。</p>\n<p>人间失格借一个受害者的口吻来讲述人类的丑恶，自私自利，好逸恶劳……同样，我也不觉得现实的太宰治是个带坏头的作家，他只不过自杀了，去寻求解脱，但更重要的是他终于能替自己做一回选择，终于不用带着面具生活。</p>\n<p>太宰治在《晚年》写过一句话，大意是“我本想这个冬日就去死的，可最近拿到一套鼠灰色细条纹的麻质和服，是适合夏天穿的和服，所以我还是先活到夏天吧。” 而我一想到好多好看的衣服没穿过，好多好吃的食物没吃过，好多好玩的地方没去过，好多好心的人没见过，好多豪车没坐过，我稍稍喜欢这个世界了。那些一味想着死的事，一定是太过认真的活吧！</p>\n<p>夜晚酣睡一宿，早晨便神清气爽吗？做过什么梦？行走的时候在思考什么？金钱？总不至于仅仅如此吧？我仿佛听说过人是为了吃饭而活着的学说，但却不曾听说过是为了金钱而活着。然而。。。或许，我也不清楚，越是思考，我就越加茫然。</p>\n<p>自还提时代起，即便是对骨肉至亲，我也全然不了解他们的生活是何等的痛楚，不了解他们在思考些什么。</p>\n<p>我在愤怒者脸上看出比狮子比鳄鱼比毒龙更为可怖的动物本性。平时将着本性隐藏起来，一旦有了机会，好比温文尔雅地躺在草地上的牛，突如其来的地狂甩尾巴打杀肚皮上的牛虻一般，会因为愤怒而意想不到地暴露人类可怕的原型。看到这些，我便会毛发倒竖战栗不已，想到这本性或许也是人类赖以生存下去的资格之一。</p>\n<p>对幼小者做那种事，是人类所能够犯下的罪恶中最为丑恶下流、残酷无比的恶性。 实际上包括那些发出嘲笑的人在内，人类不正是在彼此的互不信任中，根本不是将什么耶和华之类放在心上，无动于衷地苟且度日的吗？</p>\n<p>迄今为止我还从未与年幼于我的处女睡过觉呢！结婚吧！无论将有多么巨大的悲哀接踵而至！哪怕此生此世只有这么一次巨大粗暴的快乐！</p>\n<p>一旦我将要遗忘，便会有怪鸟拍起翅膀来，用它那利喙啄破记忆的伤口。顷刻之间，过去的耻辱与罪孽便清晰的涌现在眼前，我恐怖的几乎叫出声，再也坐不住了。</p>\n<p>良子那纯洁的信赖，就如同绿叶的瀑布一般，清新宜人。可一夜之间，它就变成了黄色的污水。</p>\n<p>信任即乎罪？</p>\n<p>纯真之信任心，即罪乎？</p>\n<p>不抵抗即乎罪？</p>\n","site":{"data":{}},"excerpt":"<p>“生而为人，我很抱歉”<br></p>","more":"<p></p>\n<p>大庭叶藏，生于一个家风严谨的日本家族。</p>\n<p>叶藏以为天桥复杂的结构是为了让车站像国外的游乐场那样妙趣横生，地铁的建造仅仅是觉得坐地下的车比坐地上的车更有趣。但实际上，公共设施的诞生都是为了方便人类活动。“不吃饭会死的，”在他眼中，这无疑是一种恐吓。</p>\n<p>由此他得出一个结论：我不知道人为什么活着，我的幸福观和世人的风马牛不相及，我很不安。</p>\n<p>为了摆脱内心的不安和恐惧，叶藏选择扮演小丑来逗笑。面具一旦戴上，叶藏再也摘不下来，他必须收起自己所有的意愿，去当家人、仆人以及同学的笑料。然而假的永远真不了，他被识破了，为了掩饰，他又必须哄好这个拆穿者。假装对他好，假装关心他，安抚他，颤栗度过初中后，认识同为画画的学生堀木。后来一步步跟着堀木堕落，因为整天戴着面具做人太辛苦了，所以叶藏不得不用酒精麻醉自己，用女人安抚自己，他有时觉得自己真该去死，做爱醒来又觉得自己无能为力，连画画都丢掉了，肉体都拿去卖了，靠女人生活。酗酒，做爱，吸毒，要整天为金钱奔波，虽然后来叶藏最后一任妻子良子出现了，但还是拯救不到他，亲眼看着良子被歹心的商人玷污却没有任何动作。</p>\n<p>叶藏是如此与这个虚伪的世界格格不入，他正深处在人间的地狱中。正如后记老板娘所说的：我认识的小叶非常坦率，也十分机灵。要是他不喝酒的话……不，就算是他喝了酒，也依然是个像神一样的好孩子。我不知道面前的你对此有何看法。</p>\n<p>人间失格借一个受害者的口吻来讲述人类的丑恶，自私自利，好逸恶劳……同样，我也不觉得现实的太宰治是个带坏头的作家，他只不过自杀了，去寻求解脱，但更重要的是他终于能替自己做一回选择，终于不用带着面具生活。</p>\n<p>太宰治在《晚年》写过一句话，大意是“我本想这个冬日就去死的，可最近拿到一套鼠灰色细条纹的麻质和服，是适合夏天穿的和服，所以我还是先活到夏天吧。” 而我一想到好多好看的衣服没穿过，好多好吃的食物没吃过，好多好玩的地方没去过，好多好心的人没见过，好多豪车没坐过，我稍稍喜欢这个世界了。那些一味想着死的事，一定是太过认真的活吧！</p>\n<p>夜晚酣睡一宿，早晨便神清气爽吗？做过什么梦？行走的时候在思考什么？金钱？总不至于仅仅如此吧？我仿佛听说过人是为了吃饭而活着的学说，但却不曾听说过是为了金钱而活着。然而。。。或许，我也不清楚，越是思考，我就越加茫然。</p>\n<p>自还提时代起，即便是对骨肉至亲，我也全然不了解他们的生活是何等的痛楚，不了解他们在思考些什么。</p>\n<p>我在愤怒者脸上看出比狮子比鳄鱼比毒龙更为可怖的动物本性。平时将着本性隐藏起来，一旦有了机会，好比温文尔雅地躺在草地上的牛，突如其来的地狂甩尾巴打杀肚皮上的牛虻一般，会因为愤怒而意想不到地暴露人类可怕的原型。看到这些，我便会毛发倒竖战栗不已，想到这本性或许也是人类赖以生存下去的资格之一。</p>\n<p>对幼小者做那种事，是人类所能够犯下的罪恶中最为丑恶下流、残酷无比的恶性。 实际上包括那些发出嘲笑的人在内，人类不正是在彼此的互不信任中，根本不是将什么耶和华之类放在心上，无动于衷地苟且度日的吗？</p>\n<p>迄今为止我还从未与年幼于我的处女睡过觉呢！结婚吧！无论将有多么巨大的悲哀接踵而至！哪怕此生此世只有这么一次巨大粗暴的快乐！</p>\n<p>一旦我将要遗忘，便会有怪鸟拍起翅膀来，用它那利喙啄破记忆的伤口。顷刻之间，过去的耻辱与罪孽便清晰的涌现在眼前，我恐怖的几乎叫出声，再也坐不住了。</p>\n<p>良子那纯洁的信赖，就如同绿叶的瀑布一般，清新宜人。可一夜之间，它就变成了黄色的污水。</p>\n<p>信任即乎罪？</p>\n<p>纯真之信任心，即罪乎？</p>\n<p>不抵抗即乎罪？</p>"},{"title":"关于ajax请求","date":"2019-07-04T06:50:22.000Z","_content":"`Asynchronous Javascript And XML`\n<!-- more -->\nAjax已经成为前后端数据通信不可或缺的技术之一，它的异步让前端数据获取向前迈了一大步，配合view-model静态更新视图带来更好的交互体验已经成为当前web发展的主流\n\n# 最初的XHR\n\n所有浏览器都支持的XHR对象 `XMLHttpRequest`\n```js\nconst xhr = new XMLHttpRequest() //获取xhr对象\n```\n\n但是IE非要展示自己的存在感坚强的要发出自己的声音，甚至于不同版本的IE浏览器之间还有不同的声音🤣\n```js\nlet xhr\n\nif (window.XMLHttpRequest) { // Mozilla, Safari...\n  xhr = new XMLHttpRequest()\n}\n\nif (window.ActiveXObject) { // IE\n  try {\n    xhr = new ActiveXObject('Msxml2.XMLHTTP')\n  } catch (e) {\n    try {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP')  // IE5、6\n    } catch (e) {}\n  }\n}\n```\n\n有了上面这个xhr对象就可以发送真正的请求了\n```js\n// GET\nxhr.open(\"GET\",\"xxx.json\",true)\nxhr.send()\n\n// POST\nxhr.onreadystatechange = function onReadyStateChange() {\n  const {readyState, status} = xhr\n\n  if (readyState === 4 && status === 200) {\n    console.log('success')\n  } else {\n    console.log('failed')\n  }\n}\nxhr.open('POST', '/api', true)\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\nxhr.send('username=admin&password=root')\n```\n# jQuery ajax\nAjax将XHR进行封装，让开发者可以更加便捷方便进行使用\n```js\n$.ajax({\n   type: 'POST',\n   url: url,\n   data: data,\n   dataType: dataType,\n   success: function () {},\n   error: function () {}\n})\n\n$.get(url,function(){})\n$.post(url,body,function(){})\n```\n\n优点：\n- 对原生XHR的封装\n- 针对MVC的编程\n- 完美的兼容性\n- 支持jsonp\n\n缺点：\n- 不符合MVVM\n- 异步模型不够现代，不支持链式，代码可读性差\n- 整个Jquery太大，引入成本过高\n\n# fetch\nfetch是es6后出现的全新API，完全是基于Promise的异步处理机制，使用起来会比起ajax更加简单\n\n使用fetch的代码会相比xhr具有条理性\n\n```js\nfetch(url).then(response => response.json())\n  .then(data => console.log(data))\n  .catch(e => console.log(\"Oops, error\", e))\n```\n优点：\n- 更加底层，提供的API丰富（request, response）\n- 语法简单，脱离了XHR，基于ES新的Promise设计\n- 看到以上，或许你会觉得fetch真的很美好，但是请了解，fetch本身是一个 low-level 的 API，它注定不会像你习惯的 $.ajax - 或是 axios 等库帮你封装各种各样的功能或实现\n\n缺点：\n- 兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装常见的polyfill就有：es6-promise,babel-polyfill,fetch-ie8等\n  > [https://caniuse.com/#search=fetch](https://caniuse.com/#search=fetch)\n\n- 不支持jsonp，可以引入fetch-jsonp `npm install fetch-jsonp --save-dev`\n`fetchJsonp(url, { timeout: 3000, jsonpCallback: 'callback' }).then(function(response) { console.log(response.json()) }).catch(function(e) { console.log(e) })`\n- 没有拦截器，需要额外再封装一层或者fetch-interceptor\n- 默认不带cookie，需要添加配置 `fetch(url,{credentials: 'include'})`\n- 没有abort，不支持timeout超时处理,可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject\n- 无法获取progress状态: fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取参考javascript - Progress indicators for fetch? - Stack Overflow 2016 - the year of web streams\n\n# Axios\n尤大在vue中强推的ajax库\n\n特点：\n- 支持node，创建http请求\n- 支持Promise API\n- 客户端防止CSRF：每个请求带一个cookie拿到的key\n- 拦截请求和响应\n- 可取消请求\n\n兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容\n\nusage:\n```js\naxios({\n  method: 'GET',\n  url: url,\n})\n  .then(res => {console.log(res)})\n  .catch(err => {console.log(err)})\n\n// get请求\naxios.get(url)\n  .then(function (response) {\n    console.log(response)\n  })\n  .catch(function (error) {\n    console.log(error)\n  })\n\n// post请求\naxios.post（`/user`, {\n    name: 'admin',\n    pw: '123456'\n  })\n  .then(function (response) {\n    console.log(response)\n  })\n  .catch(function (error) {\n    console.log(error)\n  })\n```\n\n# Last\n请求在本身上会有两种问题需要额外处理，处理方式就见仁见智\n- 请求串行\n- 请求并行\n  \n在使用方面：\n首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择\n如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax\n如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践（突然为yqb的mzone_fetch感到头疼😭）","source":"_posts/writeSomething/AboutAjax.md","raw":"---\ntitle: 关于ajax请求\ntags:\n  - ajax\ndate: 2019-07-04 14:50:22\ncategories: ajax\n---\n`Asynchronous Javascript And XML`\n<!-- more -->\nAjax已经成为前后端数据通信不可或缺的技术之一，它的异步让前端数据获取向前迈了一大步，配合view-model静态更新视图带来更好的交互体验已经成为当前web发展的主流\n\n# 最初的XHR\n\n所有浏览器都支持的XHR对象 `XMLHttpRequest`\n```js\nconst xhr = new XMLHttpRequest() //获取xhr对象\n```\n\n但是IE非要展示自己的存在感坚强的要发出自己的声音，甚至于不同版本的IE浏览器之间还有不同的声音🤣\n```js\nlet xhr\n\nif (window.XMLHttpRequest) { // Mozilla, Safari...\n  xhr = new XMLHttpRequest()\n}\n\nif (window.ActiveXObject) { // IE\n  try {\n    xhr = new ActiveXObject('Msxml2.XMLHTTP')\n  } catch (e) {\n    try {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP')  // IE5、6\n    } catch (e) {}\n  }\n}\n```\n\n有了上面这个xhr对象就可以发送真正的请求了\n```js\n// GET\nxhr.open(\"GET\",\"xxx.json\",true)\nxhr.send()\n\n// POST\nxhr.onreadystatechange = function onReadyStateChange() {\n  const {readyState, status} = xhr\n\n  if (readyState === 4 && status === 200) {\n    console.log('success')\n  } else {\n    console.log('failed')\n  }\n}\nxhr.open('POST', '/api', true)\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\nxhr.send('username=admin&password=root')\n```\n# jQuery ajax\nAjax将XHR进行封装，让开发者可以更加便捷方便进行使用\n```js\n$.ajax({\n   type: 'POST',\n   url: url,\n   data: data,\n   dataType: dataType,\n   success: function () {},\n   error: function () {}\n})\n\n$.get(url,function(){})\n$.post(url,body,function(){})\n```\n\n优点：\n- 对原生XHR的封装\n- 针对MVC的编程\n- 完美的兼容性\n- 支持jsonp\n\n缺点：\n- 不符合MVVM\n- 异步模型不够现代，不支持链式，代码可读性差\n- 整个Jquery太大，引入成本过高\n\n# fetch\nfetch是es6后出现的全新API，完全是基于Promise的异步处理机制，使用起来会比起ajax更加简单\n\n使用fetch的代码会相比xhr具有条理性\n\n```js\nfetch(url).then(response => response.json())\n  .then(data => console.log(data))\n  .catch(e => console.log(\"Oops, error\", e))\n```\n优点：\n- 更加底层，提供的API丰富（request, response）\n- 语法简单，脱离了XHR，基于ES新的Promise设计\n- 看到以上，或许你会觉得fetch真的很美好，但是请了解，fetch本身是一个 low-level 的 API，它注定不会像你习惯的 $.ajax - 或是 axios 等库帮你封装各种各样的功能或实现\n\n缺点：\n- 兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装常见的polyfill就有：es6-promise,babel-polyfill,fetch-ie8等\n  > [https://caniuse.com/#search=fetch](https://caniuse.com/#search=fetch)\n\n- 不支持jsonp，可以引入fetch-jsonp `npm install fetch-jsonp --save-dev`\n`fetchJsonp(url, { timeout: 3000, jsonpCallback: 'callback' }).then(function(response) { console.log(response.json()) }).catch(function(e) { console.log(e) })`\n- 没有拦截器，需要额外再封装一层或者fetch-interceptor\n- 默认不带cookie，需要添加配置 `fetch(url,{credentials: 'include'})`\n- 没有abort，不支持timeout超时处理,可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject\n- 无法获取progress状态: fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取参考javascript - Progress indicators for fetch? - Stack Overflow 2016 - the year of web streams\n\n# Axios\n尤大在vue中强推的ajax库\n\n特点：\n- 支持node，创建http请求\n- 支持Promise API\n- 客户端防止CSRF：每个请求带一个cookie拿到的key\n- 拦截请求和响应\n- 可取消请求\n\n兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容\n\nusage:\n```js\naxios({\n  method: 'GET',\n  url: url,\n})\n  .then(res => {console.log(res)})\n  .catch(err => {console.log(err)})\n\n// get请求\naxios.get(url)\n  .then(function (response) {\n    console.log(response)\n  })\n  .catch(function (error) {\n    console.log(error)\n  })\n\n// post请求\naxios.post（`/user`, {\n    name: 'admin',\n    pw: '123456'\n  })\n  .then(function (response) {\n    console.log(response)\n  })\n  .catch(function (error) {\n    console.log(error)\n  })\n```\n\n# Last\n请求在本身上会有两种问题需要额外处理，处理方式就见仁见智\n- 请求串行\n- 请求并行\n  \n在使用方面：\n首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择\n如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax\n如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践（突然为yqb的mzone_fetch感到头疼😭）","slug":"writeSomething/AboutAjax","published":1,"updated":"2019-07-04T07:45:23.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwn000tax48sq1okg0c","content":"<p><code>Asynchronous Javascript And XML</code><br><a id=\"more\"></a><br>Ajax已经成为前后端数据通信不可或缺的技术之一，它的异步让前端数据获取向前迈了一大步，配合view-model静态更新视图带来更好的交互体验已经成为当前web发展的主流</p>\n<h1 id=\"最初的XHR\"><a href=\"#最初的XHR\" class=\"headerlink\" title=\"最初的XHR\"></a>最初的XHR</h1><p>所有浏览器都支持的XHR对象 <code>XMLHttpRequest</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest() <span class=\"comment\">//获取xhr对象</span></span><br></pre></td></tr></table></figure></p>\n<p>但是IE非要展示自己的存在感坚强的要发出自己的声音，甚至于不同版本的IE浏览器之间还有不同的声音🤣<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xhr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest) &#123; <span class=\"comment\">// Mozilla, Safari...</span></span><br><span class=\"line\">  xhr = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.ActiveXObject) &#123; <span class=\"comment\">// IE</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'Msxml2.XMLHTTP'</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'Microsoft.XMLHTTP'</span>)  <span class=\"comment\">// IE5、6</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有了上面这个xhr对象就可以发送真正的请求了<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GET</span></span><br><span class=\"line\">xhr.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"xxx.json\"</span>,<span class=\"literal\">true</span>)</span><br><span class=\"line\">xhr.send()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST</span></span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onReadyStateChange</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;readyState, status&#125; = xhr</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (readyState === <span class=\"number\">4</span> &amp;&amp; status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'success'</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'failed'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xhr.open(<span class=\"string\">'POST'</span>, <span class=\"string\">'/api'</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'application/x-www-form-urlencoded'</span>)</span><br><span class=\"line\">xhr.send(<span class=\"string\">'username=admin&amp;password=root'</span>)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"jQuery-ajax\"><a href=\"#jQuery-ajax\" class=\"headerlink\" title=\"jQuery ajax\"></a>jQuery ajax</h1><p>Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">   type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">   url: url,</span><br><span class=\"line\">   data: data,</span><br><span class=\"line\">   dataType: dataType,</span><br><span class=\"line\">   success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">   error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">$.<span class=\"keyword\">get</span>(url,function()&#123;&#125;)</span><br><span class=\"line\">$.post(url,body,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ul>\n<li>对原生XHR的封装</li>\n<li>针对MVC的编程</li>\n<li>完美的兼容性</li>\n<li>支持jsonp</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>不符合MVVM</li>\n<li>异步模型不够现代，不支持链式，代码可读性差</li>\n<li>整个Jquery太大，引入成本过高</li>\n</ul>\n<h1 id=\"fetch\"><a href=\"#fetch\" class=\"headerlink\" title=\"fetch\"></a>fetch</h1><p>fetch是es6后出现的全新API，完全是基于Promise的异步处理机制，使用起来会比起ajax更加简单</p>\n<p>使用fetch的代码会相比xhr具有条理性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url).then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"built_in\">console</span>.log(data))</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Oops, error\"</span>, e))</span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ul>\n<li>更加底层，提供的API丰富（request, response）</li>\n<li>语法简单，脱离了XHR，基于ES新的Promise设计</li>\n<li>看到以上，或许你会觉得fetch真的很美好，但是请了解，fetch本身是一个 low-level 的 API，它注定不会像你习惯的 $.ajax - 或是 axios 等库帮你封装各种各样的功能或实现</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><p>兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装常见的polyfill就有：es6-promise,babel-polyfill,fetch-ie8等</p>\n<blockquote>\n<p><a href=\"https://caniuse.com/#search=fetch\" target=\"_blank\" rel=\"noopener\">https://caniuse.com/#search=fetch</a></p>\n</blockquote>\n</li>\n<li><p>不支持jsonp，可以引入fetch-jsonp <code>npm install fetch-jsonp --save-dev</code><br><code>fetchJsonp(url, { timeout: 3000, jsonpCallback: &#39;callback&#39; }).then(function(response) { console.log(response.json()) }).catch(function(e) { console.log(e) })</code></p>\n</li>\n<li>没有拦截器，需要额外再封装一层或者fetch-interceptor</li>\n<li>默认不带cookie，需要添加配置 <code>fetch(url,{credentials: &#39;include&#39;})</code></li>\n<li>没有abort，不支持timeout超时处理,可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject</li>\n<li>无法获取progress状态: fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取参考javascript - Progress indicators for fetch? - Stack Overflow 2016 - the year of web streams</li>\n</ul>\n<h1 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h1><p>尤大在vue中强推的ajax库</p>\n<p>特点：</p>\n<ul>\n<li>支持node，创建http请求</li>\n<li>支持Promise API</li>\n<li>客户端防止CSRF：每个请求带一个cookie拿到的key</li>\n<li>拦截请求和响应</li>\n<li>可取消请求</li>\n</ul>\n<p>兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容</p>\n<p>usage:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'GET'</span>,</span><br><span class=\"line\">  url: url,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(res)&#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(err)&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get请求</span></span><br><span class=\"line\">axios.get(url)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// post请求</span></span><br><span class=\"line\">axios.post（<span class=\"string\">`/user`</span>, &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'admin'</span>,</span><br><span class=\"line\">    pw: <span class=\"string\">'123456'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Last\"><a href=\"#Last\" class=\"headerlink\" title=\"Last\"></a>Last</h1><p>请求在本身上会有两种问题需要额外处理，处理方式就见仁见智</p>\n<ul>\n<li>请求串行</li>\n<li>请求并行</li>\n</ul>\n<p>在使用方面：<br>首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择<br>如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax<br>如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践（突然为yqb的mzone_fetch感到头疼😭）</p>\n","site":{"data":{}},"excerpt":"<p><code>Asynchronous Javascript And XML</code><br></p>","more":"<br>Ajax已经成为前后端数据通信不可或缺的技术之一，它的异步让前端数据获取向前迈了一大步，配合view-model静态更新视图带来更好的交互体验已经成为当前web发展的主流<p></p>\n<h1 id=\"最初的XHR\"><a href=\"#最初的XHR\" class=\"headerlink\" title=\"最初的XHR\"></a>最初的XHR</h1><p>所有浏览器都支持的XHR对象 <code>XMLHttpRequest</code><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest() <span class=\"comment\">//获取xhr对象</span></span><br></pre></td></tr></table></figure></p>\n<p>但是IE非要展示自己的存在感坚强的要发出自己的声音，甚至于不同版本的IE浏览器之间还有不同的声音🤣<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xhr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest) &#123; <span class=\"comment\">// Mozilla, Safari...</span></span><br><span class=\"line\">  xhr = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.ActiveXObject) &#123; <span class=\"comment\">// IE</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'Msxml2.XMLHTTP'</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'Microsoft.XMLHTTP'</span>)  <span class=\"comment\">// IE5、6</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有了上面这个xhr对象就可以发送真正的请求了<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GET</span></span><br><span class=\"line\">xhr.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">\"xxx.json\"</span>,<span class=\"literal\">true</span>)</span><br><span class=\"line\">xhr.send()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST</span></span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onReadyStateChange</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;readyState, status&#125; = xhr</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (readyState === <span class=\"number\">4</span> &amp;&amp; status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'success'</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'failed'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xhr.open(<span class=\"string\">'POST'</span>, <span class=\"string\">'/api'</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'application/x-www-form-urlencoded'</span>)</span><br><span class=\"line\">xhr.send(<span class=\"string\">'username=admin&amp;password=root'</span>)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"jQuery-ajax\"><a href=\"#jQuery-ajax\" class=\"headerlink\" title=\"jQuery ajax\"></a>jQuery ajax</h1><p>Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">   type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">   url: url,</span><br><span class=\"line\">   data: data,</span><br><span class=\"line\">   dataType: dataType,</span><br><span class=\"line\">   success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">   error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">$.<span class=\"keyword\">get</span>(url,function()&#123;&#125;)</span><br><span class=\"line\">$.post(url,body,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ul>\n<li>对原生XHR的封装</li>\n<li>针对MVC的编程</li>\n<li>完美的兼容性</li>\n<li>支持jsonp</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>不符合MVVM</li>\n<li>异步模型不够现代，不支持链式，代码可读性差</li>\n<li>整个Jquery太大，引入成本过高</li>\n</ul>\n<h1 id=\"fetch\"><a href=\"#fetch\" class=\"headerlink\" title=\"fetch\"></a>fetch</h1><p>fetch是es6后出现的全新API，完全是基于Promise的异步处理机制，使用起来会比起ajax更加简单</p>\n<p>使用fetch的代码会相比xhr具有条理性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url).then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"built_in\">console</span>.log(data))</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Oops, error\"</span>, e))</span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ul>\n<li>更加底层，提供的API丰富（request, response）</li>\n<li>语法简单，脱离了XHR，基于ES新的Promise设计</li>\n<li>看到以上，或许你会觉得fetch真的很美好，但是请了解，fetch本身是一个 low-level 的 API，它注定不会像你习惯的 $.ajax - 或是 axios 等库帮你封装各种各样的功能或实现</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><p>兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装常见的polyfill就有：es6-promise,babel-polyfill,fetch-ie8等</p>\n<blockquote>\n<p><a href=\"https://caniuse.com/#search=fetch\" target=\"_blank\" rel=\"noopener\">https://caniuse.com/#search=fetch</a></p>\n</blockquote>\n</li>\n<li><p>不支持jsonp，可以引入fetch-jsonp <code>npm install fetch-jsonp --save-dev</code><br><code>fetchJsonp(url, { timeout: 3000, jsonpCallback: &#39;callback&#39; }).then(function(response) { console.log(response.json()) }).catch(function(e) { console.log(e) })</code></p>\n</li>\n<li>没有拦截器，需要额外再封装一层或者fetch-interceptor</li>\n<li>默认不带cookie，需要添加配置 <code>fetch(url,{credentials: &#39;include&#39;})</code></li>\n<li>没有abort，不支持timeout超时处理,可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject</li>\n<li>无法获取progress状态: fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取参考javascript - Progress indicators for fetch? - Stack Overflow 2016 - the year of web streams</li>\n</ul>\n<h1 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h1><p>尤大在vue中强推的ajax库</p>\n<p>特点：</p>\n<ul>\n<li>支持node，创建http请求</li>\n<li>支持Promise API</li>\n<li>客户端防止CSRF：每个请求带一个cookie拿到的key</li>\n<li>拦截请求和响应</li>\n<li>可取消请求</li>\n</ul>\n<p>兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容</p>\n<p>usage:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'GET'</span>,</span><br><span class=\"line\">  url: url,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(res)&#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(err)&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get请求</span></span><br><span class=\"line\">axios.get(url)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// post请求</span></span><br><span class=\"line\">axios.post（<span class=\"string\">`/user`</span>, &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'admin'</span>,</span><br><span class=\"line\">    pw: <span class=\"string\">'123456'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Last\"><a href=\"#Last\" class=\"headerlink\" title=\"Last\"></a>Last</h1><p>请求在本身上会有两种问题需要额外处理，处理方式就见仁见智</p>\n<ul>\n<li>请求串行</li>\n<li>请求并行</li>\n</ul>\n<p>在使用方面：<br>首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择<br>如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax<br>如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践（突然为yqb的mzone_fetch感到头疼😭）</p>"},{"title":"算法复杂度","date":"2019-03-06T03:15:00.000Z","_content":"算法运行的时间复杂度和空间复杂度简单理解\n<!-- more -->\n*和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师*\n\n# 算法\n**算法**（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数\n\n说个粗浅的观点：在JS中定义的函数都是算法\n\n# 算法复杂度\n针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示\n\n- 时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)\n- 空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度\n\n*算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度*\n\n***所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度***\n\n# 时间复杂度\n一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用\"O\"来表示数量级，给出算法的时间复杂度\n\nT(n)=O(f(n))\n\n它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界\n- 时间复杂度就是函数中基本操作所执行的次数\n- 一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数\n- 忽略掉常数项\n- 关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数\n- 计算时间复杂度是估算随着n的增长函数执行次数的增长趋势\n- 递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数\n\n# 空间复杂度\n算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级\n\nS(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)\n\n递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)\n\n# 基础算法\n基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主\n\n## 冒泡排序\n核心代码：\n```js\n// arr\nfor (let i = 0; i < arr.length; i++) {\n  for (let j = 0; j < arr.length; j++) {\n    if (arr[j] > arr[j+1]) {\n      let temp = arr[j+1]\n      arr[j+1] = arr[j]\n      arr[j] = temp\n    }\n  }\n}\n```\n*此处只表述最基本的情况，不优化任何代码*\n\n该冒泡算法的时间复杂度：\n从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2\n所以该冒泡排序的时间复杂度为O(n^2)\n\n该冒泡算法的空间复杂度：\n从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)\n\n## 递归\n递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢\n\n*只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了*\n\n递归demo：\n```js\nlet n = 10\n\nfunction recursion() {\n  if (n > 1)\n    n-- && recursion()\n  else\n    return 'end of the recursive'\n}\n```\n上述是一个会循环执行10次就终止的简单递归\n该递归的时间复杂度：\n设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)\n该递归的空间复杂度：\n设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)\n\n## 二分法\n二分法本质依然是使用递归不断等分，代码如下：\n\n```js\n/**\n * @description: dichotomy\n * @param {Array} arr 入参数组\n * @param {any} val match\n * @param {Number} l 索引开始\n * @param {Number} r 索引结束\n*/\nfunction dichotomy(arr, val, l, r ){\n    let mid = Math.floor((l + r) / 2);\n    let midval = arr[mid]\n\n    if (l > r) return console.log('no match')\n\n    if (midval === val) return console.log('has match, index is ', mid)\n\n    midval > val\n      ? dichotomy(arr, val, l, mid - 1)\n      : dichotomy(arr, val, mid + 1, r)\n}\n\n// 测试\nconst arr = [1, 2, 3, 4, 5]\ndichotomy(arr, 3, 0, arr.length - 1)\n\n// optput:\n// has match, index is  2\n```\n算法的执行是不断等分数组，直到无法匹配要查找的数据\n设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4...\n.\n.\n.\n第 x 等分后长度为 n/2^x\n而算法执行的最差的情况就是每个等分的长度为1，1就是临界值\n所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数\n\n所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）\n每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数\n\n\n以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌\n\n\n**end**","source":"_posts/writeSomething/AlgorithmComplexity.md","raw":"---\ntitle: 算法复杂度\ntags:\n  - 算法\n  - 算法复杂度\ndate: 2019-03-06 11:15:00\ncategories: 算法\n---\n算法运行的时间复杂度和空间复杂度简单理解\n<!-- more -->\n*和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师*\n\n# 算法\n**算法**（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数\n\n说个粗浅的观点：在JS中定义的函数都是算法\n\n# 算法复杂度\n针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示\n\n- 时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)\n- 空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度\n\n*算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度*\n\n***所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度***\n\n# 时间复杂度\n一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用\"O\"来表示数量级，给出算法的时间复杂度\n\nT(n)=O(f(n))\n\n它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界\n- 时间复杂度就是函数中基本操作所执行的次数\n- 一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数\n- 忽略掉常数项\n- 关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数\n- 计算时间复杂度是估算随着n的增长函数执行次数的增长趋势\n- 递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数\n\n# 空间复杂度\n算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级\n\nS(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)\n\n递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)\n\n# 基础算法\n基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主\n\n## 冒泡排序\n核心代码：\n```js\n// arr\nfor (let i = 0; i < arr.length; i++) {\n  for (let j = 0; j < arr.length; j++) {\n    if (arr[j] > arr[j+1]) {\n      let temp = arr[j+1]\n      arr[j+1] = arr[j]\n      arr[j] = temp\n    }\n  }\n}\n```\n*此处只表述最基本的情况，不优化任何代码*\n\n该冒泡算法的时间复杂度：\n从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2\n所以该冒泡排序的时间复杂度为O(n^2)\n\n该冒泡算法的空间复杂度：\n从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)\n\n## 递归\n递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢\n\n*只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了*\n\n递归demo：\n```js\nlet n = 10\n\nfunction recursion() {\n  if (n > 1)\n    n-- && recursion()\n  else\n    return 'end of the recursive'\n}\n```\n上述是一个会循环执行10次就终止的简单递归\n该递归的时间复杂度：\n设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)\n该递归的空间复杂度：\n设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)\n\n## 二分法\n二分法本质依然是使用递归不断等分，代码如下：\n\n```js\n/**\n * @description: dichotomy\n * @param {Array} arr 入参数组\n * @param {any} val match\n * @param {Number} l 索引开始\n * @param {Number} r 索引结束\n*/\nfunction dichotomy(arr, val, l, r ){\n    let mid = Math.floor((l + r) / 2);\n    let midval = arr[mid]\n\n    if (l > r) return console.log('no match')\n\n    if (midval === val) return console.log('has match, index is ', mid)\n\n    midval > val\n      ? dichotomy(arr, val, l, mid - 1)\n      : dichotomy(arr, val, mid + 1, r)\n}\n\n// 测试\nconst arr = [1, 2, 3, 4, 5]\ndichotomy(arr, 3, 0, arr.length - 1)\n\n// optput:\n// has match, index is  2\n```\n算法的执行是不断等分数组，直到无法匹配要查找的数据\n设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4...\n.\n.\n.\n第 x 等分后长度为 n/2^x\n而算法执行的最差的情况就是每个等分的长度为1，1就是临界值\n所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数\n\n所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）\n每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数\n\n\n以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌\n\n\n**end**","slug":"writeSomething/AlgorithmComplexity","published":1,"updated":"2019-03-06T10:06:47.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwp000yax481xvxfmqs","content":"<p>算法运行的时间复杂度和空间复杂度简单理解<br><a id=\"more\"></a><br><em>和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师</em></p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p><strong>算法</strong>（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数</p>\n<p>说个粗浅的观点：在JS中定义的函数都是算法</p>\n<h1 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h1><p>针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示</p>\n<ul>\n<li>时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)</li>\n<li>空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度</li>\n</ul>\n<p><em>算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度</em></p>\n<p><strong><em>所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度</em></strong></p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用”O”来表示数量级，给出算法的时间复杂度</p>\n<p>T(n)=O(f(n))</p>\n<p>它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界</p>\n<ul>\n<li>时间复杂度就是函数中基本操作所执行的次数</li>\n<li>一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数</li>\n<li>忽略掉常数项</li>\n<li>关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数</li>\n<li>计算时间复杂度是估算随着n的增长函数执行次数的增长趋势</li>\n<li>递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数</li>\n</ul>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级</p>\n<p>S(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)</p>\n<p>递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)</p>\n<h1 id=\"基础算法\"><a href=\"#基础算法\" class=\"headerlink\" title=\"基础算法\"></a>基础算法</h1><p>基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>核心代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arr</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = arr[j+<span class=\"number\">1</span>]</span><br><span class=\"line\">      arr[j+<span class=\"number\">1</span>] = arr[j]</span><br><span class=\"line\">      arr[j] = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>此处只表述最基本的情况，不优化任何代码</em></p>\n<p>该冒泡算法的时间复杂度：<br>从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2<br>所以该冒泡排序的时间复杂度为O(n^2)</p>\n<p>该冒泡算法的空间复杂度：<br>从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)</p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢</p>\n<p><em>只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了</em></p>\n<p>递归demo：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursion</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    n-- &amp;&amp; recursion()</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'end of the recursive'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述是一个会循环执行10次就终止的简单递归<br>该递归的时间复杂度：<br>设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)<br>该递归的空间复杂度：<br>设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)</p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><p>二分法本质依然是使用递归不断等分，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @description: dichotomy</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; arr 入参数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; val match</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; l 索引开始</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; r 索引结束</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dichotomy</span>(<span class=\"params\">arr, val, l, r </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor((l + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> midval = arr[mid]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'no match'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (midval === val) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'has match, index is '</span>, mid)</span><br><span class=\"line\"></span><br><span class=\"line\">    midval &gt; val</span><br><span class=\"line\">      ? dichotomy(arr, val, l, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">      : dichotomy(arr, val, mid + <span class=\"number\">1</span>, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">dichotomy(arr, <span class=\"number\">3</span>, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// optput:</span></span><br><span class=\"line\"><span class=\"comment\">// has match, index is  2</span></span><br></pre></td></tr></table></figure>\n<p>算法的执行是不断等分数组，直到无法匹配要查找的数据<br>设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4…<br>.<br>.<br>.<br>第 x 等分后长度为 n/2^x<br>而算法执行的最差的情况就是每个等分的长度为1，1就是临界值<br>所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数</p>\n<p>所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）<br>每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数</p>\n<p>以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌</p>\n<p><strong>end</strong></p>\n","site":{"data":{}},"excerpt":"<p>算法运行的时间复杂度和空间复杂度简单理解<br></p>","more":"<br><em>和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师</em><p></p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p><strong>算法</strong>（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数</p>\n<p>说个粗浅的观点：在JS中定义的函数都是算法</p>\n<h1 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h1><p>针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示</p>\n<ul>\n<li>时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)</li>\n<li>空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度</li>\n</ul>\n<p><em>算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度</em></p>\n<p><strong><em>所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度</em></strong></p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用”O”来表示数量级，给出算法的时间复杂度</p>\n<p>T(n)=O(f(n))</p>\n<p>它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界</p>\n<ul>\n<li>时间复杂度就是函数中基本操作所执行的次数</li>\n<li>一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数</li>\n<li>忽略掉常数项</li>\n<li>关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数</li>\n<li>计算时间复杂度是估算随着n的增长函数执行次数的增长趋势</li>\n<li>递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数</li>\n</ul>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级</p>\n<p>S(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)</p>\n<p>递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)</p>\n<h1 id=\"基础算法\"><a href=\"#基础算法\" class=\"headerlink\" title=\"基础算法\"></a>基础算法</h1><p>基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>核心代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arr</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = arr[j+<span class=\"number\">1</span>]</span><br><span class=\"line\">      arr[j+<span class=\"number\">1</span>] = arr[j]</span><br><span class=\"line\">      arr[j] = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>此处只表述最基本的情况，不优化任何代码</em></p>\n<p>该冒泡算法的时间复杂度：<br>从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2<br>所以该冒泡排序的时间复杂度为O(n^2)</p>\n<p>该冒泡算法的空间复杂度：<br>从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)</p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢</p>\n<p><em>只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了</em></p>\n<p>递归demo：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursion</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    n-- &amp;&amp; recursion()</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'end of the recursive'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述是一个会循环执行10次就终止的简单递归<br>该递归的时间复杂度：<br>设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)<br>该递归的空间复杂度：<br>设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)</p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><p>二分法本质依然是使用递归不断等分，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @description: dichotomy</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; arr 入参数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; val match</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; l 索引开始</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; r 索引结束</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dichotomy</span>(<span class=\"params\">arr, val, l, r </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor((l + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> midval = arr[mid]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'no match'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (midval === val) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'has match, index is '</span>, mid)</span><br><span class=\"line\"></span><br><span class=\"line\">    midval &gt; val</span><br><span class=\"line\">      ? dichotomy(arr, val, l, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">      : dichotomy(arr, val, mid + <span class=\"number\">1</span>, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">dichotomy(arr, <span class=\"number\">3</span>, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// optput:</span></span><br><span class=\"line\"><span class=\"comment\">// has match, index is  2</span></span><br></pre></td></tr></table></figure>\n<p>算法的执行是不断等分数组，直到无法匹配要查找的数据<br>设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4…<br>.<br>.<br>.<br>第 x 等分后长度为 n/2^x<br>而算法执行的最差的情况就是每个等分的长度为1，1就是临界值<br>所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数</p>\n<p>所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）<br>每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数</p>\n<p>以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌</p>\n<p><strong>end</strong></p>"},{"title":"使用ts封装一个fetch请求库---拦截器篇","date":"2019-04-13T03:34:00.000Z","_content":"\n封装自己的fetch请求库---拦截器篇\n<!-- more -->\n关于ajax有非常多的封装库，最近两天自己简单封装了一下，好好体验其中三昧，内容不算太少，分为三篇说完。\n本篇博客的介绍内容是封装基于原生fetch的一个拦截器（interceptor）。\n*请求库封装的源码在[https://github.com/rollawaypoint/obtain-fetch](https://github.com/rollawaypoint/obtain-fetch)*\n\n# 初始化请求基类\n首先构造一个包含请求方法的基类，这样做方便随时向外暴露自己新增的接口\n```ts\nclass Obtain {\n  constructor() {\n  }\n  curl(url: string, options: any = {}): Promise<any> {\n    return fetch(url, options)\n  }\n}\n\nconst obtain = new Obtain()\nexport default obtain.curl\n```\n*这里使用原生的fetch，关于兼容性封装xmr对象或者针对多端请求后面可以自行封装*\n基类Obtain拥有一个curl方法用来向外暴露发送异步请求\n\n# 构造拦截器请求队列\n*参考axios*\n- 拦截器分为请求拦截器和响应拦截器\n- 在请求拦截器和响应拦截器之间我们将真正的请求发出\n- 请求拦截器的队列中对请求数据进行处理依次向下一个请求拦截器中传递直到触发真正请求\n- 真正的请求触发后需要将返回值作为当前的上下文传到接下来的响应拦截器的队列中\n- 依次执行响应拦截器队列中的回调对请求返回值进行处理\n- 以一条promise链将所有的中间处理过程连接起来\n\n# 构造拦截器类\nInterceptor类拥有一个存储不同拦截器的队列 `handler`\n构造 use 方法将用户定义的拦截器push进拦截器队列\n构造 reducer 方法对拦截器队列中的拦截器函数进行批量处理\n\n```ts\nclass Interceptor {\n\tpublic handler: Array<Array<any>>\n\n\tconstructor() {\n\t\tthis.handler = []\n\t}\n\n\tpublic use(success: Function, failed: Function): void {\n\t\tthis.handler.push([success, failed])\n\t}\n\n\tpublic reducer(fn: Function): void {\n\t\tthis.handler.forEach(handlerList => fn(handlerList))\n\t}\n}\n\nexport default Interceptor\n```\n\n# 构造Fetch类\n接受上面定义的拦截器进行初始化\n自身拥有 curl 方法对外暴露进行请求的派发，内部使用调用fetch\n```ts\ninterface TypeInterceptor {\n  request: Interceptor,\n  response: Interceptor\n}\nclass Fetch {\n  public interceptor: TypeInterceptor\n\n  constructor() {\n    this.interceptor = {\n      request: new Interceptor(),\n      response: new Interceptor()\n    }\n  }\n  fetch(url, options) {\n    return () => fetch(url, options)\n  }\n\n  curl(url: string, options: any = {}): Promise<any> {\n  }\n}\n\nexport default Fetch\n```\n\n# 构造curl方法\n构造curl方法对拦截器队列进行初始化进行链式调用\n```js\nfunction curl(url: string, options: any = {}): Promise<any> {\n  options.method = options.method || 'GET'\n\n  // 初始化promise\n  let promise = Promise.resolve(options)\n\n  // 构造promise调用链\n  // 请求派发放在中间\n  const chain: Array<Array<Function|any>> = [[this.fetch(url, options), undefined]]\n\n  // 将收集到的请求拦截器依次放在promise调用链中请求派发之前\n  this.interceptor.request.reducer(handlerList => chain.unshift(handlerList))\n  // 将收集到的响应拦截器依次放在promise调用链中请求派发之后\n  this.interceptor.response.reducer(handlerList => chain.push(handlerList))\n\n  // excute chain inteceptor\n  while (chain.length) {\n    promise = promise.then(...chain.shift())\n  }\n\n  return promise\n}\n```\n至此拦截器相关封装已经极为简单的完成了\n\n# 对外暴露curl以及封装use方法便于使用\n```ts\nconst obtain = new Fetch()\n\n// 使用简单的拦截器进行接口response的处理\nobtain.interceptor.response.use(\n  res => res.json(),\n  err => ({ err, msg: 'oops, something wrong...'})\n)\n\n// bind工具 对导出的curl上下文进行绑定\nconst bind = (fn, context) => function() {\n  return fn.apply(context, Array.from(arguments))\n}\n\nconst curl: any = bind(Fetch.prototype.curl, obtain)\n\n// 封装use方法 将fetch实例传递给外部传入的回调\ncurl.use = function(plugin: Function) {\n  if (typeof plugin !== 'function') {\n    return console.error('Error: plugin must be a function!')\n  }\n\n  plugin(obtain)\n}\n\nexport default curl\n```\n\n# 使用\n```js\n// 拦截器\nobtain.use(function(http) {\n  http.interceptor.request.use(option => {\n    console.log('in to interceptor ****************', option)\n    return option\n  }, null)\n  http.interceptor.response.use(option => {\n    console.log('after interceptor ****************')\n    return option\n  }, null)\n})\n\n// 并发\nobtain.use(function(http) {\n  http.concurrency = 10\n})\n\nobtain('http://localhost:4000/banner').then(async res => {\n  console.log(res, 'result')\n})\n```\n至此fetch封装拦截器完成\n","source":"_posts/writeSomething/Fetch_1.md","raw":"---\ntitle: 使用ts封装一个fetch请求库---拦截器篇\ntags:\n  - fetch\n  - interceptor\ndate: 2019-04-13 11:34:00\ncategories: 封装\n---\n\n封装自己的fetch请求库---拦截器篇\n<!-- more -->\n关于ajax有非常多的封装库，最近两天自己简单封装了一下，好好体验其中三昧，内容不算太少，分为三篇说完。\n本篇博客的介绍内容是封装基于原生fetch的一个拦截器（interceptor）。\n*请求库封装的源码在[https://github.com/rollawaypoint/obtain-fetch](https://github.com/rollawaypoint/obtain-fetch)*\n\n# 初始化请求基类\n首先构造一个包含请求方法的基类，这样做方便随时向外暴露自己新增的接口\n```ts\nclass Obtain {\n  constructor() {\n  }\n  curl(url: string, options: any = {}): Promise<any> {\n    return fetch(url, options)\n  }\n}\n\nconst obtain = new Obtain()\nexport default obtain.curl\n```\n*这里使用原生的fetch，关于兼容性封装xmr对象或者针对多端请求后面可以自行封装*\n基类Obtain拥有一个curl方法用来向外暴露发送异步请求\n\n# 构造拦截器请求队列\n*参考axios*\n- 拦截器分为请求拦截器和响应拦截器\n- 在请求拦截器和响应拦截器之间我们将真正的请求发出\n- 请求拦截器的队列中对请求数据进行处理依次向下一个请求拦截器中传递直到触发真正请求\n- 真正的请求触发后需要将返回值作为当前的上下文传到接下来的响应拦截器的队列中\n- 依次执行响应拦截器队列中的回调对请求返回值进行处理\n- 以一条promise链将所有的中间处理过程连接起来\n\n# 构造拦截器类\nInterceptor类拥有一个存储不同拦截器的队列 `handler`\n构造 use 方法将用户定义的拦截器push进拦截器队列\n构造 reducer 方法对拦截器队列中的拦截器函数进行批量处理\n\n```ts\nclass Interceptor {\n\tpublic handler: Array<Array<any>>\n\n\tconstructor() {\n\t\tthis.handler = []\n\t}\n\n\tpublic use(success: Function, failed: Function): void {\n\t\tthis.handler.push([success, failed])\n\t}\n\n\tpublic reducer(fn: Function): void {\n\t\tthis.handler.forEach(handlerList => fn(handlerList))\n\t}\n}\n\nexport default Interceptor\n```\n\n# 构造Fetch类\n接受上面定义的拦截器进行初始化\n自身拥有 curl 方法对外暴露进行请求的派发，内部使用调用fetch\n```ts\ninterface TypeInterceptor {\n  request: Interceptor,\n  response: Interceptor\n}\nclass Fetch {\n  public interceptor: TypeInterceptor\n\n  constructor() {\n    this.interceptor = {\n      request: new Interceptor(),\n      response: new Interceptor()\n    }\n  }\n  fetch(url, options) {\n    return () => fetch(url, options)\n  }\n\n  curl(url: string, options: any = {}): Promise<any> {\n  }\n}\n\nexport default Fetch\n```\n\n# 构造curl方法\n构造curl方法对拦截器队列进行初始化进行链式调用\n```js\nfunction curl(url: string, options: any = {}): Promise<any> {\n  options.method = options.method || 'GET'\n\n  // 初始化promise\n  let promise = Promise.resolve(options)\n\n  // 构造promise调用链\n  // 请求派发放在中间\n  const chain: Array<Array<Function|any>> = [[this.fetch(url, options), undefined]]\n\n  // 将收集到的请求拦截器依次放在promise调用链中请求派发之前\n  this.interceptor.request.reducer(handlerList => chain.unshift(handlerList))\n  // 将收集到的响应拦截器依次放在promise调用链中请求派发之后\n  this.interceptor.response.reducer(handlerList => chain.push(handlerList))\n\n  // excute chain inteceptor\n  while (chain.length) {\n    promise = promise.then(...chain.shift())\n  }\n\n  return promise\n}\n```\n至此拦截器相关封装已经极为简单的完成了\n\n# 对外暴露curl以及封装use方法便于使用\n```ts\nconst obtain = new Fetch()\n\n// 使用简单的拦截器进行接口response的处理\nobtain.interceptor.response.use(\n  res => res.json(),\n  err => ({ err, msg: 'oops, something wrong...'})\n)\n\n// bind工具 对导出的curl上下文进行绑定\nconst bind = (fn, context) => function() {\n  return fn.apply(context, Array.from(arguments))\n}\n\nconst curl: any = bind(Fetch.prototype.curl, obtain)\n\n// 封装use方法 将fetch实例传递给外部传入的回调\ncurl.use = function(plugin: Function) {\n  if (typeof plugin !== 'function') {\n    return console.error('Error: plugin must be a function!')\n  }\n\n  plugin(obtain)\n}\n\nexport default curl\n```\n\n# 使用\n```js\n// 拦截器\nobtain.use(function(http) {\n  http.interceptor.request.use(option => {\n    console.log('in to interceptor ****************', option)\n    return option\n  }, null)\n  http.interceptor.response.use(option => {\n    console.log('after interceptor ****************')\n    return option\n  }, null)\n})\n\n// 并发\nobtain.use(function(http) {\n  http.concurrency = 10\n})\n\nobtain('http://localhost:4000/banner').then(async res => {\n  console.log(res, 'result')\n})\n```\n至此fetch封装拦截器完成\n","slug":"writeSomething/Fetch_1","published":1,"updated":"2019-04-19T02:30:53.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwq0011ax48gv9566o9","content":"<p>封装自己的fetch请求库—拦截器篇<br><a id=\"more\"></a><br>关于ajax有非常多的封装库，最近两天自己简单封装了一下，好好体验其中三昧，内容不算太少，分为三篇说完。<br>本篇博客的介绍内容是封装基于原生fetch的一个拦截器（interceptor）。<br><em>请求库封装的源码在<a href=\"https://github.com/rollawaypoint/obtain-fetch\" target=\"_blank\" rel=\"noopener\">https://github.com/rollawaypoint/obtain-fetch</a></em></p>\n<h1 id=\"初始化请求基类\"><a href=\"#初始化请求基类\" class=\"headerlink\" title=\"初始化请求基类\"></a>初始化请求基类</h1><p>首先构造一个包含请求方法的基类，这样做方便随时向外暴露自己新增的接口<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Obtain &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  curl(url: <span class=\"built_in\">string</span>, options: <span class=\"built_in\">any</span> = &#123;&#125;): <span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">any</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(url, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obtain = <span class=\"keyword\">new</span> Obtain()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> obtain.curl</span><br></pre></td></tr></table></figure></p>\n<p><em>这里使用原生的fetch，关于兼容性封装xmr对象或者针对多端请求后面可以自行封装</em><br>基类Obtain拥有一个curl方法用来向外暴露发送异步请求</p>\n<h1 id=\"构造拦截器请求队列\"><a href=\"#构造拦截器请求队列\" class=\"headerlink\" title=\"构造拦截器请求队列\"></a>构造拦截器请求队列</h1><p><em>参考axios</em></p>\n<ul>\n<li>拦截器分为请求拦截器和响应拦截器</li>\n<li>在请求拦截器和响应拦截器之间我们将真正的请求发出</li>\n<li>请求拦截器的队列中对请求数据进行处理依次向下一个请求拦截器中传递直到触发真正请求</li>\n<li>真正的请求触发后需要将返回值作为当前的上下文传到接下来的响应拦截器的队列中</li>\n<li>依次执行响应拦截器队列中的回调对请求返回值进行处理</li>\n<li>以一条promise链将所有的中间处理过程连接起来</li>\n</ul>\n<h1 id=\"构造拦截器类\"><a href=\"#构造拦截器类\" class=\"headerlink\" title=\"构造拦截器类\"></a>构造拦截器类</h1><p>Interceptor类拥有一个存储不同拦截器的队列 <code>handler</code><br>构造 use 方法将用户定义的拦截器push进拦截器队列<br>构造 reducer 方法对拦截器队列中的拦截器函数进行批量处理</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Interceptor &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> handler: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">any</span>&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.handler = []</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> use(success: <span class=\"built_in\">Function</span>, failed: <span class=\"built_in\">Function</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.handler.push([success, failed])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> reducer(fn: <span class=\"built_in\">Function</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.handler.forEach(<span class=\"function\"><span class=\"params\">handlerList</span> =&gt;</span> fn(handlerList))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Interceptor</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造Fetch类\"><a href=\"#构造Fetch类\" class=\"headerlink\" title=\"构造Fetch类\"></a>构造Fetch类</h1><p>接受上面定义的拦截器进行初始化<br>自身拥有 curl 方法对外暴露进行请求的派发，内部使用调用fetch<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> TypeInterceptor &#123;</span><br><span class=\"line\">  request: Interceptor,</span><br><span class=\"line\">  response: Interceptor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Fetch &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> interceptor: TypeInterceptor</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.interceptor = &#123;</span><br><span class=\"line\">      request: <span class=\"keyword\">new</span> Interceptor(),</span><br><span class=\"line\">      response: <span class=\"keyword\">new</span> Interceptor()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fetch(url, options) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fetch(url, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  curl(url: <span class=\"built_in\">string</span>, options: <span class=\"built_in\">any</span> = &#123;&#125;): <span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">any</span>&gt; &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Fetch</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"构造curl方法\"><a href=\"#构造curl方法\" class=\"headerlink\" title=\"构造curl方法\"></a>构造curl方法</h1><p>构造curl方法对拦截器队列进行初始化进行链式调用<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curl</span>(<span class=\"params\">url: string, options: any = &#123;&#125;</span>): <span class=\"title\">Promise</span>&lt;<span class=\"title\">any</span>&gt; </span>&#123;</span><br><span class=\"line\">  options.method = options.method || <span class=\"string\">'GET'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化promise</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise = <span class=\"built_in\">Promise</span>.resolve(options)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 构造promise调用链</span></span><br><span class=\"line\">  <span class=\"comment\">// 请求派发放在中间</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chain: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">Function</span>|any&gt;&gt; = [[<span class=\"keyword\">this</span>.fetch(url, options), <span class=\"literal\">undefined</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将收集到的请求拦截器依次放在promise调用链中请求派发之前</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.interceptor.request.reducer(<span class=\"function\"><span class=\"params\">handlerList</span> =&gt;</span> chain.unshift(handlerList))</span><br><span class=\"line\">  <span class=\"comment\">// 将收集到的响应拦截器依次放在promise调用链中请求派发之后</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.interceptor.response.reducer(<span class=\"function\"><span class=\"params\">handlerList</span> =&gt;</span> chain.push(handlerList))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// excute chain inteceptor</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (chain.length) &#123;</span><br><span class=\"line\">    promise = promise.then(...chain.shift())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此拦截器相关封装已经极为简单的完成了</p>\n<h1 id=\"对外暴露curl以及封装use方法便于使用\"><a href=\"#对外暴露curl以及封装use方法便于使用\" class=\"headerlink\" title=\"对外暴露curl以及封装use方法便于使用\"></a>对外暴露curl以及封装use方法便于使用</h1><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obtain = <span class=\"keyword\">new</span> Fetch()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用简单的拦截器进行接口response的处理</span></span><br><span class=\"line\">obtain.interceptor.response.use(</span><br><span class=\"line\">  res =&gt; res.json(),</span><br><span class=\"line\">  err =&gt; (&#123; err, msg: <span class=\"string\">'oops, something wrong...'</span>&#125;)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bind工具 对导出的curl上下文进行绑定</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bind = <span class=\"function\">(<span class=\"params\">fn, context</span>) =&gt;</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn.apply(context, <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> curl: <span class=\"built_in\">any</span> = bind(Fetch.prototype.curl, obtain)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 封装use方法 将fetch实例传递给外部传入的回调</span></span><br><span class=\"line\">curl.use = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin: <span class=\"built_in\">Function</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(<span class=\"string\">'Error: plugin must be a function!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  plugin(obtain)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> curl</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拦截器</span></span><br><span class=\"line\">obtain.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">http</span>) </span>&#123;</span><br><span class=\"line\">  http.interceptor.request.use(<span class=\"function\"><span class=\"params\">option</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'in to interceptor ****************'</span>, option)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> option</span><br><span class=\"line\">  &#125;, <span class=\"literal\">null</span>)</span><br><span class=\"line\">  http.interceptor.response.use(<span class=\"function\"><span class=\"params\">option</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'after interceptor ****************'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> option</span><br><span class=\"line\">  &#125;, <span class=\"literal\">null</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并发</span></span><br><span class=\"line\">obtain.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">http</span>) </span>&#123;</span><br><span class=\"line\">  http.concurrency = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obtain(<span class=\"string\">'http://localhost:4000/banner'</span>).then(<span class=\"keyword\">async</span> res =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res, <span class=\"string\">'result'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>至此fetch封装拦截器完成</p>\n","site":{"data":{}},"excerpt":"<p>封装自己的fetch请求库—拦截器篇<br></p>","more":"<br>关于ajax有非常多的封装库，最近两天自己简单封装了一下，好好体验其中三昧，内容不算太少，分为三篇说完。<br>本篇博客的介绍内容是封装基于原生fetch的一个拦截器（interceptor）。<br><em>请求库封装的源码在<a href=\"https://github.com/rollawaypoint/obtain-fetch\" target=\"_blank\" rel=\"noopener\">https://github.com/rollawaypoint/obtain-fetch</a></em><p></p>\n<h1 id=\"初始化请求基类\"><a href=\"#初始化请求基类\" class=\"headerlink\" title=\"初始化请求基类\"></a>初始化请求基类</h1><p>首先构造一个包含请求方法的基类，这样做方便随时向外暴露自己新增的接口<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Obtain &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  curl(url: <span class=\"built_in\">string</span>, options: <span class=\"built_in\">any</span> = &#123;&#125;): <span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">any</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(url, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obtain = <span class=\"keyword\">new</span> Obtain()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> obtain.curl</span><br></pre></td></tr></table></figure></p>\n<p><em>这里使用原生的fetch，关于兼容性封装xmr对象或者针对多端请求后面可以自行封装</em><br>基类Obtain拥有一个curl方法用来向外暴露发送异步请求</p>\n<h1 id=\"构造拦截器请求队列\"><a href=\"#构造拦截器请求队列\" class=\"headerlink\" title=\"构造拦截器请求队列\"></a>构造拦截器请求队列</h1><p><em>参考axios</em></p>\n<ul>\n<li>拦截器分为请求拦截器和响应拦截器</li>\n<li>在请求拦截器和响应拦截器之间我们将真正的请求发出</li>\n<li>请求拦截器的队列中对请求数据进行处理依次向下一个请求拦截器中传递直到触发真正请求</li>\n<li>真正的请求触发后需要将返回值作为当前的上下文传到接下来的响应拦截器的队列中</li>\n<li>依次执行响应拦截器队列中的回调对请求返回值进行处理</li>\n<li>以一条promise链将所有的中间处理过程连接起来</li>\n</ul>\n<h1 id=\"构造拦截器类\"><a href=\"#构造拦截器类\" class=\"headerlink\" title=\"构造拦截器类\"></a>构造拦截器类</h1><p>Interceptor类拥有一个存储不同拦截器的队列 <code>handler</code><br>构造 use 方法将用户定义的拦截器push进拦截器队列<br>构造 reducer 方法对拦截器队列中的拦截器函数进行批量处理</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Interceptor &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> handler: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">any</span>&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.handler = []</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> use(success: <span class=\"built_in\">Function</span>, failed: <span class=\"built_in\">Function</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.handler.push([success, failed])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> reducer(fn: <span class=\"built_in\">Function</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.handler.forEach(<span class=\"function\"><span class=\"params\">handlerList</span> =&gt;</span> fn(handlerList))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Interceptor</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造Fetch类\"><a href=\"#构造Fetch类\" class=\"headerlink\" title=\"构造Fetch类\"></a>构造Fetch类</h1><p>接受上面定义的拦截器进行初始化<br>自身拥有 curl 方法对外暴露进行请求的派发，内部使用调用fetch<br><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> TypeInterceptor &#123;</span><br><span class=\"line\">  request: Interceptor,</span><br><span class=\"line\">  response: Interceptor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Fetch &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> interceptor: TypeInterceptor</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.interceptor = &#123;</span><br><span class=\"line\">      request: <span class=\"keyword\">new</span> Interceptor(),</span><br><span class=\"line\">      response: <span class=\"keyword\">new</span> Interceptor()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fetch(url, options) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fetch(url, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  curl(url: <span class=\"built_in\">string</span>, options: <span class=\"built_in\">any</span> = &#123;&#125;): <span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">any</span>&gt; &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Fetch</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"构造curl方法\"><a href=\"#构造curl方法\" class=\"headerlink\" title=\"构造curl方法\"></a>构造curl方法</h1><p>构造curl方法对拦截器队列进行初始化进行链式调用<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curl</span>(<span class=\"params\">url: string, options: any = &#123;&#125;</span>): <span class=\"title\">Promise</span>&lt;<span class=\"title\">any</span>&gt; </span>&#123;</span><br><span class=\"line\">  options.method = options.method || <span class=\"string\">'GET'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化promise</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise = <span class=\"built_in\">Promise</span>.resolve(options)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 构造promise调用链</span></span><br><span class=\"line\">  <span class=\"comment\">// 请求派发放在中间</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chain: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">Function</span>|any&gt;&gt; = [[<span class=\"keyword\">this</span>.fetch(url, options), <span class=\"literal\">undefined</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将收集到的请求拦截器依次放在promise调用链中请求派发之前</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.interceptor.request.reducer(<span class=\"function\"><span class=\"params\">handlerList</span> =&gt;</span> chain.unshift(handlerList))</span><br><span class=\"line\">  <span class=\"comment\">// 将收集到的响应拦截器依次放在promise调用链中请求派发之后</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.interceptor.response.reducer(<span class=\"function\"><span class=\"params\">handlerList</span> =&gt;</span> chain.push(handlerList))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// excute chain inteceptor</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (chain.length) &#123;</span><br><span class=\"line\">    promise = promise.then(...chain.shift())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此拦截器相关封装已经极为简单的完成了</p>\n<h1 id=\"对外暴露curl以及封装use方法便于使用\"><a href=\"#对外暴露curl以及封装use方法便于使用\" class=\"headerlink\" title=\"对外暴露curl以及封装use方法便于使用\"></a>对外暴露curl以及封装use方法便于使用</h1><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obtain = <span class=\"keyword\">new</span> Fetch()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用简单的拦截器进行接口response的处理</span></span><br><span class=\"line\">obtain.interceptor.response.use(</span><br><span class=\"line\">  res =&gt; res.json(),</span><br><span class=\"line\">  err =&gt; (&#123; err, msg: <span class=\"string\">'oops, something wrong...'</span>&#125;)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bind工具 对导出的curl上下文进行绑定</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bind = <span class=\"function\">(<span class=\"params\">fn, context</span>) =&gt;</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn.apply(context, <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> curl: <span class=\"built_in\">any</span> = bind(Fetch.prototype.curl, obtain)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 封装use方法 将fetch实例传递给外部传入的回调</span></span><br><span class=\"line\">curl.use = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin: <span class=\"built_in\">Function</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(<span class=\"string\">'Error: plugin must be a function!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  plugin(obtain)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> curl</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拦截器</span></span><br><span class=\"line\">obtain.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">http</span>) </span>&#123;</span><br><span class=\"line\">  http.interceptor.request.use(<span class=\"function\"><span class=\"params\">option</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'in to interceptor ****************'</span>, option)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> option</span><br><span class=\"line\">  &#125;, <span class=\"literal\">null</span>)</span><br><span class=\"line\">  http.interceptor.response.use(<span class=\"function\"><span class=\"params\">option</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'after interceptor ****************'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> option</span><br><span class=\"line\">  &#125;, <span class=\"literal\">null</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并发</span></span><br><span class=\"line\">obtain.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">http</span>) </span>&#123;</span><br><span class=\"line\">  http.concurrency = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obtain(<span class=\"string\">'http://localhost:4000/banner'</span>).then(<span class=\"keyword\">async</span> res =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res, <span class=\"string\">'result'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>至此fetch封装拦截器完成</p>"},{"title":"functional event emitter","date":"2019-03-22T08:35:00.000Z","_content":"\n用函数式编程简单封装一个 `event emitter`\n<!--more-->\n\n函数式编程：函数式编程（英语：functional programming），又称泛函编程，是一种编程范式，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象\n*起源于范畴论*\n\n# 从函数柯里化说起\n*从低阶函数变为高阶函数的过程*\n从调用上来看，就是将 `f(a, b, c)` 变为支持 `f(a)(b)(c)`、`f(a, b)(c)`、`f(a)(b, c)`的形式\n如最基本的 `(a, b) => a + b` 可以柯里化为：\n```js\nconst f = a => b => a + b\n\n// output:\nf(4)(6) // 10\n```\n\n这表明函数柯里化是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。从某种意义上来讲，这是一种对参数的缓存，是一种非常高效的编写函数的方法\n\n具体的细节不赘述主要内容是封装这个event emitter，*很多时候js相关的类函数式操作（reduce、compose）被当做了函数式编程*, 有机会单独深入了解函数式编程Functor、Monad、Applicative后来仔细说说\n\n# 传统封装event emitter\n首先定义一个拥有着基本的订阅和发布的event类\n```js\nclass Event {\n  addEventListener () {\n    // to do\n  }\n  dispatch () {\n    // to do\n  }\n}\n```\n\n这个类要有一个存储订阅者的地方，同时发布的时候要将消息推送给所有订阅该消息的订阅者\n```js\nclass Event {\n  constructor (eventMap = new Map()) {\n    // 使用map存储订阅者\n    this.eventMap = eventMap\n  }\n  addEventListener (event, handler) {\n    // to do\n  }\n  dispatch (event) {\n    // 发布\n    // 该消息的订阅队列不存在\n    if (!this.eventMap.has(event)) return\n\n    // 推送消息\n    this.eventMap.get(event).forEach(fn => fn())\n  }\n}\n```\n\n下面添加event的订阅方法，支持传入订阅消息名和对应的回调\n```js\nclass Event {\n  constructor (eventMap = new Map()) {\n    // 使用map存储订阅者\n    this.eventMap = eventMap\n  }\n  addEventListener (event, handler) {\n    this.eventMap.has(event)\n      // 判断当前订阅的消息队列中是否已经存在\n      ? this.eventMap.set(event, this.eventMap.get(event).concat([ handler ]))\n      : this.eventMap.set(event, [ handler ])\n  }\n  dispatch (event) {\n    // 发布\n    // 该消息的订阅队列不存在\n    if (!this.eventMap.has(event)) return\n\n    // 推送消息\n    this.eventMap.get(event).forEach(fn => fn())\n  }\n}\n```\n以上基本的event emitter调度中心已经封装完成了正常使用应该是没有问题的\n测试：\n```js\nconst e = new Event()\n\ne.addEventListener('e1', (e) => {\n  console.log('handle e1 first')\n})\n\ne.addEventListener('e1', (e) => {\n  console.log('handle e1 second', e)\n})\n\ne.dispatch('e1')\n\n// output: \n// handle e1 first\n// handle e1 second\n```\n那么如何使用函数式编程的思想将上面的event emitter封装起来呢？\n\n# functional event emitter\n#### functional addEventListener\n如传统封装方法的一致，addEventListener内部需要分别使用消息类型event，消息回调handler以及存储中心eventMap，用柯里化的思想分别将这三个传入新封装的函数，新函数即为：\n```js\nconst addEventListener = event\n  => handler\n    => eventMap\n      => eventMap.has(event)\n        // 判断逻辑不变\n        ? new Map(eventMap).set(event, eventMap.get(event).concat([handler]))\n        : new Map(eventMap).set(event, [handler])\n```\n\n#### functional dispatch\n同样，观察上面封装的dispatch方法，我们需要消息类型event和存储中心eventMap两个数据，下面也分为两个参数分别传入，改写的dispatch方法如下：\n```js\nconst dispatch = event\n  => eventMap\n    => eventMap.has(event) && eventMap.get(event).forEach(fn => fn())\n```\nevent emitter类两个核心的函数已经改写完毕了，可是我们观察上面的addEventListener方法，可以看到上面的封装分三步将所需要的参数分别传入，调用即为：`addEventListener('e2')(() => log('hey'))`, 此时的返回值是一个需要接受存储中心 `eventMap` 为参数的一个新函数，这里需要注意\n我们要对所有的addEventListener进行整合最终传入同一个map对象作为唯一存储对象，下面我们要写一个compose函数\n\n#### functional compose\n这个compose需要接受函数的集合（函数即为`addEventListener('e2')(() => log('hey'))`的返回值的函数）作为参数，使用数组最强大的reduce方法对传入的函数进行批处理调用即可，如果大家熟悉redux里面的compose函数，其实都是一样的，都是处理一组函数集合的集中调用（类似的还有之前的一篇博客 [十行代码实现Koa2洋葱模型](https://rollawaypoint.github.io/2019/02/22/writeSomething/koa2OnionModel/#%E4%B8%89%E6%AD%A5%E5%AE%8C%E6%88%90%E5%B0%81%E8%A3%85) 中的compose函数）， 代码如下：\n```js\nconst compose = (...fns)\n  => fns.reduceRight((f, g)\n    => (...args)\n      => f(g(...args)))\n```\n至此，所有的封装基本已经完成了，使用函数式的封装，保护函数状态的单一性，下面进行测试：\n\n\n```js\nconst addEventListeners = compose(\n  addEventListener('e2')(() => log('hey')),\n  addEventListener('e2')(() => log('hi'))\n)\n\nconst m = addEventListeners(new Map())\ndispatch('e2')(m)\n\n// output:\n// hey\n// hi\n\n```\n\n**end**\n","source":"_posts/writeSomething/FunctionalEventEmitter.md","raw":"---\ntitle: functional event emitter\ntags:\n  - 函数式编程\n  - event emitter\ndate: 2019-03-22 16:35:00\ncategories: 算法\n---\n\n用函数式编程简单封装一个 `event emitter`\n<!--more-->\n\n函数式编程：函数式编程（英语：functional programming），又称泛函编程，是一种编程范式，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象\n*起源于范畴论*\n\n# 从函数柯里化说起\n*从低阶函数变为高阶函数的过程*\n从调用上来看，就是将 `f(a, b, c)` 变为支持 `f(a)(b)(c)`、`f(a, b)(c)`、`f(a)(b, c)`的形式\n如最基本的 `(a, b) => a + b` 可以柯里化为：\n```js\nconst f = a => b => a + b\n\n// output:\nf(4)(6) // 10\n```\n\n这表明函数柯里化是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。从某种意义上来讲，这是一种对参数的缓存，是一种非常高效的编写函数的方法\n\n具体的细节不赘述主要内容是封装这个event emitter，*很多时候js相关的类函数式操作（reduce、compose）被当做了函数式编程*, 有机会单独深入了解函数式编程Functor、Monad、Applicative后来仔细说说\n\n# 传统封装event emitter\n首先定义一个拥有着基本的订阅和发布的event类\n```js\nclass Event {\n  addEventListener () {\n    // to do\n  }\n  dispatch () {\n    // to do\n  }\n}\n```\n\n这个类要有一个存储订阅者的地方，同时发布的时候要将消息推送给所有订阅该消息的订阅者\n```js\nclass Event {\n  constructor (eventMap = new Map()) {\n    // 使用map存储订阅者\n    this.eventMap = eventMap\n  }\n  addEventListener (event, handler) {\n    // to do\n  }\n  dispatch (event) {\n    // 发布\n    // 该消息的订阅队列不存在\n    if (!this.eventMap.has(event)) return\n\n    // 推送消息\n    this.eventMap.get(event).forEach(fn => fn())\n  }\n}\n```\n\n下面添加event的订阅方法，支持传入订阅消息名和对应的回调\n```js\nclass Event {\n  constructor (eventMap = new Map()) {\n    // 使用map存储订阅者\n    this.eventMap = eventMap\n  }\n  addEventListener (event, handler) {\n    this.eventMap.has(event)\n      // 判断当前订阅的消息队列中是否已经存在\n      ? this.eventMap.set(event, this.eventMap.get(event).concat([ handler ]))\n      : this.eventMap.set(event, [ handler ])\n  }\n  dispatch (event) {\n    // 发布\n    // 该消息的订阅队列不存在\n    if (!this.eventMap.has(event)) return\n\n    // 推送消息\n    this.eventMap.get(event).forEach(fn => fn())\n  }\n}\n```\n以上基本的event emitter调度中心已经封装完成了正常使用应该是没有问题的\n测试：\n```js\nconst e = new Event()\n\ne.addEventListener('e1', (e) => {\n  console.log('handle e1 first')\n})\n\ne.addEventListener('e1', (e) => {\n  console.log('handle e1 second', e)\n})\n\ne.dispatch('e1')\n\n// output: \n// handle e1 first\n// handle e1 second\n```\n那么如何使用函数式编程的思想将上面的event emitter封装起来呢？\n\n# functional event emitter\n#### functional addEventListener\n如传统封装方法的一致，addEventListener内部需要分别使用消息类型event，消息回调handler以及存储中心eventMap，用柯里化的思想分别将这三个传入新封装的函数，新函数即为：\n```js\nconst addEventListener = event\n  => handler\n    => eventMap\n      => eventMap.has(event)\n        // 判断逻辑不变\n        ? new Map(eventMap).set(event, eventMap.get(event).concat([handler]))\n        : new Map(eventMap).set(event, [handler])\n```\n\n#### functional dispatch\n同样，观察上面封装的dispatch方法，我们需要消息类型event和存储中心eventMap两个数据，下面也分为两个参数分别传入，改写的dispatch方法如下：\n```js\nconst dispatch = event\n  => eventMap\n    => eventMap.has(event) && eventMap.get(event).forEach(fn => fn())\n```\nevent emitter类两个核心的函数已经改写完毕了，可是我们观察上面的addEventListener方法，可以看到上面的封装分三步将所需要的参数分别传入，调用即为：`addEventListener('e2')(() => log('hey'))`, 此时的返回值是一个需要接受存储中心 `eventMap` 为参数的一个新函数，这里需要注意\n我们要对所有的addEventListener进行整合最终传入同一个map对象作为唯一存储对象，下面我们要写一个compose函数\n\n#### functional compose\n这个compose需要接受函数的集合（函数即为`addEventListener('e2')(() => log('hey'))`的返回值的函数）作为参数，使用数组最强大的reduce方法对传入的函数进行批处理调用即可，如果大家熟悉redux里面的compose函数，其实都是一样的，都是处理一组函数集合的集中调用（类似的还有之前的一篇博客 [十行代码实现Koa2洋葱模型](https://rollawaypoint.github.io/2019/02/22/writeSomething/koa2OnionModel/#%E4%B8%89%E6%AD%A5%E5%AE%8C%E6%88%90%E5%B0%81%E8%A3%85) 中的compose函数）， 代码如下：\n```js\nconst compose = (...fns)\n  => fns.reduceRight((f, g)\n    => (...args)\n      => f(g(...args)))\n```\n至此，所有的封装基本已经完成了，使用函数式的封装，保护函数状态的单一性，下面进行测试：\n\n\n```js\nconst addEventListeners = compose(\n  addEventListener('e2')(() => log('hey')),\n  addEventListener('e2')(() => log('hi'))\n)\n\nconst m = addEventListeners(new Map())\ndispatch('e2')(m)\n\n// output:\n// hey\n// hi\n\n```\n\n**end**\n","slug":"writeSomething/FunctionalEventEmitter","published":1,"updated":"2019-03-29T05:55:29.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxws0015ax481ou2sejy","content":"<p>用函数式编程简单封装一个 <code>event emitter</code><br><a id=\"more\"></a></p>\n<p>函数式编程：函数式编程（英语：functional programming），又称泛函编程，是一种编程范式，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象<br><em>起源于范畴论</em></p>\n<h1 id=\"从函数柯里化说起\"><a href=\"#从函数柯里化说起\" class=\"headerlink\" title=\"从函数柯里化说起\"></a>从函数柯里化说起</h1><p><em>从低阶函数变为高阶函数的过程</em><br>从调用上来看，就是将 <code>f(a, b, c)</code> 变为支持 <code>f(a)(b)(c)</code>、<code>f(a, b)(c)</code>、<code>f(a)(b, c)</code>的形式<br>如最基本的 <code>(a, b) =&gt; a + b</code> 可以柯里化为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\">f(<span class=\"number\">4</span>)(<span class=\"number\">6</span>) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure></p>\n<p>这表明函数柯里化是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。从某种意义上来讲，这是一种对参数的缓存，是一种非常高效的编写函数的方法</p>\n<p>具体的细节不赘述主要内容是封装这个event emitter，<em>很多时候js相关的类函数式操作（reduce、compose）被当做了函数式编程</em>, 有机会单独深入了解函数式编程Functor、Monad、Applicative后来仔细说说</p>\n<h1 id=\"传统封装event-emitter\"><a href=\"#传统封装event-emitter\" class=\"headerlink\" title=\"传统封装event emitter\"></a>传统封装event emitter</h1><p>首先定义一个拥有着基本的订阅和发布的event类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  addEventListener () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类要有一个存储订阅者的地方，同时发布的时候要将消息推送给所有订阅该消息的订阅者<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (eventMap = new Map()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用map存储订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap = eventMap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addEventListener (event, handler) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch (event) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布</span></span><br><span class=\"line\">    <span class=\"comment\">// 该消息的订阅队列不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.eventMap.has(event)) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 推送消息</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面添加event的订阅方法，支持传入订阅消息名和对应的回调<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (eventMap = new Map()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用map存储订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap = eventMap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addEventListener (event, handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.has(event)</span><br><span class=\"line\">      <span class=\"comment\">// 判断当前订阅的消息队列中是否已经存在</span></span><br><span class=\"line\">      ? <span class=\"keyword\">this</span>.eventMap.set(event, <span class=\"keyword\">this</span>.eventMap.get(event).concat([ handler ]))</span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.eventMap.set(event, [ handler ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch (event) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布</span></span><br><span class=\"line\">    <span class=\"comment\">// 该消息的订阅队列不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.eventMap.has(event)) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 推送消息</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的event emitter调度中心已经封装完成了正常使用应该是没有问题的<br>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> e = <span class=\"keyword\">new</span> Event()</span><br><span class=\"line\"></span><br><span class=\"line\">e.addEventListener(<span class=\"string\">'e1'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'handle e1 first'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">e.addEventListener(<span class=\"string\">'e1'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'handle e1 second'</span>, e)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">e.dispatch(<span class=\"string\">'e1'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: </span></span><br><span class=\"line\"><span class=\"comment\">// handle e1 first</span></span><br><span class=\"line\"><span class=\"comment\">// handle e1 second</span></span><br></pre></td></tr></table></figure></p>\n<p>那么如何使用函数式编程的思想将上面的event emitter封装起来呢？</p>\n<h1 id=\"functional-event-emitter\"><a href=\"#functional-event-emitter\" class=\"headerlink\" title=\"functional event emitter\"></a>functional event emitter</h1><h4 id=\"functional-addEventListener\"><a href=\"#functional-addEventListener\" class=\"headerlink\" title=\"functional addEventListener\"></a>functional addEventListener</h4><p>如传统封装方法的一致，addEventListener内部需要分别使用消息类型event，消息回调handler以及存储中心eventMap，用柯里化的思想分别将这三个传入新封装的函数，新函数即为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> addEventListener = event</span><br><span class=\"line\">  =&gt; handler</span><br><span class=\"line\">    =&gt; eventMap</span><br><span class=\"line\">      =&gt; eventMap.has(event)</span><br><span class=\"line\">        <span class=\"comment\">// 判断逻辑不变</span></span><br><span class=\"line\">        ? <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(eventMap).set(event, eventMap.get(event).concat([handler]))</span><br><span class=\"line\">        : <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(eventMap).set(event, [handler])</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"functional-dispatch\"><a href=\"#functional-dispatch\" class=\"headerlink\" title=\"functional dispatch\"></a>functional dispatch</h4><p>同样，观察上面封装的dispatch方法，我们需要消息类型event和存储中心eventMap两个数据，下面也分为两个参数分别传入，改写的dispatch方法如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dispatch = event</span><br><span class=\"line\">  =&gt; eventMap</span><br><span class=\"line\">    =&gt; eventMap.has(event) &amp;&amp; eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br></pre></td></tr></table></figure></p>\n<p>event emitter类两个核心的函数已经改写完毕了，可是我们观察上面的addEventListener方法，可以看到上面的封装分三步将所需要的参数分别传入，调用即为：<code>addEventListener(&#39;e2&#39;)(() =&gt; log(&#39;hey&#39;))</code>, 此时的返回值是一个需要接受存储中心 <code>eventMap</code> 为参数的一个新函数，这里需要注意<br>我们要对所有的addEventListener进行整合最终传入同一个map对象作为唯一存储对象，下面我们要写一个compose函数</p>\n<h4 id=\"functional-compose\"><a href=\"#functional-compose\" class=\"headerlink\" title=\"functional compose\"></a>functional compose</h4><p>这个compose需要接受函数的集合（函数即为<code>addEventListener(&#39;e2&#39;)(() =&gt; log(&#39;hey&#39;))</code>的返回值的函数）作为参数，使用数组最强大的reduce方法对传入的函数进行批处理调用即可，如果大家熟悉redux里面的compose函数，其实都是一样的，都是处理一组函数集合的集中调用（类似的还有之前的一篇博客 <a href=\"https://rollawaypoint.github.io/2019/02/22/writeSomething/koa2OnionModel/#%E4%B8%89%E6%AD%A5%E5%AE%8C%E6%88%90%E5%B0%81%E8%A3%85\">十行代码实现Koa2洋葱模型</a> 中的compose函数）， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = (...fns)</span><br><span class=\"line\">  =&gt; fns.reduceRight((f, g)</span><br><span class=\"line\">    =&gt; (...args)</span><br><span class=\"line\">      =&gt; f(g(...args)))</span><br></pre></td></tr></table></figure></p>\n<p>至此，所有的封装基本已经完成了，使用函数式的封装，保护函数状态的单一性，下面进行测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> addEventListeners = compose(</span><br><span class=\"line\">  addEventListener(<span class=\"string\">'e2'</span>)(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> log(<span class=\"string\">'hey'</span>)),</span><br><span class=\"line\">  addEventListener(<span class=\"string\">'e2'</span>)(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> log(<span class=\"string\">'hi'</span>))</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> m = addEventListeners(<span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>())</span><br><span class=\"line\">dispatch(<span class=\"string\">'e2'</span>)(m)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// hey</span></span><br><span class=\"line\"><span class=\"comment\">// hi</span></span><br></pre></td></tr></table></figure>\n<p><strong>end</strong></p>\n","site":{"data":{}},"excerpt":"<p>用函数式编程简单封装一个 <code>event emitter</code><br></p>","more":"<p></p>\n<p>函数式编程：函数式编程（英语：functional programming），又称泛函编程，是一种编程范式，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象<br><em>起源于范畴论</em></p>\n<h1 id=\"从函数柯里化说起\"><a href=\"#从函数柯里化说起\" class=\"headerlink\" title=\"从函数柯里化说起\"></a>从函数柯里化说起</h1><p><em>从低阶函数变为高阶函数的过程</em><br>从调用上来看，就是将 <code>f(a, b, c)</code> 变为支持 <code>f(a)(b)(c)</code>、<code>f(a, b)(c)</code>、<code>f(a)(b, c)</code>的形式<br>如最基本的 <code>(a, b) =&gt; a + b</code> 可以柯里化为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\">f(<span class=\"number\">4</span>)(<span class=\"number\">6</span>) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure></p>\n<p>这表明函数柯里化是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。从某种意义上来讲，这是一种对参数的缓存，是一种非常高效的编写函数的方法</p>\n<p>具体的细节不赘述主要内容是封装这个event emitter，<em>很多时候js相关的类函数式操作（reduce、compose）被当做了函数式编程</em>, 有机会单独深入了解函数式编程Functor、Monad、Applicative后来仔细说说</p>\n<h1 id=\"传统封装event-emitter\"><a href=\"#传统封装event-emitter\" class=\"headerlink\" title=\"传统封装event emitter\"></a>传统封装event emitter</h1><p>首先定义一个拥有着基本的订阅和发布的event类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  addEventListener () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类要有一个存储订阅者的地方，同时发布的时候要将消息推送给所有订阅该消息的订阅者<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (eventMap = new Map()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用map存储订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap = eventMap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addEventListener (event, handler) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch (event) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布</span></span><br><span class=\"line\">    <span class=\"comment\">// 该消息的订阅队列不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.eventMap.has(event)) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 推送消息</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面添加event的订阅方法，支持传入订阅消息名和对应的回调<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (eventMap = new Map()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用map存储订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap = eventMap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addEventListener (event, handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.has(event)</span><br><span class=\"line\">      <span class=\"comment\">// 判断当前订阅的消息队列中是否已经存在</span></span><br><span class=\"line\">      ? <span class=\"keyword\">this</span>.eventMap.set(event, <span class=\"keyword\">this</span>.eventMap.get(event).concat([ handler ]))</span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.eventMap.set(event, [ handler ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch (event) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布</span></span><br><span class=\"line\">    <span class=\"comment\">// 该消息的订阅队列不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.eventMap.has(event)) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 推送消息</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的event emitter调度中心已经封装完成了正常使用应该是没有问题的<br>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> e = <span class=\"keyword\">new</span> Event()</span><br><span class=\"line\"></span><br><span class=\"line\">e.addEventListener(<span class=\"string\">'e1'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'handle e1 first'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">e.addEventListener(<span class=\"string\">'e1'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'handle e1 second'</span>, e)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">e.dispatch(<span class=\"string\">'e1'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: </span></span><br><span class=\"line\"><span class=\"comment\">// handle e1 first</span></span><br><span class=\"line\"><span class=\"comment\">// handle e1 second</span></span><br></pre></td></tr></table></figure></p>\n<p>那么如何使用函数式编程的思想将上面的event emitter封装起来呢？</p>\n<h1 id=\"functional-event-emitter\"><a href=\"#functional-event-emitter\" class=\"headerlink\" title=\"functional event emitter\"></a>functional event emitter</h1><h4 id=\"functional-addEventListener\"><a href=\"#functional-addEventListener\" class=\"headerlink\" title=\"functional addEventListener\"></a>functional addEventListener</h4><p>如传统封装方法的一致，addEventListener内部需要分别使用消息类型event，消息回调handler以及存储中心eventMap，用柯里化的思想分别将这三个传入新封装的函数，新函数即为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> addEventListener = event</span><br><span class=\"line\">  =&gt; handler</span><br><span class=\"line\">    =&gt; eventMap</span><br><span class=\"line\">      =&gt; eventMap.has(event)</span><br><span class=\"line\">        <span class=\"comment\">// 判断逻辑不变</span></span><br><span class=\"line\">        ? <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(eventMap).set(event, eventMap.get(event).concat([handler]))</span><br><span class=\"line\">        : <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(eventMap).set(event, [handler])</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"functional-dispatch\"><a href=\"#functional-dispatch\" class=\"headerlink\" title=\"functional dispatch\"></a>functional dispatch</h4><p>同样，观察上面封装的dispatch方法，我们需要消息类型event和存储中心eventMap两个数据，下面也分为两个参数分别传入，改写的dispatch方法如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dispatch = event</span><br><span class=\"line\">  =&gt; eventMap</span><br><span class=\"line\">    =&gt; eventMap.has(event) &amp;&amp; eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br></pre></td></tr></table></figure></p>\n<p>event emitter类两个核心的函数已经改写完毕了，可是我们观察上面的addEventListener方法，可以看到上面的封装分三步将所需要的参数分别传入，调用即为：<code>addEventListener(&#39;e2&#39;)(() =&gt; log(&#39;hey&#39;))</code>, 此时的返回值是一个需要接受存储中心 <code>eventMap</code> 为参数的一个新函数，这里需要注意<br>我们要对所有的addEventListener进行整合最终传入同一个map对象作为唯一存储对象，下面我们要写一个compose函数</p>\n<h4 id=\"functional-compose\"><a href=\"#functional-compose\" class=\"headerlink\" title=\"functional compose\"></a>functional compose</h4><p>这个compose需要接受函数的集合（函数即为<code>addEventListener(&#39;e2&#39;)(() =&gt; log(&#39;hey&#39;))</code>的返回值的函数）作为参数，使用数组最强大的reduce方法对传入的函数进行批处理调用即可，如果大家熟悉redux里面的compose函数，其实都是一样的，都是处理一组函数集合的集中调用（类似的还有之前的一篇博客 <a href=\"https://rollawaypoint.github.io/2019/02/22/writeSomething/koa2OnionModel/#%E4%B8%89%E6%AD%A5%E5%AE%8C%E6%88%90%E5%B0%81%E8%A3%85\">十行代码实现Koa2洋葱模型</a> 中的compose函数）， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = (...fns)</span><br><span class=\"line\">  =&gt; fns.reduceRight((f, g)</span><br><span class=\"line\">    =&gt; (...args)</span><br><span class=\"line\">      =&gt; f(g(...args)))</span><br></pre></td></tr></table></figure></p>\n<p>至此，所有的封装基本已经完成了，使用函数式的封装，保护函数状态的单一性，下面进行测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> addEventListeners = compose(</span><br><span class=\"line\">  addEventListener(<span class=\"string\">'e2'</span>)(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> log(<span class=\"string\">'hey'</span>)),</span><br><span class=\"line\">  addEventListener(<span class=\"string\">'e2'</span>)(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> log(<span class=\"string\">'hi'</span>))</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> m = addEventListeners(<span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>())</span><br><span class=\"line\">dispatch(<span class=\"string\">'e2'</span>)(m)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// hey</span></span><br><span class=\"line\"><span class=\"comment\">// hi</span></span><br></pre></td></tr></table></figure>\n<p><strong>end</strong></p>"},{"title":"webpack define plugin","date":"2019-05-10T09:17:00.000Z","_content":"关于 webpack define plugin 的一些思考（胡思乱想）\n\n记录帖\n<!-- more -->\n\n这两天给当下接的项目配代理，用的 `http-proxy-middleware` 简单配置了一下本地就work了，没想到打包测试环境出了问题，才注意到原来项目中的api竟然不是跟随当前站点域名，且不统一有不同环境的不同域名。\n\n# 将原本的api对象根据环境映射一下\n\n```js\nexports.apis = {\n  [envA]: {\n    [alias]: '/'\n  },\n  [envB]: {\n    [alias]: '/'\n  }\n}\n```\n\n为了不影响项目中原本大量的引入使用方式，再单独导出一个聚合的apis\n```js\nexport default Object.keys(apis).reduce((all, c) => {\n  for (const k in apis[c]) {\n    if (all.hasOwnProperty(k)) {\n      throw new Error(`${k} has been injected, please check if your API key is duplicated.`);\n    }\n\n    all[k] = apis[c][k];\n  }\n\n  return all;\n}, {});\n```\n\n# 根据环境按照http-proxy-middleware参数格式对api进行format\n\n```js\nmodule.exports = Object.keys(APISMap).reduce((proxyTable, proxyDomain) => {\n  const domainApiMap = APISMap[proxyDomain]\n\n  proxyTable.push({\n    context: Object.keys(domainApiMap).reduce((apis, apiKey) => [...apis, domainApiMap[apiKey]], []),\n    config: {\n      // target: '//prod.com',\n      target: env ? apiConfig[env][proxyDomain] : '//mock.com/api',\n      changeOrigin: true,  \n    },\n  })\n\n  return proxyTable;\n}, [])\n\n```\n\n# 在server里使用http-proxy-middleware简单配置下上面导出的配置项参数\n```js\n// proxy api requests\n  if (isProxy && proxyTable) {\n    proxyTable.forEach(({context, config}) => app.use(proxyMiddleware(context, config)))\n  }\n```\n\n以为大功告成了？\n\n不，不同环境的打包之后出了问题\n\n配置读取的代理域名根据一个配置文件读取，而这个配置文件始终导出的环境都是`dev` （_\b之前的配置项_），并不想每次发版还要手动改环境，那也太傻\n\n于是决定代理的时候指定全路径可以不可以呢（读取当前真正环境域名映射）\n\nhttp-proxy-middleware竟然撂挑子了，本地代理都做不到了（更别说发布）\n\n对了，webpack不是可以定义全局环境变量吗？直接定义一个开发环境的不就好了吗？产线环境根本不走开发环境的webpack.config。\n\n# new webpack.definePlugin({})\n\n很nc，插件传入的数值必须使用双重引号包裹，eg.：`process.env.NODE_ENV: '\"dev\"'`\n\napis文件内已经可以正常使用了，根据当前环境，既然http-proxy-middleware只可以代理匹配api路径那就在开发环境保持，产线环境拼接原路径\n```js\nconst apis = require('./apis');\n\nconst isDev = process.env.NODE_ENV === 'dev';\n\nexport default Object.keys(apis).reduce((all, c) => {\n  for (const k in apis[c]) {\n    if (all.hasOwnProperty(k)) {\n      throw new Error(`${k} has been injected, please check if your API key is duplicated.`);\n    }\n    all[k] = isDev ? apis[c][k] : `${window[c]}${apis[c][k]}`;\n  }\n  return all;\n}, {});\n```\n\n已经没问题了，可是接下来我想在启动server的时候判断当前是不是我定的那个dev环境，我却无法使用我在webpack里面使用definePlugin定义的`process.env.NODE_ENV`\n\nwhy?!\n\n思维一度陷入误区，命名我在“浏览器环境”都能使用？？？不是刚在api文件中判断当前环境拼接domain吗？\n\nemmmm\n\ndefinePlugin!\ndefinePlugin!\ndefinePlugin!\n\ndefinePlugin只是定义一个映射的机制，将你定义的key在webpack编译AST的时候做了一个替换而已，他并不是node的process模块\n\n这个时候肯定会试一下，既然定义的只是key，那么且当做常量，那么我在apis文件打印一下process看看是什么？\n\n竟然是包含一系列信息的对象\n\n？？？\n\n浏览器环境为什么可以使用node模块？\n\n所以上面“浏览器环境”我加了引号\n\n猜测: 可能webpack只是模拟实现process模块在项目中，例如 `browser-process` 包。\n\n可是为什么我在编译webpack配置文件的时候无法使用定义的全局变量呢？一开始我以为没有走配置的compiler这个过程？\n虽然是昨晚的问题但是现在我也不确定何等原因...\n\n难搞哦😭\n","source":"_posts/writeSomething/Webpack_1.md","raw":"---\ntitle: webpack define plugin\ntags:\n  - webpack\ndate: 2019-05-10 17:17:00\ncategories: webpack\n---\n关于 webpack define plugin 的一些思考（胡思乱想）\n\n记录帖\n<!-- more -->\n\n这两天给当下接的项目配代理，用的 `http-proxy-middleware` 简单配置了一下本地就work了，没想到打包测试环境出了问题，才注意到原来项目中的api竟然不是跟随当前站点域名，且不统一有不同环境的不同域名。\n\n# 将原本的api对象根据环境映射一下\n\n```js\nexports.apis = {\n  [envA]: {\n    [alias]: '/'\n  },\n  [envB]: {\n    [alias]: '/'\n  }\n}\n```\n\n为了不影响项目中原本大量的引入使用方式，再单独导出一个聚合的apis\n```js\nexport default Object.keys(apis).reduce((all, c) => {\n  for (const k in apis[c]) {\n    if (all.hasOwnProperty(k)) {\n      throw new Error(`${k} has been injected, please check if your API key is duplicated.`);\n    }\n\n    all[k] = apis[c][k];\n  }\n\n  return all;\n}, {});\n```\n\n# 根据环境按照http-proxy-middleware参数格式对api进行format\n\n```js\nmodule.exports = Object.keys(APISMap).reduce((proxyTable, proxyDomain) => {\n  const domainApiMap = APISMap[proxyDomain]\n\n  proxyTable.push({\n    context: Object.keys(domainApiMap).reduce((apis, apiKey) => [...apis, domainApiMap[apiKey]], []),\n    config: {\n      // target: '//prod.com',\n      target: env ? apiConfig[env][proxyDomain] : '//mock.com/api',\n      changeOrigin: true,  \n    },\n  })\n\n  return proxyTable;\n}, [])\n\n```\n\n# 在server里使用http-proxy-middleware简单配置下上面导出的配置项参数\n```js\n// proxy api requests\n  if (isProxy && proxyTable) {\n    proxyTable.forEach(({context, config}) => app.use(proxyMiddleware(context, config)))\n  }\n```\n\n以为大功告成了？\n\n不，不同环境的打包之后出了问题\n\n配置读取的代理域名根据一个配置文件读取，而这个配置文件始终导出的环境都是`dev` （_\b之前的配置项_），并不想每次发版还要手动改环境，那也太傻\n\n于是决定代理的时候指定全路径可以不可以呢（读取当前真正环境域名映射）\n\nhttp-proxy-middleware竟然撂挑子了，本地代理都做不到了（更别说发布）\n\n对了，webpack不是可以定义全局环境变量吗？直接定义一个开发环境的不就好了吗？产线环境根本不走开发环境的webpack.config。\n\n# new webpack.definePlugin({})\n\n很nc，插件传入的数值必须使用双重引号包裹，eg.：`process.env.NODE_ENV: '\"dev\"'`\n\napis文件内已经可以正常使用了，根据当前环境，既然http-proxy-middleware只可以代理匹配api路径那就在开发环境保持，产线环境拼接原路径\n```js\nconst apis = require('./apis');\n\nconst isDev = process.env.NODE_ENV === 'dev';\n\nexport default Object.keys(apis).reduce((all, c) => {\n  for (const k in apis[c]) {\n    if (all.hasOwnProperty(k)) {\n      throw new Error(`${k} has been injected, please check if your API key is duplicated.`);\n    }\n    all[k] = isDev ? apis[c][k] : `${window[c]}${apis[c][k]}`;\n  }\n  return all;\n}, {});\n```\n\n已经没问题了，可是接下来我想在启动server的时候判断当前是不是我定的那个dev环境，我却无法使用我在webpack里面使用definePlugin定义的`process.env.NODE_ENV`\n\nwhy?!\n\n思维一度陷入误区，命名我在“浏览器环境”都能使用？？？不是刚在api文件中判断当前环境拼接domain吗？\n\nemmmm\n\ndefinePlugin!\ndefinePlugin!\ndefinePlugin!\n\ndefinePlugin只是定义一个映射的机制，将你定义的key在webpack编译AST的时候做了一个替换而已，他并不是node的process模块\n\n这个时候肯定会试一下，既然定义的只是key，那么且当做常量，那么我在apis文件打印一下process看看是什么？\n\n竟然是包含一系列信息的对象\n\n？？？\n\n浏览器环境为什么可以使用node模块？\n\n所以上面“浏览器环境”我加了引号\n\n猜测: 可能webpack只是模拟实现process模块在项目中，例如 `browser-process` 包。\n\n可是为什么我在编译webpack配置文件的时候无法使用定义的全局变量呢？一开始我以为没有走配置的compiler这个过程？\n虽然是昨晚的问题但是现在我也不确定何等原因...\n\n难搞哦😭\n","slug":"writeSomething/Webpack_1","published":1,"updated":"2019-09-03T07:17:52.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwu0018ax48z28kai0t","content":"<p>关于 webpack define plugin 的一些思考（胡思乱想）</p>\n<p>记录帖<br><a id=\"more\"></a></p>\n<p>这两天给当下接的项目配代理，用的 <code>http-proxy-middleware</code> 简单配置了一下本地就work了，没想到打包测试环境出了问题，才注意到原来项目中的api竟然不是跟随当前站点域名，且不统一有不同环境的不同域名。</p>\n<h1 id=\"将原本的api对象根据环境映射一下\"><a href=\"#将原本的api对象根据环境映射一下\" class=\"headerlink\" title=\"将原本的api对象根据环境映射一下\"></a>将原本的api对象根据环境映射一下</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.apis = &#123;</span><br><span class=\"line\">  [envA]: &#123;</span><br><span class=\"line\">    [alias]: <span class=\"string\">'/'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  [envB]: &#123;</span><br><span class=\"line\">    [alias]: <span class=\"string\">'/'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了不影响项目中原本大量的引入使用方式，再单独导出一个聚合的apis<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"built_in\">Object</span>.keys(apis).reduce(<span class=\"function\">(<span class=\"params\">all, c</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> apis[c]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (all.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;k&#125;</span> has been injected, please check if your API key is duplicated.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    all[k] = apis[c][k];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> all;</span><br><span class=\"line\">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"根据环境按照http-proxy-middleware参数格式对api进行format\"><a href=\"#根据环境按照http-proxy-middleware参数格式对api进行format\" class=\"headerlink\" title=\"根据环境按照http-proxy-middleware参数格式对api进行format\"></a>根据环境按照http-proxy-middleware参数格式对api进行format</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"built_in\">Object</span>.keys(APISMap).reduce(<span class=\"function\">(<span class=\"params\">proxyTable, proxyDomain</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domainApiMap = APISMap[proxyDomain]</span><br><span class=\"line\"></span><br><span class=\"line\">  proxyTable.push(&#123;</span><br><span class=\"line\">    context: <span class=\"built_in\">Object</span>.keys(domainApiMap).reduce(<span class=\"function\">(<span class=\"params\">apis, apiKey</span>) =&gt;</span> [...apis, domainApiMap[apiKey]], []),</span><br><span class=\"line\">    config: &#123;</span><br><span class=\"line\">      <span class=\"comment\">// target: '//prod.com',</span></span><br><span class=\"line\">      target: env ? apiConfig[env][proxyDomain] : <span class=\"string\">'//mock.com/api'</span>,</span><br><span class=\"line\">      changeOrigin: <span class=\"literal\">true</span>,  </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxyTable;</span><br><span class=\"line\">&#125;, [])</span><br></pre></td></tr></table></figure>\n<h1 id=\"在server里使用http-proxy-middleware简单配置下上面导出的配置项参数\"><a href=\"#在server里使用http-proxy-middleware简单配置下上面导出的配置项参数\" class=\"headerlink\" title=\"在server里使用http-proxy-middleware简单配置下上面导出的配置项参数\"></a>在server里使用http-proxy-middleware简单配置下上面导出的配置项参数</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// proxy api requests</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isProxy &amp;&amp; proxyTable) &#123;</span><br><span class=\"line\">    proxyTable.forEach(<span class=\"function\">(<span class=\"params\">&#123;context, config&#125;</span>) =&gt;</span> app.use(proxyMiddleware(context, config)))</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>以为大功告成了？</p>\n<p>不，不同环境的打包之后出了问题</p>\n<p>配置读取的代理域名根据一个配置文件读取，而这个配置文件始终导出的环境都是<code>dev</code> （<em>\b之前的配置项</em>），并不想每次发版还要手动改环境，那也太傻</p>\n<p>于是决定代理的时候指定全路径可以不可以呢（读取当前真正环境域名映射）</p>\n<p>http-proxy-middleware竟然撂挑子了，本地代理都做不到了（更别说发布）</p>\n<p>对了，webpack不是可以定义全局环境变量吗？直接定义一个开发环境的不就好了吗？产线环境根本不走开发环境的webpack.config。</p>\n<h1 id=\"new-webpack-definePlugin\"><a href=\"#new-webpack-definePlugin\" class=\"headerlink\" title=\"new webpack.definePlugin({})\"></a>new webpack.definePlugin({})</h1><p>很nc，插件传入的数值必须使用双重引号包裹，eg.：<code>process.env.NODE_ENV: &#39;&quot;dev&quot;&#39;</code></p>\n<p>apis文件内已经可以正常使用了，根据当前环境，既然http-proxy-middleware只可以代理匹配api路径那就在开发环境保持，产线环境拼接原路径<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> apis = <span class=\"built_in\">require</span>(<span class=\"string\">'./apis'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isDev = process.env.NODE_ENV === <span class=\"string\">'dev'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"built_in\">Object</span>.keys(apis).reduce(<span class=\"function\">(<span class=\"params\">all, c</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> apis[c]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (all.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;k&#125;</span> has been injected, please check if your API key is duplicated.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    all[k] = isDev ? apis[c][k] : <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">window</span>[c]&#125;</span><span class=\"subst\">$&#123;apis[c][k]&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> all;</span><br><span class=\"line\">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>已经没问题了，可是接下来我想在启动server的时候判断当前是不是我定的那个dev环境，我却无法使用我在webpack里面使用definePlugin定义的<code>process.env.NODE_ENV</code></p>\n<p>why?!</p>\n<p>思维一度陷入误区，命名我在“浏览器环境”都能使用？？？不是刚在api文件中判断当前环境拼接domain吗？</p>\n<p>emmmm</p>\n<p>definePlugin!<br>definePlugin!<br>definePlugin!</p>\n<p>definePlugin只是定义一个映射的机制，将你定义的key在webpack编译AST的时候做了一个替换而已，他并不是node的process模块</p>\n<p>这个时候肯定会试一下，既然定义的只是key，那么且当做常量，那么我在apis文件打印一下process看看是什么？</p>\n<p>竟然是包含一系列信息的对象</p>\n<p>？？？</p>\n<p>浏览器环境为什么可以使用node模块？</p>\n<p>所以上面“浏览器环境”我加了引号</p>\n<p>猜测: 可能webpack只是模拟实现process模块在项目中，例如 <code>browser-process</code> 包。</p>\n<p>可是为什么我在编译webpack配置文件的时候无法使用定义的全局变量呢？一开始我以为没有走配置的compiler这个过程？<br>虽然是昨晚的问题但是现在我也不确定何等原因…</p>\n<p>难搞哦😭</p>\n","site":{"data":{}},"excerpt":"<p>关于 webpack define plugin 的一些思考（胡思乱想）</p>\n<p>记录帖<br></p>","more":"<p></p>\n<p>这两天给当下接的项目配代理，用的 <code>http-proxy-middleware</code> 简单配置了一下本地就work了，没想到打包测试环境出了问题，才注意到原来项目中的api竟然不是跟随当前站点域名，且不统一有不同环境的不同域名。</p>\n<h1 id=\"将原本的api对象根据环境映射一下\"><a href=\"#将原本的api对象根据环境映射一下\" class=\"headerlink\" title=\"将原本的api对象根据环境映射一下\"></a>将原本的api对象根据环境映射一下</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.apis = &#123;</span><br><span class=\"line\">  [envA]: &#123;</span><br><span class=\"line\">    [alias]: <span class=\"string\">'/'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  [envB]: &#123;</span><br><span class=\"line\">    [alias]: <span class=\"string\">'/'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了不影响项目中原本大量的引入使用方式，再单独导出一个聚合的apis<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"built_in\">Object</span>.keys(apis).reduce(<span class=\"function\">(<span class=\"params\">all, c</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> apis[c]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (all.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;k&#125;</span> has been injected, please check if your API key is duplicated.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    all[k] = apis[c][k];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> all;</span><br><span class=\"line\">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"根据环境按照http-proxy-middleware参数格式对api进行format\"><a href=\"#根据环境按照http-proxy-middleware参数格式对api进行format\" class=\"headerlink\" title=\"根据环境按照http-proxy-middleware参数格式对api进行format\"></a>根据环境按照http-proxy-middleware参数格式对api进行format</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"built_in\">Object</span>.keys(APISMap).reduce(<span class=\"function\">(<span class=\"params\">proxyTable, proxyDomain</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domainApiMap = APISMap[proxyDomain]</span><br><span class=\"line\"></span><br><span class=\"line\">  proxyTable.push(&#123;</span><br><span class=\"line\">    context: <span class=\"built_in\">Object</span>.keys(domainApiMap).reduce(<span class=\"function\">(<span class=\"params\">apis, apiKey</span>) =&gt;</span> [...apis, domainApiMap[apiKey]], []),</span><br><span class=\"line\">    config: &#123;</span><br><span class=\"line\">      <span class=\"comment\">// target: '//prod.com',</span></span><br><span class=\"line\">      target: env ? apiConfig[env][proxyDomain] : <span class=\"string\">'//mock.com/api'</span>,</span><br><span class=\"line\">      changeOrigin: <span class=\"literal\">true</span>,  </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxyTable;</span><br><span class=\"line\">&#125;, [])</span><br></pre></td></tr></table></figure>\n<h1 id=\"在server里使用http-proxy-middleware简单配置下上面导出的配置项参数\"><a href=\"#在server里使用http-proxy-middleware简单配置下上面导出的配置项参数\" class=\"headerlink\" title=\"在server里使用http-proxy-middleware简单配置下上面导出的配置项参数\"></a>在server里使用http-proxy-middleware简单配置下上面导出的配置项参数</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// proxy api requests</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isProxy &amp;&amp; proxyTable) &#123;</span><br><span class=\"line\">    proxyTable.forEach(<span class=\"function\">(<span class=\"params\">&#123;context, config&#125;</span>) =&gt;</span> app.use(proxyMiddleware(context, config)))</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>以为大功告成了？</p>\n<p>不，不同环境的打包之后出了问题</p>\n<p>配置读取的代理域名根据一个配置文件读取，而这个配置文件始终导出的环境都是<code>dev</code> （<em>\b之前的配置项</em>），并不想每次发版还要手动改环境，那也太傻</p>\n<p>于是决定代理的时候指定全路径可以不可以呢（读取当前真正环境域名映射）</p>\n<p>http-proxy-middleware竟然撂挑子了，本地代理都做不到了（更别说发布）</p>\n<p>对了，webpack不是可以定义全局环境变量吗？直接定义一个开发环境的不就好了吗？产线环境根本不走开发环境的webpack.config。</p>\n<h1 id=\"new-webpack-definePlugin\"><a href=\"#new-webpack-definePlugin\" class=\"headerlink\" title=\"new webpack.definePlugin({})\"></a>new webpack.definePlugin({})</h1><p>很nc，插件传入的数值必须使用双重引号包裹，eg.：<code>process.env.NODE_ENV: &#39;&quot;dev&quot;&#39;</code></p>\n<p>apis文件内已经可以正常使用了，根据当前环境，既然http-proxy-middleware只可以代理匹配api路径那就在开发环境保持，产线环境拼接原路径<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> apis = <span class=\"built_in\">require</span>(<span class=\"string\">'./apis'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isDev = process.env.NODE_ENV === <span class=\"string\">'dev'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"built_in\">Object</span>.keys(apis).reduce(<span class=\"function\">(<span class=\"params\">all, c</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> apis[c]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (all.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;k&#125;</span> has been injected, please check if your API key is duplicated.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    all[k] = isDev ? apis[c][k] : <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">window</span>[c]&#125;</span><span class=\"subst\">$&#123;apis[c][k]&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> all;</span><br><span class=\"line\">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>已经没问题了，可是接下来我想在启动server的时候判断当前是不是我定的那个dev环境，我却无法使用我在webpack里面使用definePlugin定义的<code>process.env.NODE_ENV</code></p>\n<p>why?!</p>\n<p>思维一度陷入误区，命名我在“浏览器环境”都能使用？？？不是刚在api文件中判断当前环境拼接domain吗？</p>\n<p>emmmm</p>\n<p>definePlugin!<br>definePlugin!<br>definePlugin!</p>\n<p>definePlugin只是定义一个映射的机制，将你定义的key在webpack编译AST的时候做了一个替换而已，他并不是node的process模块</p>\n<p>这个时候肯定会试一下，既然定义的只是key，那么且当做常量，那么我在apis文件打印一下process看看是什么？</p>\n<p>竟然是包含一系列信息的对象</p>\n<p>？？？</p>\n<p>浏览器环境为什么可以使用node模块？</p>\n<p>所以上面“浏览器环境”我加了引号</p>\n<p>猜测: 可能webpack只是模拟实现process模块在项目中，例如 <code>browser-process</code> 包。</p>\n<p>可是为什么我在编译webpack配置文件的时候无法使用定义的全局变量呢？一开始我以为没有走配置的compiler这个过程？<br>虽然是昨晚的问题但是现在我也不确定何等原因…</p>\n<p>难搞哦😭</p>"},{"title":"使用ts封装一个fetch请求库---请求的并发控制","date":"2019-06-13T06:20:00.000Z","_content":"fetch系列第三篇`记录帖`，封装一个请求并发控制的库\n\n<!-- more -->\n和各类型拦截器封装的本质一样，通过不直接更改原宿主的形式对原宿主进行包装重写覆盖（或者称之为装饰者模式）\n\n_代码由 `wx.request` 作为示例_\n\n# 从使用开始\n先从使用场景入手，希望引入一个函数可以接受原request方法以及控制的并发数从而返回一个内部可以控制指定并发数的新请求函数\n\n```js\nconst wrapper = require('request-concurrency')\n\nconst new_fetch = wrapper(fetch, 2)\n```\n\n所以主要就是处理以下三件事：\n\n1. 接受原请求方法以及并发数参数\n2. 构建请求派发队列\n3. 对原请求进行包装参数处理\n\n# 接受原请求方法以及并发数参数\n\n接受原请求方法以及并发数参数并返回一个promsie\n```js\n// 向外暴露的接口方法\nfunction setConcurrencyRequest(request, concurrency = 10) {\n  if (typeof request !== 'function') {\n    throw Error('request must be function')\n  }\n\n  // 请求队列\n  const queue = []\n\n  // 对外暴露的调用方法\n  return apiArgs => {\n    return new Promise((resolve, reject) => {\n    })\n  }\n}\n```\n接下来需要构建请求派发队列，主要分为两部分：执行队列和等待队列\n\n# 构建请求派发队列\n\n用闭包对两个队列分别做存储，用户每次触发客户端请求都会先将请求推入等待队列中，而在执行阶段则主要做两件事情，一是不断将执行队列中的请求派发出去（初始是空），二是不断检查执行队列的长度（并发数），当执行队列的长度在并发数以内则将等待队列中的请求按顺序推入（先入先出）执行队列。\n\n这里的最重要的地方是执行队列中请求完成的时候返回客户端结果同时将该请求从执行队列中移除。\n\n也主要有三件事情：\n1. 接受客户端传入的请求推入等待队列 `push`\n2. 派发当前执行队列中的请求 `excute`\n3. 移除执行队列中结束的请求，将等待队列中相应数量的请求按照先进先出的顺序移除并推入执行队列 `changeQueue`\n\n```js\nfunction getRequestQueue(call, concurrency) {\n  concurrency = concurrency || 5\n\n  // 挂起\n  const waitingList = []\n  // 执行\n  const executionList = []\n\n  return function() {\n    const model = {\n      concurrency,\n      push(currentRequest, call) {\n        waitingList.push({\n          currentRequest,\n          call\n        })\n\n        this.excute()\n      },\n      excute() {\n        while (this.concurrency > executionList.length && waitingList.length) {\n          // 将挂起队列中请求推进执行队列\n          const apiModel = waitingList.shift()\n          executionList.push(apiModel)\n          call(\n            apiModel.currentRequest,\n            setCall((...args) => {\n              this.changeQueue(apiModel)\n              if (apiModel.call) {\n                apiModel.call.constructor === Function && apiModel.call(...args)\n              }\n\n              // 发起请求\n              this.excute()\n            })\n          )\n        }\n      },\n      changeQueue(apiModel) {\n        // 从执行队列移除\n        const index = executionList.indexOf(apiModel)\n\n        if (index !== -1) {\n          executionList.splice(index, 1)\n        }\n      }\n    }\n\n    return model\n  }\n}\n```\n\n\n\n\n# 以下为完整代码\n\n源码放在：\n> [https://github.com/rollawaypoint/request-concurrency/blob/master/lib/index.js](https://github.com/rollawaypoint/request-concurrency/blob/master/lib/index.js)\n\n```js\nconst defaultConcurrency = 5\n\nfunction setConcurrencyCount(concurrency = defaultConcurrency) {\n  return concurrency && concurrency.constructor === Number\n    ? concurrency\n    : defaultConcurrency\n}\n\n// 回调结束置空\nconst setCall = fn => (...args) => {\n  if (!fn) {\n    throw new Error('repeating call has been denied.')\n  }\n\n  const call = fn\n  fn = null\n\n  return call(...args)\n}\n\nfunction getRequestQueue(call, concurrency) {\n  concurrency = setConcurrencyCount(concurrency)\n\n  // 挂起\n  const waitingList = []\n  // 执行\n  const executionList = []\n\n  return function() {\n    const model = {\n      concurrency,\n      push(currentRequest, call) {\n        waitingList.push({\n          currentRequest,\n          call\n        })\n\n        this.excute()\n      },\n\n      excute() {\n        while (this.concurrency > executionList.length && waitingList.length) {\n          // 将挂起队列中请求推进执行队列\n          const apiModel = waitingList.shift()\n\n          executionList.push(apiModel)\n\n          call(\n            apiModel.currentRequest,\n            setCall((...args) => {\n              this.changeQueue(apiModel)\n\n              if (apiModel.call) {\n                apiModel.call.constructor === Function && apiModel.call(...args)\n              }\n\n              // 发起请求\n              this.excute()\n            })\n          )\n        }\n      },\n\n      changeQueue(apiModel) {\n        // 从执行队列移除\n        const index = executionList.indexOf(apiModel)\n\n        if (index !== -1) {\n          executionList.splice(index, 1)\n        }\n      }\n    }\n\n    return model\n  }\n}\n\nfunction setConcurrencyRequest(request, concurrency = defaultConcurrency) {\n  if (typeof request !== 'function') {\n    throw Error('request must be function')\n  }\n\n  const queue = getRequestQueue(\n    (currentRequest, call) => currentRequest(call),\n    concurrency\n  )()\n\n  return apiArgs => {\n    return new Promise((resolve, reject) => {\n      queue.push(call => {\n        const complete = apiArgs.complete\n  \n        apiArgs.complete = (...args) => {\n          // 请求完成\n          call()\n          if (complete) {\n            complete.constructor === Function && complete.apply(apiArgs, args)\n          }\n        }\n  \n        resolve(request(apiArgs))\n      })\n    })\n  }\n}\n\nmodule.exports = setConcurrencyRequest\n```","source":"_posts/writeSomething/Fetch_3_concurrency.md","raw":"---\ntitle: 使用ts封装一个fetch请求库---请求的并发控制\ntags:\n  - fetch\n  - concurrency\ndate: 2019-06-13 14:20:00\ncategories: 封装\n---\nfetch系列第三篇`记录帖`，封装一个请求并发控制的库\n\n<!-- more -->\n和各类型拦截器封装的本质一样，通过不直接更改原宿主的形式对原宿主进行包装重写覆盖（或者称之为装饰者模式）\n\n_代码由 `wx.request` 作为示例_\n\n# 从使用开始\n先从使用场景入手，希望引入一个函数可以接受原request方法以及控制的并发数从而返回一个内部可以控制指定并发数的新请求函数\n\n```js\nconst wrapper = require('request-concurrency')\n\nconst new_fetch = wrapper(fetch, 2)\n```\n\n所以主要就是处理以下三件事：\n\n1. 接受原请求方法以及并发数参数\n2. 构建请求派发队列\n3. 对原请求进行包装参数处理\n\n# 接受原请求方法以及并发数参数\n\n接受原请求方法以及并发数参数并返回一个promsie\n```js\n// 向外暴露的接口方法\nfunction setConcurrencyRequest(request, concurrency = 10) {\n  if (typeof request !== 'function') {\n    throw Error('request must be function')\n  }\n\n  // 请求队列\n  const queue = []\n\n  // 对外暴露的调用方法\n  return apiArgs => {\n    return new Promise((resolve, reject) => {\n    })\n  }\n}\n```\n接下来需要构建请求派发队列，主要分为两部分：执行队列和等待队列\n\n# 构建请求派发队列\n\n用闭包对两个队列分别做存储，用户每次触发客户端请求都会先将请求推入等待队列中，而在执行阶段则主要做两件事情，一是不断将执行队列中的请求派发出去（初始是空），二是不断检查执行队列的长度（并发数），当执行队列的长度在并发数以内则将等待队列中的请求按顺序推入（先入先出）执行队列。\n\n这里的最重要的地方是执行队列中请求完成的时候返回客户端结果同时将该请求从执行队列中移除。\n\n也主要有三件事情：\n1. 接受客户端传入的请求推入等待队列 `push`\n2. 派发当前执行队列中的请求 `excute`\n3. 移除执行队列中结束的请求，将等待队列中相应数量的请求按照先进先出的顺序移除并推入执行队列 `changeQueue`\n\n```js\nfunction getRequestQueue(call, concurrency) {\n  concurrency = concurrency || 5\n\n  // 挂起\n  const waitingList = []\n  // 执行\n  const executionList = []\n\n  return function() {\n    const model = {\n      concurrency,\n      push(currentRequest, call) {\n        waitingList.push({\n          currentRequest,\n          call\n        })\n\n        this.excute()\n      },\n      excute() {\n        while (this.concurrency > executionList.length && waitingList.length) {\n          // 将挂起队列中请求推进执行队列\n          const apiModel = waitingList.shift()\n          executionList.push(apiModel)\n          call(\n            apiModel.currentRequest,\n            setCall((...args) => {\n              this.changeQueue(apiModel)\n              if (apiModel.call) {\n                apiModel.call.constructor === Function && apiModel.call(...args)\n              }\n\n              // 发起请求\n              this.excute()\n            })\n          )\n        }\n      },\n      changeQueue(apiModel) {\n        // 从执行队列移除\n        const index = executionList.indexOf(apiModel)\n\n        if (index !== -1) {\n          executionList.splice(index, 1)\n        }\n      }\n    }\n\n    return model\n  }\n}\n```\n\n\n\n\n# 以下为完整代码\n\n源码放在：\n> [https://github.com/rollawaypoint/request-concurrency/blob/master/lib/index.js](https://github.com/rollawaypoint/request-concurrency/blob/master/lib/index.js)\n\n```js\nconst defaultConcurrency = 5\n\nfunction setConcurrencyCount(concurrency = defaultConcurrency) {\n  return concurrency && concurrency.constructor === Number\n    ? concurrency\n    : defaultConcurrency\n}\n\n// 回调结束置空\nconst setCall = fn => (...args) => {\n  if (!fn) {\n    throw new Error('repeating call has been denied.')\n  }\n\n  const call = fn\n  fn = null\n\n  return call(...args)\n}\n\nfunction getRequestQueue(call, concurrency) {\n  concurrency = setConcurrencyCount(concurrency)\n\n  // 挂起\n  const waitingList = []\n  // 执行\n  const executionList = []\n\n  return function() {\n    const model = {\n      concurrency,\n      push(currentRequest, call) {\n        waitingList.push({\n          currentRequest,\n          call\n        })\n\n        this.excute()\n      },\n\n      excute() {\n        while (this.concurrency > executionList.length && waitingList.length) {\n          // 将挂起队列中请求推进执行队列\n          const apiModel = waitingList.shift()\n\n          executionList.push(apiModel)\n\n          call(\n            apiModel.currentRequest,\n            setCall((...args) => {\n              this.changeQueue(apiModel)\n\n              if (apiModel.call) {\n                apiModel.call.constructor === Function && apiModel.call(...args)\n              }\n\n              // 发起请求\n              this.excute()\n            })\n          )\n        }\n      },\n\n      changeQueue(apiModel) {\n        // 从执行队列移除\n        const index = executionList.indexOf(apiModel)\n\n        if (index !== -1) {\n          executionList.splice(index, 1)\n        }\n      }\n    }\n\n    return model\n  }\n}\n\nfunction setConcurrencyRequest(request, concurrency = defaultConcurrency) {\n  if (typeof request !== 'function') {\n    throw Error('request must be function')\n  }\n\n  const queue = getRequestQueue(\n    (currentRequest, call) => currentRequest(call),\n    concurrency\n  )()\n\n  return apiArgs => {\n    return new Promise((resolve, reject) => {\n      queue.push(call => {\n        const complete = apiArgs.complete\n  \n        apiArgs.complete = (...args) => {\n          // 请求完成\n          call()\n          if (complete) {\n            complete.constructor === Function && complete.apply(apiArgs, args)\n          }\n        }\n  \n        resolve(request(apiArgs))\n      })\n    })\n  }\n}\n\nmodule.exports = setConcurrencyRequest\n```","slug":"writeSomething/Fetch_3_concurrency","published":1,"updated":"2019-06-13T10:45:18.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwv001cax48vsrygfwf","content":"<p>fetch系列第三篇<code>记录帖</code>，封装一个请求并发控制的库</p>\n<a id=\"more\"></a>\n<p>和各类型拦截器封装的本质一样，通过不直接更改原宿主的形式对原宿主进行包装重写覆盖（或者称之为装饰者模式）</p>\n<p><em>代码由 <code>wx.request</code> 作为示例</em></p>\n<h1 id=\"从使用开始\"><a href=\"#从使用开始\" class=\"headerlink\" title=\"从使用开始\"></a>从使用开始</h1><p>先从使用场景入手，希望引入一个函数可以接受原request方法以及控制的并发数从而返回一个内部可以控制指定并发数的新请求函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wrapper = <span class=\"built_in\">require</span>(<span class=\"string\">'request-concurrency'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> new_fetch = wrapper(fetch, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>所以主要就是处理以下三件事：</p>\n<ol>\n<li>接受原请求方法以及并发数参数</li>\n<li>构建请求派发队列</li>\n<li>对原请求进行包装参数处理</li>\n</ol>\n<h1 id=\"接受原请求方法以及并发数参数\"><a href=\"#接受原请求方法以及并发数参数\" class=\"headerlink\" title=\"接受原请求方法以及并发数参数\"></a>接受原请求方法以及并发数参数</h1><p>接受原请求方法以及并发数参数并返回一个promsie<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向外暴露的接口方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setConcurrencyRequest</span>(<span class=\"params\">request, concurrency = <span class=\"number\">10</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> request !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'request must be function'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 请求队列</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 对外暴露的调用方法</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">apiArgs</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来需要构建请求派发队列，主要分为两部分：执行队列和等待队列</p>\n<h1 id=\"构建请求派发队列\"><a href=\"#构建请求派发队列\" class=\"headerlink\" title=\"构建请求派发队列\"></a>构建请求派发队列</h1><p>用闭包对两个队列分别做存储，用户每次触发客户端请求都会先将请求推入等待队列中，而在执行阶段则主要做两件事情，一是不断将执行队列中的请求派发出去（初始是空），二是不断检查执行队列的长度（并发数），当执行队列的长度在并发数以内则将等待队列中的请求按顺序推入（先入先出）执行队列。</p>\n<p>这里的最重要的地方是执行队列中请求完成的时候返回客户端结果同时将该请求从执行队列中移除。</p>\n<p>也主要有三件事情：</p>\n<ol>\n<li>接受客户端传入的请求推入等待队列 <code>push</code></li>\n<li>派发当前执行队列中的请求 <code>excute</code></li>\n<li>移除执行队列中结束的请求，将等待队列中相应数量的请求按照先进先出的顺序移除并推入执行队列 <code>changeQueue</code></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRequestQueue</span>(<span class=\"params\">call, concurrency</span>) </span>&#123;</span><br><span class=\"line\">  concurrency = concurrency || <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 挂起</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> waitingList = []</span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> executionList = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> model = &#123;</span><br><span class=\"line\">      concurrency,</span><br><span class=\"line\">      push(currentRequest, call) &#123;</span><br><span class=\"line\">        waitingList.push(&#123;</span><br><span class=\"line\">          currentRequest,</span><br><span class=\"line\">          call</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.excute()</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      excute() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.concurrency &gt; executionList.length &amp;&amp; waitingList.length) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将挂起队列中请求推进执行队列</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> apiModel = waitingList.shift()</span><br><span class=\"line\">          executionList.push(apiModel)</span><br><span class=\"line\">          call(</span><br><span class=\"line\">            apiModel.currentRequest,</span><br><span class=\"line\">            setCall(<span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">this</span>.changeQueue(apiModel)</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (apiModel.call) &#123;</span><br><span class=\"line\">                apiModel.call.constructor === <span class=\"built_in\">Function</span> &amp;&amp; apiModel.call(...args)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 发起请求</span></span><br><span class=\"line\">              <span class=\"keyword\">this</span>.excute()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      changeQueue(apiModel) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从执行队列移除</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> index = executionList.indexOf(apiModel)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          executionList.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> model</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"以下为完整代码\"><a href=\"#以下为完整代码\" class=\"headerlink\" title=\"以下为完整代码\"></a>以下为完整代码</h1><p>源码放在：</p>\n<blockquote>\n<p><a href=\"https://github.com/rollawaypoint/request-concurrency/blob/master/lib/index.js\" target=\"_blank\" rel=\"noopener\">https://github.com/rollawaypoint/request-concurrency/blob/master/lib/index.js</a></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defaultConcurrency = <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setConcurrencyCount</span>(<span class=\"params\">concurrency = defaultConcurrency</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> concurrency &amp;&amp; concurrency.constructor === <span class=\"built_in\">Number</span></span><br><span class=\"line\">    ? concurrency</span><br><span class=\"line\">    : defaultConcurrency</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 回调结束置空</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> setCall = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'repeating call has been denied.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> call = fn</span><br><span class=\"line\">  fn = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> call(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRequestQueue</span>(<span class=\"params\">call, concurrency</span>) </span>&#123;</span><br><span class=\"line\">  concurrency = setConcurrencyCount(concurrency)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 挂起</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> waitingList = []</span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> executionList = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> model = &#123;</span><br><span class=\"line\">      concurrency,</span><br><span class=\"line\">      push(currentRequest, call) &#123;</span><br><span class=\"line\">        waitingList.push(&#123;</span><br><span class=\"line\">          currentRequest,</span><br><span class=\"line\">          call</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.excute()</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">      excute() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.concurrency &gt; executionList.length &amp;&amp; waitingList.length) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将挂起队列中请求推进执行队列</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> apiModel = waitingList.shift()</span><br><span class=\"line\"></span><br><span class=\"line\">          executionList.push(apiModel)</span><br><span class=\"line\"></span><br><span class=\"line\">          call(</span><br><span class=\"line\">            apiModel.currentRequest,</span><br><span class=\"line\">            setCall(<span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">this</span>.changeQueue(apiModel)</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (apiModel.call) &#123;</span><br><span class=\"line\">                apiModel.call.constructor === <span class=\"built_in\">Function</span> &amp;&amp; apiModel.call(...args)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 发起请求</span></span><br><span class=\"line\">              <span class=\"keyword\">this</span>.excute()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">      changeQueue(apiModel) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从执行队列移除</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> index = executionList.indexOf(apiModel)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          executionList.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> model</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setConcurrencyRequest</span>(<span class=\"params\">request, concurrency = defaultConcurrency</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> request !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'request must be function'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = getRequestQueue(</span><br><span class=\"line\">    (currentRequest, call) =&gt; currentRequest(call),</span><br><span class=\"line\">    concurrency</span><br><span class=\"line\">  )()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">apiArgs</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      queue.push(<span class=\"function\"><span class=\"params\">call</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> complete = apiArgs.complete</span><br><span class=\"line\">  </span><br><span class=\"line\">        apiArgs.complete = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 请求完成</span></span><br><span class=\"line\">          call()</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (complete) &#123;</span><br><span class=\"line\">            complete.constructor === <span class=\"built_in\">Function</span> &amp;&amp; complete.apply(apiArgs, args)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        resolve(request(apiArgs))</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = setConcurrencyRequest</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>fetch系列第三篇<code>记录帖</code>，封装一个请求并发控制的库</p>","more":"<p>和各类型拦截器封装的本质一样，通过不直接更改原宿主的形式对原宿主进行包装重写覆盖（或者称之为装饰者模式）</p>\n<p><em>代码由 <code>wx.request</code> 作为示例</em></p>\n<h1 id=\"从使用开始\"><a href=\"#从使用开始\" class=\"headerlink\" title=\"从使用开始\"></a>从使用开始</h1><p>先从使用场景入手，希望引入一个函数可以接受原request方法以及控制的并发数从而返回一个内部可以控制指定并发数的新请求函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wrapper = <span class=\"built_in\">require</span>(<span class=\"string\">'request-concurrency'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> new_fetch = wrapper(fetch, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>所以主要就是处理以下三件事：</p>\n<ol>\n<li>接受原请求方法以及并发数参数</li>\n<li>构建请求派发队列</li>\n<li>对原请求进行包装参数处理</li>\n</ol>\n<h1 id=\"接受原请求方法以及并发数参数\"><a href=\"#接受原请求方法以及并发数参数\" class=\"headerlink\" title=\"接受原请求方法以及并发数参数\"></a>接受原请求方法以及并发数参数</h1><p>接受原请求方法以及并发数参数并返回一个promsie<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向外暴露的接口方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setConcurrencyRequest</span>(<span class=\"params\">request, concurrency = <span class=\"number\">10</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> request !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'request must be function'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 请求队列</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 对外暴露的调用方法</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">apiArgs</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来需要构建请求派发队列，主要分为两部分：执行队列和等待队列</p>\n<h1 id=\"构建请求派发队列\"><a href=\"#构建请求派发队列\" class=\"headerlink\" title=\"构建请求派发队列\"></a>构建请求派发队列</h1><p>用闭包对两个队列分别做存储，用户每次触发客户端请求都会先将请求推入等待队列中，而在执行阶段则主要做两件事情，一是不断将执行队列中的请求派发出去（初始是空），二是不断检查执行队列的长度（并发数），当执行队列的长度在并发数以内则将等待队列中的请求按顺序推入（先入先出）执行队列。</p>\n<p>这里的最重要的地方是执行队列中请求完成的时候返回客户端结果同时将该请求从执行队列中移除。</p>\n<p>也主要有三件事情：</p>\n<ol>\n<li>接受客户端传入的请求推入等待队列 <code>push</code></li>\n<li>派发当前执行队列中的请求 <code>excute</code></li>\n<li>移除执行队列中结束的请求，将等待队列中相应数量的请求按照先进先出的顺序移除并推入执行队列 <code>changeQueue</code></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRequestQueue</span>(<span class=\"params\">call, concurrency</span>) </span>&#123;</span><br><span class=\"line\">  concurrency = concurrency || <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 挂起</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> waitingList = []</span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> executionList = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> model = &#123;</span><br><span class=\"line\">      concurrency,</span><br><span class=\"line\">      push(currentRequest, call) &#123;</span><br><span class=\"line\">        waitingList.push(&#123;</span><br><span class=\"line\">          currentRequest,</span><br><span class=\"line\">          call</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.excute()</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      excute() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.concurrency &gt; executionList.length &amp;&amp; waitingList.length) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将挂起队列中请求推进执行队列</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> apiModel = waitingList.shift()</span><br><span class=\"line\">          executionList.push(apiModel)</span><br><span class=\"line\">          call(</span><br><span class=\"line\">            apiModel.currentRequest,</span><br><span class=\"line\">            setCall(<span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">this</span>.changeQueue(apiModel)</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (apiModel.call) &#123;</span><br><span class=\"line\">                apiModel.call.constructor === <span class=\"built_in\">Function</span> &amp;&amp; apiModel.call(...args)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 发起请求</span></span><br><span class=\"line\">              <span class=\"keyword\">this</span>.excute()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      changeQueue(apiModel) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从执行队列移除</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> index = executionList.indexOf(apiModel)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          executionList.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> model</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"以下为完整代码\"><a href=\"#以下为完整代码\" class=\"headerlink\" title=\"以下为完整代码\"></a>以下为完整代码</h1><p>源码放在：</p>\n<blockquote>\n<p><a href=\"https://github.com/rollawaypoint/request-concurrency/blob/master/lib/index.js\" target=\"_blank\" rel=\"noopener\">https://github.com/rollawaypoint/request-concurrency/blob/master/lib/index.js</a></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defaultConcurrency = <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setConcurrencyCount</span>(<span class=\"params\">concurrency = defaultConcurrency</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> concurrency &amp;&amp; concurrency.constructor === <span class=\"built_in\">Number</span></span><br><span class=\"line\">    ? concurrency</span><br><span class=\"line\">    : defaultConcurrency</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 回调结束置空</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> setCall = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'repeating call has been denied.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> call = fn</span><br><span class=\"line\">  fn = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> call(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRequestQueue</span>(<span class=\"params\">call, concurrency</span>) </span>&#123;</span><br><span class=\"line\">  concurrency = setConcurrencyCount(concurrency)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 挂起</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> waitingList = []</span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> executionList = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> model = &#123;</span><br><span class=\"line\">      concurrency,</span><br><span class=\"line\">      push(currentRequest, call) &#123;</span><br><span class=\"line\">        waitingList.push(&#123;</span><br><span class=\"line\">          currentRequest,</span><br><span class=\"line\">          call</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.excute()</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">      excute() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.concurrency &gt; executionList.length &amp;&amp; waitingList.length) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将挂起队列中请求推进执行队列</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> apiModel = waitingList.shift()</span><br><span class=\"line\"></span><br><span class=\"line\">          executionList.push(apiModel)</span><br><span class=\"line\"></span><br><span class=\"line\">          call(</span><br><span class=\"line\">            apiModel.currentRequest,</span><br><span class=\"line\">            setCall(<span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">this</span>.changeQueue(apiModel)</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (apiModel.call) &#123;</span><br><span class=\"line\">                apiModel.call.constructor === <span class=\"built_in\">Function</span> &amp;&amp; apiModel.call(...args)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 发起请求</span></span><br><span class=\"line\">              <span class=\"keyword\">this</span>.excute()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">      changeQueue(apiModel) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从执行队列移除</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> index = executionList.indexOf(apiModel)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">          executionList.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> model</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setConcurrencyRequest</span>(<span class=\"params\">request, concurrency = defaultConcurrency</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> request !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'request must be function'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = getRequestQueue(</span><br><span class=\"line\">    (currentRequest, call) =&gt; currentRequest(call),</span><br><span class=\"line\">    concurrency</span><br><span class=\"line\">  )()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">apiArgs</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      queue.push(<span class=\"function\"><span class=\"params\">call</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> complete = apiArgs.complete</span><br><span class=\"line\">  </span><br><span class=\"line\">        apiArgs.complete = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 请求完成</span></span><br><span class=\"line\">          call()</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (complete) &#123;</span><br><span class=\"line\">            complete.constructor === <span class=\"built_in\">Function</span> &amp;&amp; complete.apply(apiArgs, args)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        resolve(request(apiArgs))</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = setConcurrencyRequest</span><br></pre></td></tr></table></figure>"},{"title":"壹钱包理财信贷组技术分享","date":"2019-05-24T06:00:00.000Z","_content":"壹钱包理财信贷组技术分享\n\n<!-- more -->\n_拙见_\n\n# 编程在现阶段我们需要注意哪些\n如何在众多的竞争者中找到自己定位并且提升是每个开发都应该思考的问题。\n\n提高编程水平在于四点：\n**Essential things:**\n\n- 提高逻辑能力，培养发散性思维\n\n- 提高架构能力\n\n- 具备更完善的知识体系\n\n- 编写规范的代码\n\n现阶段能做的不多，但把能做的做好就是很大的提升。下面分别以上面四点来具体说我的看法。\n\n# 提高逻辑能力，培养发散性思维\n逻辑能力和发散性思维或许玄学但是却确实是一个很重要的能力。\n\n#### 逻辑能力\n逻辑能力可以通过锻炼来提升，坚持对原理性的东西进行思考，每一个阶段都会发现和上一阶段的差距。三个阶段性建议：\n\n1. 这方面如果大家没有目标推荐大家有空可以去刷LeetCode上的算法，三个级别的难度可以有效地帮助大家对自己的逻辑推理能力进行有效的过渡提升。\n2. 经历第一个阶段后相信会感受到自己和之前的明显差距，这个时候可以看一些比较好的库的源码，试着去debug理解它们的执行（jQuery、vue、react、diff dom、vuex/redux等）\n3. 之后自己尝试封装一些东西的时候可以尝试把之前自己得到的东西加进来，当然可能会四不像，但是拿来主义才是建设“特色社会主义”的核心。\n   \n#### 发散性思维\n要保持**思维的发散**，要保持开放性的思想能接受的看法越多才可以在自己处理问题的时候有更多角度发现问题症结，在实现功能的时候有更全面的考虑，不固执于单一的想法。\n\n# 提高架构能力\n_不沉浸于单纯的业务开发，一切架构基于业务但是单纯的业务开发只是无限次的进行重复劳动而与架构背离。_\n\n架构能力也是一个指标，类似于大家在抽离一个组件、封装一个工具类等的时候可以体现开发者的构思能力和技巧。\n\n#### 强内聚&弱耦合\n软件工程中有个常说的概念叫做**强内聚弱耦合**。简单解释一下这两个概念。\n  - **强内聚**就是指一个功能不随意受外部状态变化的而影响自身，这样可以保证这个功能的可控和结果可预判性。\n  - **弱耦合**就是各个功能点之间的联系要尽可能的被弱化，例如A功能如果是实现B功能的必要条件当A不可用即代表B不可用，弱耦合正是弱化这种关联的设计，可以需要彼此但不是必须依赖彼此。\n\n#### 组件\n组件抽离的好不好在于是否高度可复用、组件内状态是否易于维护等，而这些都是考验开发者在设计这个组件的时候是否有良好的构思和设计。\n函数式编程中有纯函数pure function（函子）的概念，所谓纯函数就是指不受外部状态所影响一切输出在预期的函数。在react中有个高阶函数（HOC）的概念（react上手不久，说的不对记得纠正！！！），在于接受一个纯函数组件作为参数，控制纯函数组件的状态后返回新的组件。而这个纯函数组件（dumb）和高阶组件之间就属于一个解耦，dumb组件和HOC组件之间的职能分别赋予控制视图（view）和数据状态（state）层，而这个解耦就将dumb组件变为一个更易复用的状态。\n\n#### 函数\n封装一个简单的工具函数的时候主要考虑哪些东西？\n  - 易于调用\n  - 性能\n  - 异常兼容\n\n1. 首先封装一个工具函数前肯定已经考虑的这个函数的使用方式和使用场景，它应该是易于调用的（调用都显得麻烦也不能称之为封装233）\n2. 性能无需格外陈述利害，函数运行的效率很多时候可能在体验上体现出不是一个量级的差距（如函数的递归和尾递归之间调用栈的变更）\n3. 异常兼容在于基本的如参数往往是不可控的是否有兼容判断，函数内部逻辑代码是否考虑全面避免异常等\n\n#### 设计模式\n拥有一定的架构能力后就会了解到设计模式这个概念，抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位，常规的软件设计模式有23种，部分开发中常用的具体查看[JS常用的设计模式](https://rollawaypoint.github.io/2019/02/24/writeSomething/jsDesignPattern/)\n\n# 具备更完善的知识体系\n_点成线、线成面、面成体_\n\n我们需要无数的知识点才能构成相对完整的知识面，而完善的知识体系需要的更多。当然我们并不真的需要所有的知识来构建我们知识体系，我们需要的是相关的技术范围内的知识脉络体系，就像很多人入门编程时候的学习顺序。\n\n相关领域内相对健全完善的知识体系可以极大提高这个人看问题的维度（多角度多领域）。\n\n举个🌰：有人在讨论react的状态管理工具redux的connect是如何工作的，会联想到什么呢？\n\nredux connect-> compose、reduce -> 类函数式编程？ -> koa middleware -> 洋葱模型 -> eggjs middleware\n\n而一个完善的知识脉络体系需要我们自己去填充。\n\n# 编写规范的代码\n编码规范属于相对的说法，不同公司甚至团队可能会有不同的属于自己的规范，但是大的方向上大都一致。\n\n- 简约\n- 易读\n- 可控\n- 易维护\n- etc.\n\n简约不意味着简单，需要较好的编程功底，代码简洁易读，保证代码关键字注释（常量、功能函数等）。代码数据结构构建合理，返回结果可预测。易于后续人员维护。\n\n开发规范比较笼统且条框限制特别多，不是从0组建的team也就没有必要从0定义一个全面的约束规定。现在从已有项目的部分代码中发现存在的不规范写法进行简单约束一下今后相关的编码书写规范。\n\n1. 单文件大小限制\n本质上没有严格限制但是要尽量条理分明\n超过500（Random）行代码检查是否有的功能是可以抽离成单独逻辑处理脚本的（组件抽离不必说）\n\n2. 组件的render内的return语句中应该只包含渲染，业务逻辑、数据判断、函数调用传参控制等提到外面\n\n3. 不依靠view-viewModel的数据尽量不要挂载在this上，单独作为变量\n\n4. 使用if语句遵循尽早return避免嵌套的原则\n\n5. promise链应保证纯净避免大量在callback中直接使用Promise.resolve()(reject)\n当前如果处于promise链内（fetch内） return res代替 return Promise.resolve(res)\n抛出异常 throw res 代替 return Promise.reject(res)\n\n6. 避免DRY，重复性的工作一定做好封装和抽离\n\n7. 根据自己业务逻辑合理构建数据结构\n\nopen、real！peace!\n","source":"_posts/writeSomething/Programming2Advanced.md","raw":"---\ntitle: 壹钱包理财信贷组技术分享\ntags:\n  - 技术分享\ndate: 2019-05-24 14:00:00\ncategories: 技术分享\n---\n壹钱包理财信贷组技术分享\n\n<!-- more -->\n_拙见_\n\n# 编程在现阶段我们需要注意哪些\n如何在众多的竞争者中找到自己定位并且提升是每个开发都应该思考的问题。\n\n提高编程水平在于四点：\n**Essential things:**\n\n- 提高逻辑能力，培养发散性思维\n\n- 提高架构能力\n\n- 具备更完善的知识体系\n\n- 编写规范的代码\n\n现阶段能做的不多，但把能做的做好就是很大的提升。下面分别以上面四点来具体说我的看法。\n\n# 提高逻辑能力，培养发散性思维\n逻辑能力和发散性思维或许玄学但是却确实是一个很重要的能力。\n\n#### 逻辑能力\n逻辑能力可以通过锻炼来提升，坚持对原理性的东西进行思考，每一个阶段都会发现和上一阶段的差距。三个阶段性建议：\n\n1. 这方面如果大家没有目标推荐大家有空可以去刷LeetCode上的算法，三个级别的难度可以有效地帮助大家对自己的逻辑推理能力进行有效的过渡提升。\n2. 经历第一个阶段后相信会感受到自己和之前的明显差距，这个时候可以看一些比较好的库的源码，试着去debug理解它们的执行（jQuery、vue、react、diff dom、vuex/redux等）\n3. 之后自己尝试封装一些东西的时候可以尝试把之前自己得到的东西加进来，当然可能会四不像，但是拿来主义才是建设“特色社会主义”的核心。\n   \n#### 发散性思维\n要保持**思维的发散**，要保持开放性的思想能接受的看法越多才可以在自己处理问题的时候有更多角度发现问题症结，在实现功能的时候有更全面的考虑，不固执于单一的想法。\n\n# 提高架构能力\n_不沉浸于单纯的业务开发，一切架构基于业务但是单纯的业务开发只是无限次的进行重复劳动而与架构背离。_\n\n架构能力也是一个指标，类似于大家在抽离一个组件、封装一个工具类等的时候可以体现开发者的构思能力和技巧。\n\n#### 强内聚&弱耦合\n软件工程中有个常说的概念叫做**强内聚弱耦合**。简单解释一下这两个概念。\n  - **强内聚**就是指一个功能不随意受外部状态变化的而影响自身，这样可以保证这个功能的可控和结果可预判性。\n  - **弱耦合**就是各个功能点之间的联系要尽可能的被弱化，例如A功能如果是实现B功能的必要条件当A不可用即代表B不可用，弱耦合正是弱化这种关联的设计，可以需要彼此但不是必须依赖彼此。\n\n#### 组件\n组件抽离的好不好在于是否高度可复用、组件内状态是否易于维护等，而这些都是考验开发者在设计这个组件的时候是否有良好的构思和设计。\n函数式编程中有纯函数pure function（函子）的概念，所谓纯函数就是指不受外部状态所影响一切输出在预期的函数。在react中有个高阶函数（HOC）的概念（react上手不久，说的不对记得纠正！！！），在于接受一个纯函数组件作为参数，控制纯函数组件的状态后返回新的组件。而这个纯函数组件（dumb）和高阶组件之间就属于一个解耦，dumb组件和HOC组件之间的职能分别赋予控制视图（view）和数据状态（state）层，而这个解耦就将dumb组件变为一个更易复用的状态。\n\n#### 函数\n封装一个简单的工具函数的时候主要考虑哪些东西？\n  - 易于调用\n  - 性能\n  - 异常兼容\n\n1. 首先封装一个工具函数前肯定已经考虑的这个函数的使用方式和使用场景，它应该是易于调用的（调用都显得麻烦也不能称之为封装233）\n2. 性能无需格外陈述利害，函数运行的效率很多时候可能在体验上体现出不是一个量级的差距（如函数的递归和尾递归之间调用栈的变更）\n3. 异常兼容在于基本的如参数往往是不可控的是否有兼容判断，函数内部逻辑代码是否考虑全面避免异常等\n\n#### 设计模式\n拥有一定的架构能力后就会了解到设计模式这个概念，抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位，常规的软件设计模式有23种，部分开发中常用的具体查看[JS常用的设计模式](https://rollawaypoint.github.io/2019/02/24/writeSomething/jsDesignPattern/)\n\n# 具备更完善的知识体系\n_点成线、线成面、面成体_\n\n我们需要无数的知识点才能构成相对完整的知识面，而完善的知识体系需要的更多。当然我们并不真的需要所有的知识来构建我们知识体系，我们需要的是相关的技术范围内的知识脉络体系，就像很多人入门编程时候的学习顺序。\n\n相关领域内相对健全完善的知识体系可以极大提高这个人看问题的维度（多角度多领域）。\n\n举个🌰：有人在讨论react的状态管理工具redux的connect是如何工作的，会联想到什么呢？\n\nredux connect-> compose、reduce -> 类函数式编程？ -> koa middleware -> 洋葱模型 -> eggjs middleware\n\n而一个完善的知识脉络体系需要我们自己去填充。\n\n# 编写规范的代码\n编码规范属于相对的说法，不同公司甚至团队可能会有不同的属于自己的规范，但是大的方向上大都一致。\n\n- 简约\n- 易读\n- 可控\n- 易维护\n- etc.\n\n简约不意味着简单，需要较好的编程功底，代码简洁易读，保证代码关键字注释（常量、功能函数等）。代码数据结构构建合理，返回结果可预测。易于后续人员维护。\n\n开发规范比较笼统且条框限制特别多，不是从0组建的team也就没有必要从0定义一个全面的约束规定。现在从已有项目的部分代码中发现存在的不规范写法进行简单约束一下今后相关的编码书写规范。\n\n1. 单文件大小限制\n本质上没有严格限制但是要尽量条理分明\n超过500（Random）行代码检查是否有的功能是可以抽离成单独逻辑处理脚本的（组件抽离不必说）\n\n2. 组件的render内的return语句中应该只包含渲染，业务逻辑、数据判断、函数调用传参控制等提到外面\n\n3. 不依靠view-viewModel的数据尽量不要挂载在this上，单独作为变量\n\n4. 使用if语句遵循尽早return避免嵌套的原则\n\n5. promise链应保证纯净避免大量在callback中直接使用Promise.resolve()(reject)\n当前如果处于promise链内（fetch内） return res代替 return Promise.resolve(res)\n抛出异常 throw res 代替 return Promise.reject(res)\n\n6. 避免DRY，重复性的工作一定做好封装和抽离\n\n7. 根据自己业务逻辑合理构建数据结构\n\nopen、real！peace!\n","slug":"writeSomething/Programming2Advanced","published":1,"updated":"2019-05-23T09:49:23.386Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxww001eax48ulkvm0wk","content":"<p>壹钱包理财信贷组技术分享</p>\n<a id=\"more\"></a>\n<p>_拙见_</p>\n<h1 id=\"编程在现阶段我们需要注意哪些\"><a href=\"#编程在现阶段我们需要注意哪些\" class=\"headerlink\" title=\"编程在现阶段我们需要注意哪些\"></a>编程在现阶段我们需要注意哪些</h1><p>如何在众多的竞争者中找到自己定位并且提升是每个开发都应该思考的问题。</p>\n<p>提高编程水平在于四点：<br><strong>Essential things:</strong></p>\n<ul>\n<li><p>提高逻辑能力，培养发散性思维</p>\n</li>\n<li><p>提高架构能力</p>\n</li>\n<li><p>具备更完善的知识体系</p>\n</li>\n<li><p>编写规范的代码</p>\n</li>\n</ul>\n<p>现阶段能做的不多，但把能做的做好就是很大的提升。下面分别以上面四点来具体说我的看法。</p>\n<h1 id=\"提高逻辑能力，培养发散性思维\"><a href=\"#提高逻辑能力，培养发散性思维\" class=\"headerlink\" title=\"提高逻辑能力，培养发散性思维\"></a>提高逻辑能力，培养发散性思维</h1><p>逻辑能力和发散性思维或许玄学但是却确实是一个很重要的能力。</p>\n<h4 id=\"逻辑能力\"><a href=\"#逻辑能力\" class=\"headerlink\" title=\"逻辑能力\"></a>逻辑能力</h4><p>逻辑能力可以通过锻炼来提升，坚持对原理性的东西进行思考，每一个阶段都会发现和上一阶段的差距。三个阶段性建议：</p>\n<ol>\n<li>这方面如果大家没有目标推荐大家有空可以去刷LeetCode上的算法，三个级别的难度可以有效地帮助大家对自己的逻辑推理能力进行有效的过渡提升。</li>\n<li>经历第一个阶段后相信会感受到自己和之前的明显差距，这个时候可以看一些比较好的库的源码，试着去debug理解它们的执行（jQuery、vue、react、diff dom、vuex/redux等）</li>\n<li>之后自己尝试封装一些东西的时候可以尝试把之前自己得到的东西加进来，当然可能会四不像，但是拿来主义才是建设“特色社会主义”的核心。</li>\n</ol>\n<h4 id=\"发散性思维\"><a href=\"#发散性思维\" class=\"headerlink\" title=\"发散性思维\"></a>发散性思维</h4><p>要保持<strong>思维的发散</strong>，要保持开放性的思想能接受的看法越多才可以在自己处理问题的时候有更多角度发现问题症结，在实现功能的时候有更全面的考虑，不固执于单一的想法。</p>\n<h1 id=\"提高架构能力\"><a href=\"#提高架构能力\" class=\"headerlink\" title=\"提高架构能力\"></a>提高架构能力</h1><p><em>不沉浸于单纯的业务开发，一切架构基于业务但是单纯的业务开发只是无限次的进行重复劳动而与架构背离。</em></p>\n<p>架构能力也是一个指标，类似于大家在抽离一个组件、封装一个工具类等的时候可以体现开发者的构思能力和技巧。</p>\n<h4 id=\"强内聚-amp-弱耦合\"><a href=\"#强内聚-amp-弱耦合\" class=\"headerlink\" title=\"强内聚&amp;弱耦合\"></a>强内聚&amp;弱耦合</h4><p>软件工程中有个常说的概念叫做<strong>强内聚弱耦合</strong>。简单解释一下这两个概念。</p>\n<ul>\n<li><strong>强内聚</strong>就是指一个功能不随意受外部状态变化的而影响自身，这样可以保证这个功能的可控和结果可预判性。</li>\n<li><strong>弱耦合</strong>就是各个功能点之间的联系要尽可能的被弱化，例如A功能如果是实现B功能的必要条件当A不可用即代表B不可用，弱耦合正是弱化这种关联的设计，可以需要彼此但不是必须依赖彼此。</li>\n</ul>\n<h4 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h4><p>组件抽离的好不好在于是否高度可复用、组件内状态是否易于维护等，而这些都是考验开发者在设计这个组件的时候是否有良好的构思和设计。<br>函数式编程中有纯函数pure function（函子）的概念，所谓纯函数就是指不受外部状态所影响一切输出在预期的函数。在react中有个高阶函数（HOC）的概念（react上手不久，说的不对记得纠正！！！），在于接受一个纯函数组件作为参数，控制纯函数组件的状态后返回新的组件。而这个纯函数组件（dumb）和高阶组件之间就属于一个解耦，dumb组件和HOC组件之间的职能分别赋予控制视图（view）和数据状态（state）层，而这个解耦就将dumb组件变为一个更易复用的状态。</p>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><p>封装一个简单的工具函数的时候主要考虑哪些东西？</p>\n<ul>\n<li>易于调用</li>\n<li>性能</li>\n<li>异常兼容</li>\n</ul>\n<ol>\n<li>首先封装一个工具函数前肯定已经考虑的这个函数的使用方式和使用场景，它应该是易于调用的（调用都显得麻烦也不能称之为封装233）</li>\n<li>性能无需格外陈述利害，函数运行的效率很多时候可能在体验上体现出不是一个量级的差距（如函数的递归和尾递归之间调用栈的变更）</li>\n<li>异常兼容在于基本的如参数往往是不可控的是否有兼容判断，函数内部逻辑代码是否考虑全面避免异常等</li>\n</ol>\n<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h4><p>拥有一定的架构能力后就会了解到设计模式这个概念，抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位，常规的软件设计模式有23种，部分开发中常用的具体查看<a href=\"https://rollawaypoint.github.io/2019/02/24/writeSomething/jsDesignPattern/\">JS常用的设计模式</a></p>\n<h1 id=\"具备更完善的知识体系\"><a href=\"#具备更完善的知识体系\" class=\"headerlink\" title=\"具备更完善的知识体系\"></a>具备更完善的知识体系</h1><p><em>点成线、线成面、面成体</em></p>\n<p>我们需要无数的知识点才能构成相对完整的知识面，而完善的知识体系需要的更多。当然我们并不真的需要所有的知识来构建我们知识体系，我们需要的是相关的技术范围内的知识脉络体系，就像很多人入门编程时候的学习顺序。</p>\n<p>相关领域内相对健全完善的知识体系可以极大提高这个人看问题的维度（多角度多领域）。</p>\n<p>举个🌰：有人在讨论react的状态管理工具redux的connect是如何工作的，会联想到什么呢？</p>\n<p>redux connect-&gt; compose、reduce -&gt; 类函数式编程？ -&gt; koa middleware -&gt; 洋葱模型 -&gt; eggjs middleware</p>\n<p>而一个完善的知识脉络体系需要我们自己去填充。</p>\n<h1 id=\"编写规范的代码\"><a href=\"#编写规范的代码\" class=\"headerlink\" title=\"编写规范的代码\"></a>编写规范的代码</h1><p>编码规范属于相对的说法，不同公司甚至团队可能会有不同的属于自己的规范，但是大的方向上大都一致。</p>\n<ul>\n<li>简约</li>\n<li>易读</li>\n<li>可控</li>\n<li>易维护</li>\n<li>etc.</li>\n</ul>\n<p>简约不意味着简单，需要较好的编程功底，代码简洁易读，保证代码关键字注释（常量、功能函数等）。代码数据结构构建合理，返回结果可预测。易于后续人员维护。</p>\n<p>开发规范比较笼统且条框限制特别多，不是从0组建的team也就没有必要从0定义一个全面的约束规定。现在从已有项目的部分代码中发现存在的不规范写法进行简单约束一下今后相关的编码书写规范。</p>\n<ol>\n<li><p>单文件大小限制<br>本质上没有严格限制但是要尽量条理分明<br>超过500（Random）行代码检查是否有的功能是可以抽离成单独逻辑处理脚本的（组件抽离不必说）</p>\n</li>\n<li><p>组件的render内的return语句中应该只包含渲染，业务逻辑、数据判断、函数调用传参控制等提到外面</p>\n</li>\n<li><p>不依靠view-viewModel的数据尽量不要挂载在this上，单独作为变量</p>\n</li>\n<li><p>使用if语句遵循尽早return避免嵌套的原则</p>\n</li>\n<li><p>promise链应保证纯净避免大量在callback中直接使用Promise.resolve()(reject)<br>当前如果处于promise链内（fetch内） return res代替 return Promise.resolve(res)<br>抛出异常 throw res 代替 return Promise.reject(res)</p>\n</li>\n<li><p>避免DRY，重复性的工作一定做好封装和抽离</p>\n</li>\n<li><p>根据自己业务逻辑合理构建数据结构</p>\n</li>\n</ol>\n<p>open、real！peace!</p>\n","site":{"data":{}},"excerpt":"<p>壹钱包理财信贷组技术分享</p>","more":"<p>_拙见_</p>\n<h1 id=\"编程在现阶段我们需要注意哪些\"><a href=\"#编程在现阶段我们需要注意哪些\" class=\"headerlink\" title=\"编程在现阶段我们需要注意哪些\"></a>编程在现阶段我们需要注意哪些</h1><p>如何在众多的竞争者中找到自己定位并且提升是每个开发都应该思考的问题。</p>\n<p>提高编程水平在于四点：<br><strong>Essential things:</strong></p>\n<ul>\n<li><p>提高逻辑能力，培养发散性思维</p>\n</li>\n<li><p>提高架构能力</p>\n</li>\n<li><p>具备更完善的知识体系</p>\n</li>\n<li><p>编写规范的代码</p>\n</li>\n</ul>\n<p>现阶段能做的不多，但把能做的做好就是很大的提升。下面分别以上面四点来具体说我的看法。</p>\n<h1 id=\"提高逻辑能力，培养发散性思维\"><a href=\"#提高逻辑能力，培养发散性思维\" class=\"headerlink\" title=\"提高逻辑能力，培养发散性思维\"></a>提高逻辑能力，培养发散性思维</h1><p>逻辑能力和发散性思维或许玄学但是却确实是一个很重要的能力。</p>\n<h4 id=\"逻辑能力\"><a href=\"#逻辑能力\" class=\"headerlink\" title=\"逻辑能力\"></a>逻辑能力</h4><p>逻辑能力可以通过锻炼来提升，坚持对原理性的东西进行思考，每一个阶段都会发现和上一阶段的差距。三个阶段性建议：</p>\n<ol>\n<li>这方面如果大家没有目标推荐大家有空可以去刷LeetCode上的算法，三个级别的难度可以有效地帮助大家对自己的逻辑推理能力进行有效的过渡提升。</li>\n<li>经历第一个阶段后相信会感受到自己和之前的明显差距，这个时候可以看一些比较好的库的源码，试着去debug理解它们的执行（jQuery、vue、react、diff dom、vuex/redux等）</li>\n<li>之后自己尝试封装一些东西的时候可以尝试把之前自己得到的东西加进来，当然可能会四不像，但是拿来主义才是建设“特色社会主义”的核心。</li>\n</ol>\n<h4 id=\"发散性思维\"><a href=\"#发散性思维\" class=\"headerlink\" title=\"发散性思维\"></a>发散性思维</h4><p>要保持<strong>思维的发散</strong>，要保持开放性的思想能接受的看法越多才可以在自己处理问题的时候有更多角度发现问题症结，在实现功能的时候有更全面的考虑，不固执于单一的想法。</p>\n<h1 id=\"提高架构能力\"><a href=\"#提高架构能力\" class=\"headerlink\" title=\"提高架构能力\"></a>提高架构能力</h1><p><em>不沉浸于单纯的业务开发，一切架构基于业务但是单纯的业务开发只是无限次的进行重复劳动而与架构背离。</em></p>\n<p>架构能力也是一个指标，类似于大家在抽离一个组件、封装一个工具类等的时候可以体现开发者的构思能力和技巧。</p>\n<h4 id=\"强内聚-amp-弱耦合\"><a href=\"#强内聚-amp-弱耦合\" class=\"headerlink\" title=\"强内聚&amp;弱耦合\"></a>强内聚&amp;弱耦合</h4><p>软件工程中有个常说的概念叫做<strong>强内聚弱耦合</strong>。简单解释一下这两个概念。</p>\n<ul>\n<li><strong>强内聚</strong>就是指一个功能不随意受外部状态变化的而影响自身，这样可以保证这个功能的可控和结果可预判性。</li>\n<li><strong>弱耦合</strong>就是各个功能点之间的联系要尽可能的被弱化，例如A功能如果是实现B功能的必要条件当A不可用即代表B不可用，弱耦合正是弱化这种关联的设计，可以需要彼此但不是必须依赖彼此。</li>\n</ul>\n<h4 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h4><p>组件抽离的好不好在于是否高度可复用、组件内状态是否易于维护等，而这些都是考验开发者在设计这个组件的时候是否有良好的构思和设计。<br>函数式编程中有纯函数pure function（函子）的概念，所谓纯函数就是指不受外部状态所影响一切输出在预期的函数。在react中有个高阶函数（HOC）的概念（react上手不久，说的不对记得纠正！！！），在于接受一个纯函数组件作为参数，控制纯函数组件的状态后返回新的组件。而这个纯函数组件（dumb）和高阶组件之间就属于一个解耦，dumb组件和HOC组件之间的职能分别赋予控制视图（view）和数据状态（state）层，而这个解耦就将dumb组件变为一个更易复用的状态。</p>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><p>封装一个简单的工具函数的时候主要考虑哪些东西？</p>\n<ul>\n<li>易于调用</li>\n<li>性能</li>\n<li>异常兼容</li>\n</ul>\n<ol>\n<li>首先封装一个工具函数前肯定已经考虑的这个函数的使用方式和使用场景，它应该是易于调用的（调用都显得麻烦也不能称之为封装233）</li>\n<li>性能无需格外陈述利害，函数运行的效率很多时候可能在体验上体现出不是一个量级的差距（如函数的递归和尾递归之间调用栈的变更）</li>\n<li>异常兼容在于基本的如参数往往是不可控的是否有兼容判断，函数内部逻辑代码是否考虑全面避免异常等</li>\n</ol>\n<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h4><p>拥有一定的架构能力后就会了解到设计模式这个概念，抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位，常规的软件设计模式有23种，部分开发中常用的具体查看<a href=\"https://rollawaypoint.github.io/2019/02/24/writeSomething/jsDesignPattern/\">JS常用的设计模式</a></p>\n<h1 id=\"具备更完善的知识体系\"><a href=\"#具备更完善的知识体系\" class=\"headerlink\" title=\"具备更完善的知识体系\"></a>具备更完善的知识体系</h1><p><em>点成线、线成面、面成体</em></p>\n<p>我们需要无数的知识点才能构成相对完整的知识面，而完善的知识体系需要的更多。当然我们并不真的需要所有的知识来构建我们知识体系，我们需要的是相关的技术范围内的知识脉络体系，就像很多人入门编程时候的学习顺序。</p>\n<p>相关领域内相对健全完善的知识体系可以极大提高这个人看问题的维度（多角度多领域）。</p>\n<p>举个🌰：有人在讨论react的状态管理工具redux的connect是如何工作的，会联想到什么呢？</p>\n<p>redux connect-&gt; compose、reduce -&gt; 类函数式编程？ -&gt; koa middleware -&gt; 洋葱模型 -&gt; eggjs middleware</p>\n<p>而一个完善的知识脉络体系需要我们自己去填充。</p>\n<h1 id=\"编写规范的代码\"><a href=\"#编写规范的代码\" class=\"headerlink\" title=\"编写规范的代码\"></a>编写规范的代码</h1><p>编码规范属于相对的说法，不同公司甚至团队可能会有不同的属于自己的规范，但是大的方向上大都一致。</p>\n<ul>\n<li>简约</li>\n<li>易读</li>\n<li>可控</li>\n<li>易维护</li>\n<li>etc.</li>\n</ul>\n<p>简约不意味着简单，需要较好的编程功底，代码简洁易读，保证代码关键字注释（常量、功能函数等）。代码数据结构构建合理，返回结果可预测。易于后续人员维护。</p>\n<p>开发规范比较笼统且条框限制特别多，不是从0组建的team也就没有必要从0定义一个全面的约束规定。现在从已有项目的部分代码中发现存在的不规范写法进行简单约束一下今后相关的编码书写规范。</p>\n<ol>\n<li><p>单文件大小限制<br>本质上没有严格限制但是要尽量条理分明<br>超过500（Random）行代码检查是否有的功能是可以抽离成单独逻辑处理脚本的（组件抽离不必说）</p>\n</li>\n<li><p>组件的render内的return语句中应该只包含渲染，业务逻辑、数据判断、函数调用传参控制等提到外面</p>\n</li>\n<li><p>不依靠view-viewModel的数据尽量不要挂载在this上，单独作为变量</p>\n</li>\n<li><p>使用if语句遵循尽早return避免嵌套的原则</p>\n</li>\n<li><p>promise链应保证纯净避免大量在callback中直接使用Promise.resolve()(reject)<br>当前如果处于promise链内（fetch内） return res代替 return Promise.resolve(res)<br>抛出异常 throw res 代替 return Promise.reject(res)</p>\n</li>\n<li><p>避免DRY，重复性的工作一定做好封装和抽离</p>\n</li>\n<li><p>根据自己业务逻辑合理构建数据结构</p>\n</li>\n</ol>\n<p>open、real！peace!</p>"},{"title":"开发环境搭建","date":"2019-04-03T05:27:00.000Z","_content":"\n入手新的mac？快速搭建你的开发环境！👏\n<!-- more -->\n\n# 开机\nahhhh\n\n# Node\n[Node最新版本下载地址：](https://nodejs.org/en/)，Current 或者 LTS 版本的 Node 看自己的需求选一个囖\n\n# nrm\nnpm包管理器会捆绑安装的Node中，但是有时候我们会需要用到管理npm源的需要的，如果可能会有多个源自己设置 registry 是不是很麻烦呢\n下载nrm吧，非常好用\n```bash\n# 安装\nsudo npm install nrm -g\n\n# 查看当前的源列表（带*为正在使用）\nnrm ls\n\n# 添加源\nnrm add [源名字] [源地址]\n\n# 删除源\nnrm del [源名字]\n\n# 切换源\nnrm use [源名字]\n\n# 测试源响应时间\nnrm test [源名字]\n```\n\n# cnpm\n网络xxx，加个淘宝npm镜像吧，定时同步\n```bash\nsudo npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n这里是添加了一个 `cnpm` 的命令行工具，使用方式和 npm 完全一致，会自动添加到nrm中，但是有上面的 nrm, 完全可以自己不使用cnpm，直接加在自己的源列表里面也是可以的\n```bash\nnrm add cnpm https://registry.npm.taobao.org\n```\n\n# git\n下载并安装git：[https://git-scm.com/](https://git-scm.com/)\n\n# homebrew\nHomebrew是一个包管理器，用于安装需要的UNIX工具类似wget，也可以安装nginx、yarn之类的服务服务和工具\n\n安装XCode或者Command Line Tools for Xcode。Xcode可以从AppStore里下载安装\n或者安装 Command Line Tools for Xcode：\n```bash\nxcode-select --install\n```\n安装Homebrew\n```bash\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n使用：\n```bash\n# 搜索包\nbrew search [包名]\n\n# 安装包\nbrew install [包名]\n\n# 查看包信息，比如目前的版本，依赖，安装后注意事项等\nbrew info [包名]\n\n# 卸载包\nbrew uninstall [包名]\n\n# 显示已安装的包\nbrew list\n\n# 查看brew的帮助\nbrew –help\n\n# 更新， 这会更新 Homebrew 自己\nbrew update\n\n# 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级\nbrew outdated\nbrew outdated [包名]\n\n# 升级所有可以升级的软件们\nbrew upgrade\nbrew upgrade [包名]\n\n# 清理不需要的版本极其安装包缓存\nbrew cleanup\nbrew cleanup [包名]\n```\n\n# yarn\nYarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快\n可以使用homebrew：\n```bash\nbrew install yarn\n```\n也可以使用npm：\n```bash\nsudo npm i yarn -g\n```\n\n# oh my zsh + item2\nmac岂可无顺眼的终端\n\n查看当前拥有哪些终端：\n```bash\ncat /etc/shells\n```\n查看正在使用的终端：\n```bash\necho $SHELL\n```\n切换终端为zsh：\n```bash\nchsh -s /bin/zsh\n```\n安装 oh my zsh：\n```bash\nsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n#### 配置 zsh 插件\n这里推荐我用的三个\n\n安装zsh-autosuggestions（命令推荐）:\n```bash\ngit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n```\n安装zsh-syntax-highlighting（命令高亮）：\n```bash\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git \n```\n安装autojump（记录命令操作，使用j快捷跳转）：\n```bash\ngit clone git://github.com/joelthelion/autojump.git\ncd autojump\n./install.py\n```\n最后在 ~/.zshrc 中配置插件和主题，主题可以自行选择，有很多种类：\n```bash\n# 主题配置\nZSH_THEME=ys\n# 插件配置\nplugins=(\n git\n autojump\n zsh-autosuggestions\n zsh-syntax-highlighting\n)\n```\n\n最后下载一款 iterm2 的终端代替mac自带的：\n直接下载安装：[http://iterm2.com/ ](http://iterm2.com/)\n设为默认：\niTerm2 -> Make iTerm2 Default Term\n\n","source":"_posts/writeSomething/WorkEnvConfig.md","raw":"---\ntitle: 开发环境搭建\ntags:\n  - 开发环境搭建\ndate: 2019-04-03 13:27:00\ncategories: 开发环境搭建\n---\n\n入手新的mac？快速搭建你的开发环境！👏\n<!-- more -->\n\n# 开机\nahhhh\n\n# Node\n[Node最新版本下载地址：](https://nodejs.org/en/)，Current 或者 LTS 版本的 Node 看自己的需求选一个囖\n\n# nrm\nnpm包管理器会捆绑安装的Node中，但是有时候我们会需要用到管理npm源的需要的，如果可能会有多个源自己设置 registry 是不是很麻烦呢\n下载nrm吧，非常好用\n```bash\n# 安装\nsudo npm install nrm -g\n\n# 查看当前的源列表（带*为正在使用）\nnrm ls\n\n# 添加源\nnrm add [源名字] [源地址]\n\n# 删除源\nnrm del [源名字]\n\n# 切换源\nnrm use [源名字]\n\n# 测试源响应时间\nnrm test [源名字]\n```\n\n# cnpm\n网络xxx，加个淘宝npm镜像吧，定时同步\n```bash\nsudo npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n这里是添加了一个 `cnpm` 的命令行工具，使用方式和 npm 完全一致，会自动添加到nrm中，但是有上面的 nrm, 完全可以自己不使用cnpm，直接加在自己的源列表里面也是可以的\n```bash\nnrm add cnpm https://registry.npm.taobao.org\n```\n\n# git\n下载并安装git：[https://git-scm.com/](https://git-scm.com/)\n\n# homebrew\nHomebrew是一个包管理器，用于安装需要的UNIX工具类似wget，也可以安装nginx、yarn之类的服务服务和工具\n\n安装XCode或者Command Line Tools for Xcode。Xcode可以从AppStore里下载安装\n或者安装 Command Line Tools for Xcode：\n```bash\nxcode-select --install\n```\n安装Homebrew\n```bash\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n使用：\n```bash\n# 搜索包\nbrew search [包名]\n\n# 安装包\nbrew install [包名]\n\n# 查看包信息，比如目前的版本，依赖，安装后注意事项等\nbrew info [包名]\n\n# 卸载包\nbrew uninstall [包名]\n\n# 显示已安装的包\nbrew list\n\n# 查看brew的帮助\nbrew –help\n\n# 更新， 这会更新 Homebrew 自己\nbrew update\n\n# 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级\nbrew outdated\nbrew outdated [包名]\n\n# 升级所有可以升级的软件们\nbrew upgrade\nbrew upgrade [包名]\n\n# 清理不需要的版本极其安装包缓存\nbrew cleanup\nbrew cleanup [包名]\n```\n\n# yarn\nYarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快\n可以使用homebrew：\n```bash\nbrew install yarn\n```\n也可以使用npm：\n```bash\nsudo npm i yarn -g\n```\n\n# oh my zsh + item2\nmac岂可无顺眼的终端\n\n查看当前拥有哪些终端：\n```bash\ncat /etc/shells\n```\n查看正在使用的终端：\n```bash\necho $SHELL\n```\n切换终端为zsh：\n```bash\nchsh -s /bin/zsh\n```\n安装 oh my zsh：\n```bash\nsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n#### 配置 zsh 插件\n这里推荐我用的三个\n\n安装zsh-autosuggestions（命令推荐）:\n```bash\ngit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n```\n安装zsh-syntax-highlighting（命令高亮）：\n```bash\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git \n```\n安装autojump（记录命令操作，使用j快捷跳转）：\n```bash\ngit clone git://github.com/joelthelion/autojump.git\ncd autojump\n./install.py\n```\n最后在 ~/.zshrc 中配置插件和主题，主题可以自行选择，有很多种类：\n```bash\n# 主题配置\nZSH_THEME=ys\n# 插件配置\nplugins=(\n git\n autojump\n zsh-autosuggestions\n zsh-syntax-highlighting\n)\n```\n\n最后下载一款 iterm2 的终端代替mac自带的：\n直接下载安装：[http://iterm2.com/ ](http://iterm2.com/)\n设为默认：\niTerm2 -> Make iTerm2 Default Term\n\n","slug":"writeSomething/WorkEnvConfig","published":1,"updated":"2019-04-03T05:28:23.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwy001iax488jfqiki6","content":"<p>入手新的mac？快速搭建你的开发环境！👏<br><a id=\"more\"></a></p>\n<h1 id=\"开机\"><a href=\"#开机\" class=\"headerlink\" title=\"开机\"></a>开机</h1><p>ahhhh</p>\n<h1 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h1><p><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node最新版本下载地址：</a>，Current 或者 LTS 版本的 Node 看自己的需求选一个囖</p>\n<h1 id=\"nrm\"><a href=\"#nrm\" class=\"headerlink\" title=\"nrm\"></a>nrm</h1><p>npm包管理器会捆绑安装的Node中，但是有时候我们会需要用到管理npm源的需要的，如果可能会有多个源自己设置 registry 是不是很麻烦呢<br>下载nrm吧，非常好用<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">sudo npm install nrm -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前的源列表（带*为正在使用）</span></span><br><span class=\"line\">nrm ls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加源</span></span><br><span class=\"line\">nrm add [源名字] [源地址]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除源</span></span><br><span class=\"line\">nrm del [源名字]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换源</span></span><br><span class=\"line\">nrm use [源名字]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试源响应时间</span></span><br><span class=\"line\">nrm <span class=\"built_in\">test</span> [源名字]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"cnpm\"><a href=\"#cnpm\" class=\"headerlink\" title=\"cnpm\"></a>cnpm</h1><p>网络xxx，加个淘宝npm镜像吧，定时同步<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>\n<p>这里是添加了一个 <code>cnpm</code> 的命令行工具，使用方式和 npm 完全一致，会自动添加到nrm中，但是有上面的 nrm, 完全可以自己不使用cnpm，直接加在自己的源列表里面也是可以的<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nrm add cnpm https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h1><p>下载并安装git：<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/</a></p>\n<h1 id=\"homebrew\"><a href=\"#homebrew\" class=\"headerlink\" title=\"homebrew\"></a>homebrew</h1><p>Homebrew是一个包管理器，用于安装需要的UNIX工具类似wget，也可以安装nginx、yarn之类的服务服务和工具</p>\n<p>安装XCode或者Command Line Tools for Xcode。Xcode可以从AppStore里下载安装<br>或者安装 Command Line Tools for Xcode：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcode-select --install</span><br></pre></td></tr></table></figure></p>\n<p>安装Homebrew<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<p>使用：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 搜索包</span></span><br><span class=\"line\">brew search [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装包</span></span><br><span class=\"line\">brew install [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看包信息，比如目前的版本，依赖，安装后注意事项等</span></span><br><span class=\"line\">brew info [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 卸载包</span></span><br><span class=\"line\">brew uninstall [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示已安装的包</span></span><br><span class=\"line\">brew list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看brew的帮助</span></span><br><span class=\"line\">brew –<span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新， 这会更新 Homebrew 自己</span></span><br><span class=\"line\">brew update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span></span><br><span class=\"line\">brew outdated</span><br><span class=\"line\">brew outdated [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 升级所有可以升级的软件们</span></span><br><span class=\"line\">brew upgrade</span><br><span class=\"line\">brew upgrade [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理不需要的版本极其安装包缓存</span></span><br><span class=\"line\">brew cleanup</span><br><span class=\"line\">brew cleanup [包名]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"yarn\"><a href=\"#yarn\" class=\"headerlink\" title=\"yarn\"></a>yarn</h1><p>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快<br>可以使用homebrew：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install yarn</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用npm：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm i yarn -g</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"oh-my-zsh-item2\"><a href=\"#oh-my-zsh-item2\" class=\"headerlink\" title=\"oh my zsh + item2\"></a>oh my zsh + item2</h1><p>mac岂可无顺眼的终端</p>\n<p>查看当前拥有哪些终端：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/shells</span><br></pre></td></tr></table></figure></p>\n<p>查看正在使用的终端：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$SHELL</span></span><br></pre></td></tr></table></figure></p>\n<p>切换终端为zsh：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></p>\n<p>安装 oh my zsh：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"配置-zsh-插件\"><a href=\"#配置-zsh-插件\" class=\"headerlink\" title=\"配置 zsh 插件\"></a>配置 zsh 插件</h4><p>这里推荐我用的三个</p>\n<p>安装zsh-autosuggestions（命令推荐）:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git://github.com/zsh-users/zsh-autosuggestions <span class=\"variable\">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></p>\n<p>安装zsh-syntax-highlighting（命令高亮）：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br></pre></td></tr></table></figure></p>\n<p>安装autojump（记录命令操作，使用j快捷跳转）：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git://github.com/joelthelion/autojump.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> autojump</span><br><span class=\"line\">./install.py</span><br></pre></td></tr></table></figure></p>\n<p>最后在 ~/.zshrc 中配置插件和主题，主题可以自行选择，有很多种类：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 主题配置</span></span><br><span class=\"line\">ZSH_THEME=ys</span><br><span class=\"line\"><span class=\"comment\"># 插件配置</span></span><br><span class=\"line\">plugins=(</span><br><span class=\"line\"> git</span><br><span class=\"line\"> autojump</span><br><span class=\"line\"> zsh-autosuggestions</span><br><span class=\"line\"> zsh-syntax-highlighting</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>最后下载一款 iterm2 的终端代替mac自带的：<br>直接下载安装：<a href=\"http://iterm2.com/\" target=\"_blank\" rel=\"noopener\">http://iterm2.com/ </a><br>设为默认：<br>iTerm2 -&gt; Make iTerm2 Default Term</p>\n","site":{"data":{}},"excerpt":"<p>入手新的mac？快速搭建你的开发环境！👏<br></p>","more":"<p></p>\n<h1 id=\"开机\"><a href=\"#开机\" class=\"headerlink\" title=\"开机\"></a>开机</h1><p>ahhhh</p>\n<h1 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h1><p><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node最新版本下载地址：</a>，Current 或者 LTS 版本的 Node 看自己的需求选一个囖</p>\n<h1 id=\"nrm\"><a href=\"#nrm\" class=\"headerlink\" title=\"nrm\"></a>nrm</h1><p>npm包管理器会捆绑安装的Node中，但是有时候我们会需要用到管理npm源的需要的，如果可能会有多个源自己设置 registry 是不是很麻烦呢<br>下载nrm吧，非常好用<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">sudo npm install nrm -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前的源列表（带*为正在使用）</span></span><br><span class=\"line\">nrm ls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加源</span></span><br><span class=\"line\">nrm add [源名字] [源地址]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除源</span></span><br><span class=\"line\">nrm del [源名字]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换源</span></span><br><span class=\"line\">nrm use [源名字]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试源响应时间</span></span><br><span class=\"line\">nrm <span class=\"built_in\">test</span> [源名字]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"cnpm\"><a href=\"#cnpm\" class=\"headerlink\" title=\"cnpm\"></a>cnpm</h1><p>网络xxx，加个淘宝npm镜像吧，定时同步<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>\n<p>这里是添加了一个 <code>cnpm</code> 的命令行工具，使用方式和 npm 完全一致，会自动添加到nrm中，但是有上面的 nrm, 完全可以自己不使用cnpm，直接加在自己的源列表里面也是可以的<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nrm add cnpm https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h1><p>下载并安装git：<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/</a></p>\n<h1 id=\"homebrew\"><a href=\"#homebrew\" class=\"headerlink\" title=\"homebrew\"></a>homebrew</h1><p>Homebrew是一个包管理器，用于安装需要的UNIX工具类似wget，也可以安装nginx、yarn之类的服务服务和工具</p>\n<p>安装XCode或者Command Line Tools for Xcode。Xcode可以从AppStore里下载安装<br>或者安装 Command Line Tools for Xcode：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcode-select --install</span><br></pre></td></tr></table></figure></p>\n<p>安装Homebrew<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<p>使用：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 搜索包</span></span><br><span class=\"line\">brew search [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装包</span></span><br><span class=\"line\">brew install [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看包信息，比如目前的版本，依赖，安装后注意事项等</span></span><br><span class=\"line\">brew info [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 卸载包</span></span><br><span class=\"line\">brew uninstall [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示已安装的包</span></span><br><span class=\"line\">brew list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看brew的帮助</span></span><br><span class=\"line\">brew –<span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新， 这会更新 Homebrew 自己</span></span><br><span class=\"line\">brew update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span></span><br><span class=\"line\">brew outdated</span><br><span class=\"line\">brew outdated [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 升级所有可以升级的软件们</span></span><br><span class=\"line\">brew upgrade</span><br><span class=\"line\">brew upgrade [包名]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理不需要的版本极其安装包缓存</span></span><br><span class=\"line\">brew cleanup</span><br><span class=\"line\">brew cleanup [包名]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"yarn\"><a href=\"#yarn\" class=\"headerlink\" title=\"yarn\"></a>yarn</h1><p>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快<br>可以使用homebrew：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install yarn</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用npm：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm i yarn -g</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"oh-my-zsh-item2\"><a href=\"#oh-my-zsh-item2\" class=\"headerlink\" title=\"oh my zsh + item2\"></a>oh my zsh + item2</h1><p>mac岂可无顺眼的终端</p>\n<p>查看当前拥有哪些终端：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/shells</span><br></pre></td></tr></table></figure></p>\n<p>查看正在使用的终端：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$SHELL</span></span><br></pre></td></tr></table></figure></p>\n<p>切换终端为zsh：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></p>\n<p>安装 oh my zsh：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"配置-zsh-插件\"><a href=\"#配置-zsh-插件\" class=\"headerlink\" title=\"配置 zsh 插件\"></a>配置 zsh 插件</h4><p>这里推荐我用的三个</p>\n<p>安装zsh-autosuggestions（命令推荐）:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git://github.com/zsh-users/zsh-autosuggestions <span class=\"variable\">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></p>\n<p>安装zsh-syntax-highlighting（命令高亮）：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br></pre></td></tr></table></figure></p>\n<p>安装autojump（记录命令操作，使用j快捷跳转）：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git://github.com/joelthelion/autojump.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> autojump</span><br><span class=\"line\">./install.py</span><br></pre></td></tr></table></figure></p>\n<p>最后在 ~/.zshrc 中配置插件和主题，主题可以自行选择，有很多种类：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 主题配置</span></span><br><span class=\"line\">ZSH_THEME=ys</span><br><span class=\"line\"><span class=\"comment\"># 插件配置</span></span><br><span class=\"line\">plugins=(</span><br><span class=\"line\"> git</span><br><span class=\"line\"> autojump</span><br><span class=\"line\"> zsh-autosuggestions</span><br><span class=\"line\"> zsh-syntax-highlighting</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>最后下载一款 iterm2 的终端代替mac自带的：<br>直接下载安装：<a href=\"http://iterm2.com/\" target=\"_blank\" rel=\"noopener\">http://iterm2.com/ </a><br>设为默认：<br>iTerm2 -&gt; Make iTerm2 Default Term</p>"},{"title":"动态规划和递归：从虎羊草开始","date":"2019-02-21T12:36:00.000Z","_content":"\n老虎会吃羊吗？🐅🐑\n\n<!--more-->\n\n草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）\n\n_提示:每只老虎都很聪明_\n\n# 归纳\n\n#### case1: 两只老虎一只羊\n\n不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃\n\n#### case2: 三只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case1\n\n#### case3: 四只老虎一只羊\n\n不吃：一只老虎吃完羊后情景变为case2会被吃\n\n#### case4: 五只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case3\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃\n\n引出课题 `Dynamic Programming`\n\n# Dynamic Programming\n\n> 简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念\n\n- 最优子结构\n- 边界\n- 状态转移公式\n\n下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题\n\n_Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........这个数列从第3项开始，每一项都等于前两项之和_\n\n在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）因此可以直接写出以下代码：\n``` js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  return fn(n-1) + fn(n-2)\n}\n```\n运行结果如下：\n``` js\nconsole.log(\n  `第1项${fn(1)}`,\n  `第2项${fn(2)}`,\n  `第3项${fn(3)}`,\n  `第4项${fn(4)}`,\n  `第5项${fn(5)}`,\n  `第6项${fn(6)}`,\n  `第7项${fn(7)}`\n)\n// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13\n```\n\n现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念\n\n1. 最优子结构：若想求得第 `m` 项的值，那么只需要去求得第 `m-1` 和 `m-2` 的值即可，那么 `fn(m-1) + fn(m-2) === f(m)` 等式成立\n2. 边界: 即范围\n3. 状态转移公式：`f(m) = fn(m-1) + fn(m-2)`\n\n上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？\n具象化来看： 求得f(5) = ？\n - f(5)依赖 f(4)和f(3)\n - f(4)依赖 f(3)和f(2)\n - f(3)依赖 f(2)和f(1)\n\n显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：\n\n```js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  let m = 1, m_1 = 1, result\n\n  for(let i = 3; i <= n; i++){\n    result = m + m_1\n    m_1 = m\n    m = result\n  }\n\n  return result\n}\n```\n\n结果和上面是一致的但是性能就会有非常大的提升了\n\n# 既然上面提到了递归我们就再来说说递归\n_递归： 程序调用自身的编程技巧称为递归（recursion）_\n\n那么上面 `return fn(n-1) + fn(n-2)` 就是一个最普通的递归\n\n这里再引入一个尾递归的概念：就是函数在尾部调用自身\n\n那下面来简单说说为什么上面递归的写法性能会那么差\n\n调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存\n\n将上面方法改用尾递归的写法：\n```js\nfunction fn(n, m_1 = 1, m = 1) {  \n  if (n === 1 || n === 2) return m\n\n  return fn(n - 1, m, m + m_1)\n}\n```\n此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍\n\n当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈\n\n# summary\n\ndraven：好好看 好好学\n\n\n","source":"_posts/writeSomething/dynamicProgrammingAndRecursion.md","raw":"---\ntitle: 动态规划和递归：从虎羊草开始\ntags:\n  - 算法\n  - 动态规划\n  - 递归\ndate: 2019-02-21 20:36:00\ncategories: 算法\n---\n\n老虎会吃羊吗？🐅🐑\n\n<!--more-->\n\n草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）\n\n_提示:每只老虎都很聪明_\n\n# 归纳\n\n#### case1: 两只老虎一只羊\n\n不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃\n\n#### case2: 三只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case1\n\n#### case3: 四只老虎一只羊\n\n不吃：一只老虎吃完羊后情景变为case2会被吃\n\n#### case4: 五只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case3\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃\n\n引出课题 `Dynamic Programming`\n\n# Dynamic Programming\n\n> 简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念\n\n- 最优子结构\n- 边界\n- 状态转移公式\n\n下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题\n\n_Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........这个数列从第3项开始，每一项都等于前两项之和_\n\n在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）因此可以直接写出以下代码：\n``` js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  return fn(n-1) + fn(n-2)\n}\n```\n运行结果如下：\n``` js\nconsole.log(\n  `第1项${fn(1)}`,\n  `第2项${fn(2)}`,\n  `第3项${fn(3)}`,\n  `第4项${fn(4)}`,\n  `第5项${fn(5)}`,\n  `第6项${fn(6)}`,\n  `第7项${fn(7)}`\n)\n// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13\n```\n\n现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念\n\n1. 最优子结构：若想求得第 `m` 项的值，那么只需要去求得第 `m-1` 和 `m-2` 的值即可，那么 `fn(m-1) + fn(m-2) === f(m)` 等式成立\n2. 边界: 即范围\n3. 状态转移公式：`f(m) = fn(m-1) + fn(m-2)`\n\n上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？\n具象化来看： 求得f(5) = ？\n - f(5)依赖 f(4)和f(3)\n - f(4)依赖 f(3)和f(2)\n - f(3)依赖 f(2)和f(1)\n\n显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：\n\n```js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  let m = 1, m_1 = 1, result\n\n  for(let i = 3; i <= n; i++){\n    result = m + m_1\n    m_1 = m\n    m = result\n  }\n\n  return result\n}\n```\n\n结果和上面是一致的但是性能就会有非常大的提升了\n\n# 既然上面提到了递归我们就再来说说递归\n_递归： 程序调用自身的编程技巧称为递归（recursion）_\n\n那么上面 `return fn(n-1) + fn(n-2)` 就是一个最普通的递归\n\n这里再引入一个尾递归的概念：就是函数在尾部调用自身\n\n那下面来简单说说为什么上面递归的写法性能会那么差\n\n调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存\n\n将上面方法改用尾递归的写法：\n```js\nfunction fn(n, m_1 = 1, m = 1) {  \n  if (n === 1 || n === 2) return m\n\n  return fn(n - 1, m, m + m_1)\n}\n```\n此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍\n\n当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈\n\n# summary\n\ndraven：好好看 好好学\n\n\n","slug":"writeSomething/dynamicProgrammingAndRecursion","published":1,"updated":"2019-03-11T05:40:41.554Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxwz001kax48yk5yyuyd","content":"<p>老虎会吃羊吗？🐅🐑</p>\n<a id=\"more\"></a>\n<p>草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）</p>\n<p><em>提示:每只老虎都很聪明</em></p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><h4 id=\"case1-两只老虎一只羊\"><a href=\"#case1-两只老虎一只羊\" class=\"headerlink\" title=\"case1: 两只老虎一只羊\"></a>case1: 两只老虎一只羊</h4><p>不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃</p>\n<h4 id=\"case2-三只老虎一只羊\"><a href=\"#case2-三只老虎一只羊\" class=\"headerlink\" title=\"case2: 三只老虎一只羊\"></a>case2: 三只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case1</p>\n<h4 id=\"case3-四只老虎一只羊\"><a href=\"#case3-四只老虎一只羊\" class=\"headerlink\" title=\"case3: 四只老虎一只羊\"></a>case3: 四只老虎一只羊</h4><p>不吃：一只老虎吃完羊后情景变为case2会被吃</p>\n<h4 id=\"case4-五只老虎一只羊\"><a href=\"#case4-五只老虎一只羊\" class=\"headerlink\" title=\"case4: 五只老虎一只羊\"></a>case4: 五只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case3</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃</p>\n<p>引出课题 <code>Dynamic Programming</code></p>\n<h1 id=\"Dynamic-Programming\"><a href=\"#Dynamic-Programming\" class=\"headerlink\" title=\"Dynamic Programming\"></a>Dynamic Programming</h1><blockquote>\n<p>简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念</p>\n</blockquote>\n<ul>\n<li>最优子结构</li>\n<li>边界</li>\n<li>状态转移公式</li>\n</ul>\n<p>下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题</p>\n<p><em>Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..这个数列从第3项开始，每一项都等于前两项之和</em></p>\n<p>在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）因此可以直接写出以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n<span class=\"number\">-1</span>) + fn(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第1项<span class=\"subst\">$&#123;fn(<span class=\"number\">1</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第2项<span class=\"subst\">$&#123;fn(<span class=\"number\">2</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第3项<span class=\"subst\">$&#123;fn(<span class=\"number\">3</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第4项<span class=\"subst\">$&#123;fn(<span class=\"number\">4</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第5项<span class=\"subst\">$&#123;fn(<span class=\"number\">5</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第6项<span class=\"subst\">$&#123;fn(<span class=\"number\">6</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第7项<span class=\"subst\">$&#123;fn(<span class=\"number\">7</span>)&#125;</span>`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13</span></span><br></pre></td></tr></table></figure></p>\n<p>现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念</p>\n<ol>\n<li>最优子结构：若想求得第 <code>m</code> 项的值，那么只需要去求得第 <code>m-1</code> 和 <code>m-2</code> 的值即可，那么 <code>fn(m-1) + fn(m-2) === f(m)</code> 等式成立</li>\n<li>边界: 即范围</li>\n<li>状态转移公式：<code>f(m) = fn(m-1) + fn(m-2)</code></li>\n</ol>\n<p>上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？<br>具象化来看： 求得f(5) = ？</p>\n<ul>\n<li>f(5)依赖 f(4)和f(3)</li>\n<li>f(4)依赖 f(3)和f(2)</li>\n<li>f(3)依赖 f(2)和f(1)</li>\n</ul>\n<p>显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>, m_1 = <span class=\"number\">1</span>, result</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">    result = m + m_1</span><br><span class=\"line\">    m_1 = m</span><br><span class=\"line\">    m = result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果和上面是一致的但是性能就会有非常大的提升了</p>\n<h1 id=\"既然上面提到了递归我们就再来说说递归\"><a href=\"#既然上面提到了递归我们就再来说说递归\" class=\"headerlink\" title=\"既然上面提到了递归我们就再来说说递归\"></a>既然上面提到了递归我们就再来说说递归</h1><p><em>递归： 程序调用自身的编程技巧称为递归（recursion）</em></p>\n<p>那么上面 <code>return fn(n-1) + fn(n-2)</code> 就是一个最普通的递归</p>\n<p>这里再引入一个尾递归的概念：就是函数在尾部调用自身</p>\n<p>那下面来简单说说为什么上面递归的写法性能会那么差</p>\n<p>调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存</p>\n<p>将上面方法改用尾递归的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n, m_1 = <span class=\"number\">1</span>, m = <span class=\"number\">1</span></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> m</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n - <span class=\"number\">1</span>, m, m + m_1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍</p>\n<p>当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>draven：好好看 好好学</p>\n","site":{"data":{}},"excerpt":"<p>老虎会吃羊吗？🐅🐑</p>","more":"<p>草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）</p>\n<p><em>提示:每只老虎都很聪明</em></p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><h4 id=\"case1-两只老虎一只羊\"><a href=\"#case1-两只老虎一只羊\" class=\"headerlink\" title=\"case1: 两只老虎一只羊\"></a>case1: 两只老虎一只羊</h4><p>不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃</p>\n<h4 id=\"case2-三只老虎一只羊\"><a href=\"#case2-三只老虎一只羊\" class=\"headerlink\" title=\"case2: 三只老虎一只羊\"></a>case2: 三只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case1</p>\n<h4 id=\"case3-四只老虎一只羊\"><a href=\"#case3-四只老虎一只羊\" class=\"headerlink\" title=\"case3: 四只老虎一只羊\"></a>case3: 四只老虎一只羊</h4><p>不吃：一只老虎吃完羊后情景变为case2会被吃</p>\n<h4 id=\"case4-五只老虎一只羊\"><a href=\"#case4-五只老虎一只羊\" class=\"headerlink\" title=\"case4: 五只老虎一只羊\"></a>case4: 五只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case3</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃</p>\n<p>引出课题 <code>Dynamic Programming</code></p>\n<h1 id=\"Dynamic-Programming\"><a href=\"#Dynamic-Programming\" class=\"headerlink\" title=\"Dynamic Programming\"></a>Dynamic Programming</h1><blockquote>\n<p>简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念</p>\n</blockquote>\n<ul>\n<li>最优子结构</li>\n<li>边界</li>\n<li>状态转移公式</li>\n</ul>\n<p>下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题</p>\n<p><em>Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..这个数列从第3项开始，每一项都等于前两项之和</em></p>\n<p>在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）因此可以直接写出以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n<span class=\"number\">-1</span>) + fn(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第1项<span class=\"subst\">$&#123;fn(<span class=\"number\">1</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第2项<span class=\"subst\">$&#123;fn(<span class=\"number\">2</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第3项<span class=\"subst\">$&#123;fn(<span class=\"number\">3</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第4项<span class=\"subst\">$&#123;fn(<span class=\"number\">4</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第5项<span class=\"subst\">$&#123;fn(<span class=\"number\">5</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第6项<span class=\"subst\">$&#123;fn(<span class=\"number\">6</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第7项<span class=\"subst\">$&#123;fn(<span class=\"number\">7</span>)&#125;</span>`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13</span></span><br></pre></td></tr></table></figure></p>\n<p>现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念</p>\n<ol>\n<li>最优子结构：若想求得第 <code>m</code> 项的值，那么只需要去求得第 <code>m-1</code> 和 <code>m-2</code> 的值即可，那么 <code>fn(m-1) + fn(m-2) === f(m)</code> 等式成立</li>\n<li>边界: 即范围</li>\n<li>状态转移公式：<code>f(m) = fn(m-1) + fn(m-2)</code></li>\n</ol>\n<p>上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？<br>具象化来看： 求得f(5) = ？</p>\n<ul>\n<li>f(5)依赖 f(4)和f(3)</li>\n<li>f(4)依赖 f(3)和f(2)</li>\n<li>f(3)依赖 f(2)和f(1)</li>\n</ul>\n<p>显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>, m_1 = <span class=\"number\">1</span>, result</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">    result = m + m_1</span><br><span class=\"line\">    m_1 = m</span><br><span class=\"line\">    m = result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果和上面是一致的但是性能就会有非常大的提升了</p>\n<h1 id=\"既然上面提到了递归我们就再来说说递归\"><a href=\"#既然上面提到了递归我们就再来说说递归\" class=\"headerlink\" title=\"既然上面提到了递归我们就再来说说递归\"></a>既然上面提到了递归我们就再来说说递归</h1><p><em>递归： 程序调用自身的编程技巧称为递归（recursion）</em></p>\n<p>那么上面 <code>return fn(n-1) + fn(n-2)</code> 就是一个最普通的递归</p>\n<p>这里再引入一个尾递归的概念：就是函数在尾部调用自身</p>\n<p>那下面来简单说说为什么上面递归的写法性能会那么差</p>\n<p>调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存</p>\n<p>将上面方法改用尾递归的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n, m_1 = <span class=\"number\">1</span>, m = <span class=\"number\">1</span></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> m</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n - <span class=\"number\">1</span>, m, m + m_1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍</p>\n<p>当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>draven：好好看 好好学</p>"},{"title":"客户端与服务端的tcp连接是怎么建立的？","date":"2019-09-02T14:29:00.000Z","_content":"\n听腻了大学课本人云亦云的三次握手四次挥手，那么具体的tcp连接在应用场景中是什么样的表现形式呢？\n客户端与服务端的连接是怎么建立的？\n<!--more-->\n曾经有这么一道经典面试题：从 URL 在浏览器被被输入到页面展现的过程中发生了什么？\n相信大多数准备过的同学都能回答出来，但是如果继续问：收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？\n\n### 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？\n在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，两张图片是我短时间内两次访问 https://www.github.com 的时间统计：\n![ssl](ssl_1.jpg)\n![ssl](ssl_2.jpg)\n头一次访问，有初始化连接和 SSL 开销\n初始化连接和 SSL 开销消失了，说明使用的是同一个 TCP 连接\n持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。\n所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。\n\n### 一个 TCP 连接可以对应几个 HTTP 请求？\n如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。\n\n### 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？\nHTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。\n虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。\n\n先来看一下 Pipelining 是什么，RFC 2616 中规定了：\n> A client that supports persistent connections MAY \"pipeline\" its requests (i.e., send multiple requests without waiting for each \nresponse). A server MUST send its responses to those requests in the same order that the requests were received. \n\n一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。\n\n至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 GET/query?q=A 和 GET/query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。\nPipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：\n一些代理服务器不能正确的处理 HTTP Pipelining。\n正确的流水线实现是复杂的。\nHead-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。\n所以现代浏览器默认是不开启 HTTP Pipelining 的。\n但是，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。我们可以看一下使用 HTTP2 的效果。\n![http2](http2.jpg)\n绿色是发起请求到请求返回的等待时间，蓝色是响应的下载时间，可以看到都是在同一个 Connection，并行完成的\n所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。\n那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：\n维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。\n和服务器建立多个 TCP 连接。\n\n### 为什么有的时候刷新页面不需要重新建立 SSL 连接？\nTCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。\n\n### 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？\n假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。\nChrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。\n> https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requestsdevelopers.google.com\n\n那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？\n如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。\n如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。\n","source":"_posts/writeSomething/http_tcp.md","raw":"---\ntitle: 客户端与服务端的tcp连接是怎么建立的？\ntags:\n  - tcp\ndate: 2019-09-02 22:29:00\ncategories: 计算机网络\n---\n\n听腻了大学课本人云亦云的三次握手四次挥手，那么具体的tcp连接在应用场景中是什么样的表现形式呢？\n客户端与服务端的连接是怎么建立的？\n<!--more-->\n曾经有这么一道经典面试题：从 URL 在浏览器被被输入到页面展现的过程中发生了什么？\n相信大多数准备过的同学都能回答出来，但是如果继续问：收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？\n\n### 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？\n在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，两张图片是我短时间内两次访问 https://www.github.com 的时间统计：\n![ssl](ssl_1.jpg)\n![ssl](ssl_2.jpg)\n头一次访问，有初始化连接和 SSL 开销\n初始化连接和 SSL 开销消失了，说明使用的是同一个 TCP 连接\n持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。\n所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。\n\n### 一个 TCP 连接可以对应几个 HTTP 请求？\n如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。\n\n### 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？\nHTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。\n虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。\n\n先来看一下 Pipelining 是什么，RFC 2616 中规定了：\n> A client that supports persistent connections MAY \"pipeline\" its requests (i.e., send multiple requests without waiting for each \nresponse). A server MUST send its responses to those requests in the same order that the requests were received. \n\n一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。\n\n至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 GET/query?q=A 和 GET/query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。\nPipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：\n一些代理服务器不能正确的处理 HTTP Pipelining。\n正确的流水线实现是复杂的。\nHead-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。\n所以现代浏览器默认是不开启 HTTP Pipelining 的。\n但是，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。我们可以看一下使用 HTTP2 的效果。\n![http2](http2.jpg)\n绿色是发起请求到请求返回的等待时间，蓝色是响应的下载时间，可以看到都是在同一个 Connection，并行完成的\n所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。\n那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：\n维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。\n和服务器建立多个 TCP 连接。\n\n### 为什么有的时候刷新页面不需要重新建立 SSL 连接？\nTCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。\n\n### 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？\n假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。\nChrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。\n> https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requestsdevelopers.google.com\n\n那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？\n如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。\n如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。\n","slug":"writeSomething/http_tcp","published":1,"updated":"2019-09-03T07:17:52.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxx0001max48h70lfvci","content":"<p>听腻了大学课本人云亦云的三次握手四次挥手，那么具体的tcp连接在应用场景中是什么样的表现形式呢？<br>客户端与服务端的连接是怎么建立的？<br><a id=\"more\"></a><br>曾经有这么一道经典面试题：从 URL 在浏览器被被输入到页面展现的过程中发生了什么？<br>相信大多数准备过的同学都能回答出来，但是如果继续问：收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？</p>\n<h3 id=\"现代浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？\"><a href=\"#现代浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？\" class=\"headerlink\" title=\"现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？\"></a>现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</h3><p>在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，两张图片是我短时间内两次访问 <a href=\"https://www.github.com\" target=\"_blank\" rel=\"noopener\">https://www.github.com</a> 的时间统计：<br><img src=\"/2019/09/02/writeSomething/http_tcp/ssl_1.jpg\" alt=\"ssl\"><br><img src=\"/2019/09/02/writeSomething/http_tcp/ssl_2.jpg\" alt=\"ssl\"><br>头一次访问，有初始化连接和 SSL 开销<br>初始化连接和 SSL 开销消失了，说明使用的是同一个 TCP 连接<br>持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。<br>所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。</p>\n<h3 id=\"一个-TCP-连接可以对应几个-HTTP-请求？\"><a href=\"#一个-TCP-连接可以对应几个-HTTP-请求？\" class=\"headerlink\" title=\"一个 TCP 连接可以对应几个 HTTP 请求？\"></a>一个 TCP 连接可以对应几个 HTTP 请求？</h3><p>如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。</p>\n<h3 id=\"一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？\"><a href=\"#一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？\" class=\"headerlink\" title=\"一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？\"></a>一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</h3><p>HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。<br>虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。</p>\n<p>先来看一下 Pipelining 是什么，RFC 2616 中规定了：</p>\n<blockquote>\n<p>A client that supports persistent connections MAY “pipeline” its requests (i.e., send multiple requests without waiting for each<br>response). A server MUST send its responses to those requests in the same order that the requests were received. </p>\n</blockquote>\n<p>一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。</p>\n<p>至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 GET/query?q=A 和 GET/query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。<br>Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：<br>一些代理服务器不能正确的处理 HTTP Pipelining。<br>正确的流水线实现是复杂的。<br>Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。<br>所以现代浏览器默认是不开启 HTTP Pipelining 的。<br>但是，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。我们可以看一下使用 HTTP2 的效果。<br><img src=\"http2.jpg\" alt=\"http2\"><br>绿色是发起请求到请求返回的等待时间，蓝色是响应的下载时间，可以看到都是在同一个 Connection，并行完成的<br>所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。<br>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：<br>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。<br>和服务器建立多个 TCP 连接。</p>\n<h3 id=\"为什么有的时候刷新页面不需要重新建立-SSL-连接？\"><a href=\"#为什么有的时候刷新页面不需要重新建立-SSL-连接？\" class=\"headerlink\" title=\"为什么有的时候刷新页面不需要重新建立 SSL 连接？\"></a>为什么有的时候刷新页面不需要重新建立 SSL 连接？</h3><p>TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。</p>\n<h3 id=\"浏览器对同一-Host-建立-TCP-连接到数量有没有限制？\"><a href=\"#浏览器对同一-Host-建立-TCP-连接到数量有没有限制？\" class=\"headerlink\" title=\"浏览器对同一 Host 建立 TCP 连接到数量有没有限制？\"></a>浏览器对同一 Host 建立 TCP 连接到数量有没有限制？</h3><p>假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。<br>Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。</p>\n<blockquote>\n<p><a href=\"https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requestsdevelopers.google.com\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requestsdevelopers.google.com</a></p>\n</blockquote>\n<p>那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？<br>如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。<br>如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。</p>\n","site":{"data":{}},"excerpt":"<p>听腻了大学课本人云亦云的三次握手四次挥手，那么具体的tcp连接在应用场景中是什么样的表现形式呢？<br>客户端与服务端的连接是怎么建立的？<br></p>","more":"<br>曾经有这么一道经典面试题：从 URL 在浏览器被被输入到页面展现的过程中发生了什么？<br>相信大多数准备过的同学都能回答出来，但是如果继续问：收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？<p></p>\n<h3 id=\"现代浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？\"><a href=\"#现代浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？\" class=\"headerlink\" title=\"现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？\"></a>现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</h3><p>在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，两张图片是我短时间内两次访问 <a href=\"https://www.github.com\" target=\"_blank\" rel=\"noopener\">https://www.github.com</a> 的时间统计：<br><img src=\"/2019/09/02/writeSomething/http_tcp/ssl_1.jpg\" alt=\"ssl\"><br><img src=\"/2019/09/02/writeSomething/http_tcp/ssl_2.jpg\" alt=\"ssl\"><br>头一次访问，有初始化连接和 SSL 开销<br>初始化连接和 SSL 开销消失了，说明使用的是同一个 TCP 连接<br>持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。<br>所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。</p>\n<h3 id=\"一个-TCP-连接可以对应几个-HTTP-请求？\"><a href=\"#一个-TCP-连接可以对应几个-HTTP-请求？\" class=\"headerlink\" title=\"一个 TCP 连接可以对应几个 HTTP 请求？\"></a>一个 TCP 连接可以对应几个 HTTP 请求？</h3><p>如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。</p>\n<h3 id=\"一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？\"><a href=\"#一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？\" class=\"headerlink\" title=\"一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？\"></a>一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</h3><p>HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。<br>虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。</p>\n<p>先来看一下 Pipelining 是什么，RFC 2616 中规定了：</p>\n<blockquote>\n<p>A client that supports persistent connections MAY “pipeline” its requests (i.e., send multiple requests without waiting for each<br>response). A server MUST send its responses to those requests in the same order that the requests were received. </p>\n</blockquote>\n<p>一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。</p>\n<p>至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 GET/query?q=A 和 GET/query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。<br>Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：<br>一些代理服务器不能正确的处理 HTTP Pipelining。<br>正确的流水线实现是复杂的。<br>Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。<br>所以现代浏览器默认是不开启 HTTP Pipelining 的。<br>但是，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。我们可以看一下使用 HTTP2 的效果。<br><img src=\"http2.jpg\" alt=\"http2\"><br>绿色是发起请求到请求返回的等待时间，蓝色是响应的下载时间，可以看到都是在同一个 Connection，并行完成的<br>所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。<br>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：<br>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。<br>和服务器建立多个 TCP 连接。</p>\n<h3 id=\"为什么有的时候刷新页面不需要重新建立-SSL-连接？\"><a href=\"#为什么有的时候刷新页面不需要重新建立-SSL-连接？\" class=\"headerlink\" title=\"为什么有的时候刷新页面不需要重新建立 SSL 连接？\"></a>为什么有的时候刷新页面不需要重新建立 SSL 连接？</h3><p>TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。</p>\n<h3 id=\"浏览器对同一-Host-建立-TCP-连接到数量有没有限制？\"><a href=\"#浏览器对同一-Host-建立-TCP-连接到数量有没有限制？\" class=\"headerlink\" title=\"浏览器对同一 Host 建立 TCP 连接到数量有没有限制？\"></a>浏览器对同一 Host 建立 TCP 连接到数量有没有限制？</h3><p>假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。<br>Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。</p>\n<blockquote>\n<p><a href=\"https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requestsdevelopers.google.com\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requestsdevelopers.google.com</a></p>\n</blockquote>\n<p>那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？<br>如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。<br>如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。</p>"},{"title":"十行代码实现Koa2洋葱模型","date":"2019-02-22T11:00:00.000Z","_content":"\n十行代码实现 `koa2` 洋葱模型\n\n<!--more-->\n\n#### 洋葱图模型\n![avatar](/onion.png)\n\nkoa2上独特的中间件流程控制，是一个典型的洋葱模型\n\n# 运行 koa2 demo\n```js\nconst Koa = require('koa2')\n\nconst app = new Koa()\n\napp.use(async (ctx, next)=>{\n    console.log(1, ' start')\n    await next()\n    console.log(1, ' end')\n})\n\napp.use(async (ctx, next) => {\n    console.log(2, ' start')\n    await next()\n    console.log(2, ' end')\n})\napp.use(async (ctx, next) => {\n    console.log(3, ' start')\n    await next()\n    console.log(3, ' end')\n})\n\napp.listen(3000)\n```\n输出结果：\n```bash\n1 start\n2 start\n3 start\n3 end\n2 end\n1 end\n```\n\n展现如上图洋葱式的输出结果\n\n# 归纳\n\n接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：\n- 首先变为最简case：只有两个中间件函数\n- 那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 `1 start -> 2 start -> 2 end -> 1 end` 的结果\n- 同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n和之前的一篇 [动态规划和递归：从虎羊草开始](https://rollawaypoint.github.io/2019/02/21/writeSomething/dynamicProgrammingAndRecursion/) 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码\n\n# 三步完成封装\n\n第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n```\n\n第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -> 2 -> 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：\n```js\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n```\n\n第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：\n```js\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n```\n\n以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试\n\n# 测试\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n\nconst app = new App\n\napp.use(async function m1(next) {\n  console.log('m1')\n  await next()\n  console.log('m1 end')\n})\n\napp.use(async function m2(next) {\n  console.log('m2')\n  await next()\n  console.log('m2 end')\n})\n\napp.use(async function m3(next) {\n  console.log('m3')\n  await next()\n  console.log('m3 end')\n})\n\n\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n\ncompose(app.middleware)()\n\n// output:\n// m1\n// m2\n// m3\n// m3 end\n// m2 end\n// m1 end\n```\n\n达到预期结果ahhhhh💐\n\n# summary\n\n当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2","source":"_posts/writeSomething/koa2OnionModel.md","raw":"---\ntitle: 十行代码实现Koa2洋葱模型\ntags:\n  - 封装\n  - koa\n  - 洋葱模型\ndate: 2019-02-22 19:00:00\ncategories: 封装\n---\n\n十行代码实现 `koa2` 洋葱模型\n\n<!--more-->\n\n#### 洋葱图模型\n![avatar](/onion.png)\n\nkoa2上独特的中间件流程控制，是一个典型的洋葱模型\n\n# 运行 koa2 demo\n```js\nconst Koa = require('koa2')\n\nconst app = new Koa()\n\napp.use(async (ctx, next)=>{\n    console.log(1, ' start')\n    await next()\n    console.log(1, ' end')\n})\n\napp.use(async (ctx, next) => {\n    console.log(2, ' start')\n    await next()\n    console.log(2, ' end')\n})\napp.use(async (ctx, next) => {\n    console.log(3, ' start')\n    await next()\n    console.log(3, ' end')\n})\n\napp.listen(3000)\n```\n输出结果：\n```bash\n1 start\n2 start\n3 start\n3 end\n2 end\n1 end\n```\n\n展现如上图洋葱式的输出结果\n\n# 归纳\n\n接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：\n- 首先变为最简case：只有两个中间件函数\n- 那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 `1 start -> 2 start -> 2 end -> 1 end` 的结果\n- 同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n和之前的一篇 [动态规划和递归：从虎羊草开始](https://rollawaypoint.github.io/2019/02/21/writeSomething/dynamicProgrammingAndRecursion/) 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码\n\n# 三步完成封装\n\n第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n```\n\n第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -> 2 -> 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：\n```js\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n```\n\n第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：\n```js\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n```\n\n以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试\n\n# 测试\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n\nconst app = new App\n\napp.use(async function m1(next) {\n  console.log('m1')\n  await next()\n  console.log('m1 end')\n})\n\napp.use(async function m2(next) {\n  console.log('m2')\n  await next()\n  console.log('m2 end')\n})\n\napp.use(async function m3(next) {\n  console.log('m3')\n  await next()\n  console.log('m3 end')\n})\n\n\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n\ncompose(app.middleware)()\n\n// output:\n// m1\n// m2\n// m3\n// m3 end\n// m2 end\n// m1 end\n```\n\n达到预期结果ahhhhh💐\n\n# summary\n\n当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2","slug":"writeSomething/koa2OnionModel","published":1,"updated":"2019-03-11T06:45:51.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxx1001qax48uz0fitg5","content":"<p>十行代码实现 <code>koa2</code> 洋葱模型</p>\n<a id=\"more\"></a>\n<h4 id=\"洋葱图模型\"><a href=\"#洋葱图模型\" class=\"headerlink\" title=\"洋葱图模型\"></a>洋葱图模型</h4><p><img src=\"/2019/02/22/writeSomething/koa2OnionModel/onion.png\" alt=\"avatar\"></p>\n<p>koa2上独特的中间件流程控制，是一个典型的洋葱模型</p>\n<h1 id=\"运行-koa2-demo\"><a href=\"#运行-koa2-demo\" class=\"headerlink\" title=\"运行 koa2 demo\"></a>运行 koa2 demo</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 start</span><br><span class=\"line\">2 start</span><br><span class=\"line\">3 start</span><br><span class=\"line\">3 end</span><br><span class=\"line\">2 end</span><br><span class=\"line\">1 end</span><br></pre></td></tr></table></figure></p>\n<p>展现如上图洋葱式的输出结果</p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><p>接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：</p>\n<ul>\n<li>首先变为最简case：只有两个中间件函数</li>\n<li>那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 <code>1 start -&gt; 2 start -&gt; 2 end -&gt; 1 end</code> 的结果</li>\n<li>同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调</li>\n</ul>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.<br>和之前的一篇 <a href=\"https://rollawaypoint.github.io/2019/02/21/writeSomething/dynamicProgrammingAndRecursion/\">动态规划和递归：从虎羊草开始</a> 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码</p>\n<h1 id=\"三步完成封装\"><a href=\"#三步完成封装\" class=\"headerlink\" title=\"三步完成封装\"></a>三步完成封装</h1><p>第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -&gt; 2 -&gt; 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></p>\n<p>第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> App</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m3</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br><span class=\"line\"></span><br><span class=\"line\">compose(app.middleware)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// m1</span></span><br><span class=\"line\"><span class=\"comment\">// m2</span></span><br><span class=\"line\"><span class=\"comment\">// m3</span></span><br><span class=\"line\"><span class=\"comment\">// m3 end</span></span><br><span class=\"line\"><span class=\"comment\">// m2 end</span></span><br><span class=\"line\"><span class=\"comment\">// m1 end</span></span><br></pre></td></tr></table></figure>\n<p>达到预期结果ahhhhh💐</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2</p>\n","site":{"data":{}},"excerpt":"<p>十行代码实现 <code>koa2</code> 洋葱模型</p>","more":"<h4 id=\"洋葱图模型\"><a href=\"#洋葱图模型\" class=\"headerlink\" title=\"洋葱图模型\"></a>洋葱图模型</h4><p><img src=\"/2019/02/22/writeSomething/koa2OnionModel/onion.png\" alt=\"avatar\"></p>\n<p>koa2上独特的中间件流程控制，是一个典型的洋葱模型</p>\n<h1 id=\"运行-koa2-demo\"><a href=\"#运行-koa2-demo\" class=\"headerlink\" title=\"运行 koa2 demo\"></a>运行 koa2 demo</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 start</span><br><span class=\"line\">2 start</span><br><span class=\"line\">3 start</span><br><span class=\"line\">3 end</span><br><span class=\"line\">2 end</span><br><span class=\"line\">1 end</span><br></pre></td></tr></table></figure></p>\n<p>展现如上图洋葱式的输出结果</p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><p>接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：</p>\n<ul>\n<li>首先变为最简case：只有两个中间件函数</li>\n<li>那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 <code>1 start -&gt; 2 start -&gt; 2 end -&gt; 1 end</code> 的结果</li>\n<li>同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调</li>\n</ul>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.<br>和之前的一篇 <a href=\"https://rollawaypoint.github.io/2019/02/21/writeSomething/dynamicProgrammingAndRecursion/\">动态规划和递归：从虎羊草开始</a> 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码</p>\n<h1 id=\"三步完成封装\"><a href=\"#三步完成封装\" class=\"headerlink\" title=\"三步完成封装\"></a>三步完成封装</h1><p>第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -&gt; 2 -&gt; 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></p>\n<p>第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> App</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m3</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br><span class=\"line\"></span><br><span class=\"line\">compose(app.middleware)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// m1</span></span><br><span class=\"line\"><span class=\"comment\">// m2</span></span><br><span class=\"line\"><span class=\"comment\">// m3</span></span><br><span class=\"line\"><span class=\"comment\">// m3 end</span></span><br><span class=\"line\"><span class=\"comment\">// m2 end</span></span><br><span class=\"line\"><span class=\"comment\">// m1 end</span></span><br></pre></td></tr></table></figure>\n<p>达到预期结果ahhhhh💐</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2</p>"},{"title":"JS/Node的事件循环","date":"2019-03-07T03:21:00.000Z","_content":"\nJS特色之一是单线程，那所谓的基于事件的异步机制是什么？\n<!--more-->\n# JS是单线程\nAll we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8\n另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因\n\n另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步\n\n那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列\n\n# JS事件循环\n类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数\n\n一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行\n\n在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中\n\n每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环\n\n### 宏任务（Macrotask）\n- 整体代码(script)\n- setTimeout\n- setInterval\n- setImmediate（node）\n- I/O\n- UI rendering\n- requestAnimationFrame（浏览器）\n\n### 微任务（Microtask）\n- process.nextTick（node）\n- Promise.then catch finally\n- Object.observe（已废弃）\n- MutationObserver（浏览器）\n\n*括号内表示支持的环境*\n\n### 案例分析\n```js\n// 全局scripts macrotask\nconsole.log('macrotask scripts start')\n\n// macrotask\nsetTimeout(() => {\n  Promise.resolve().then(() => console.log('macrotask 1 inner: microtask'))\n\n  console.log('macrotask 1')\n}, 0)\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 1'))\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 2'))\n\nconsole.log('macrotask scripts end')\n\n// output:\n\n// VM322:1  macrotask scripts start\n// VM322:16 macrotask scripts end\n// VM322:11 microtask 1\n// VM322:14 microtask 2\n// VM322:7  macrotask 1\n// VM322:5  macrotask 1 inner: microtask\n```\n\n首先进入 **全局scripts macrotask**\n  - 执行当前 macrotask 中所有同步代码\n    - // VM322:1  macrotask scripts start\n    - // VM322:16 macrotask scripts end\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:11 microtask 1\n    - // VM322:14 microtask 2\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n  - 新一轮循环执行当前 macrotask 中所有同步代码\n    - // VM322:7  macrotask 1\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:5  macrotask 1 inner: microtask\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n    - 执行完毕结束循环\n\n### 误解\n面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”\n\n- 一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列\n- 键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列\n- setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队\n- ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队\n\n# Node的事件循环\nnode是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行\n\n当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环\n\n与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：\n- timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调\n  * 检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调\n  * 检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- idle, prepare：仅系统内部使用\n- Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒\n首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。\n  * 第一种情况：\n    - 如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调\n    - 检查是否有 process.nextTick 回调，如果有，全部执行\n    - 检查是否有 microtaks，如果有，全部执行\n    - 退出该阶段\n  * 第二种情况：\n    - 如果没有可用回调\n    - 检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知\n    - 如果不存在尚未完成的回调，退出poll阶段\n- Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 check 阶段\n- Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on('close', ...). 用于资源清理\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 closing 阶段\n一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序\n\n事件循环过程如下图示意*每个框内代表一个阶段*：\n\n```js\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n```\n每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段\n\n由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值\n\n在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净\n\n补充：\n1. setImmediate 对比 setTimeout\nsetImmediate 和 setTimeout 很类似，但何时调用行为完全不同\n  - setImmediate 设计为在当前 轮询 阶段完成后执行脚本\n  - setTimeout 计划在毫秒的最小阈值经过后运行的脚本\n执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）\n\n2. process.nextTick\nprocess.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码\n任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段\n\n以上简要介绍JS/Node的事件循环，存在相关错误请指出😄\n\nLink：\n  - [The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)\n  - [深入分析Node.js事件循环](https://blog.csdn.net/i10630226/article/details/81369841)\n\n**end**\n","source":"_posts/writeSomething/EventLoop.md","raw":"---\ntitle: JS/Node的事件循环\ntags:\n  - 事件循环\n  - 任务队列\ndate: 2019-03-07 11:21:00\ncategories: 你应该知道的\n---\n\nJS特色之一是单线程，那所谓的基于事件的异步机制是什么？\n<!--more-->\n# JS是单线程\nAll we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8\n另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因\n\n另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步\n\n那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列\n\n# JS事件循环\n类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数\n\n一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行\n\n在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中\n\n每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环\n\n### 宏任务（Macrotask）\n- 整体代码(script)\n- setTimeout\n- setInterval\n- setImmediate（node）\n- I/O\n- UI rendering\n- requestAnimationFrame（浏览器）\n\n### 微任务（Microtask）\n- process.nextTick（node）\n- Promise.then catch finally\n- Object.observe（已废弃）\n- MutationObserver（浏览器）\n\n*括号内表示支持的环境*\n\n### 案例分析\n```js\n// 全局scripts macrotask\nconsole.log('macrotask scripts start')\n\n// macrotask\nsetTimeout(() => {\n  Promise.resolve().then(() => console.log('macrotask 1 inner: microtask'))\n\n  console.log('macrotask 1')\n}, 0)\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 1'))\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 2'))\n\nconsole.log('macrotask scripts end')\n\n// output:\n\n// VM322:1  macrotask scripts start\n// VM322:16 macrotask scripts end\n// VM322:11 microtask 1\n// VM322:14 microtask 2\n// VM322:7  macrotask 1\n// VM322:5  macrotask 1 inner: microtask\n```\n\n首先进入 **全局scripts macrotask**\n  - 执行当前 macrotask 中所有同步代码\n    - // VM322:1  macrotask scripts start\n    - // VM322:16 macrotask scripts end\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:11 microtask 1\n    - // VM322:14 microtask 2\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n  - 新一轮循环执行当前 macrotask 中所有同步代码\n    - // VM322:7  macrotask 1\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:5  macrotask 1 inner: microtask\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n    - 执行完毕结束循环\n\n### 误解\n面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”\n\n- 一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列\n- 键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列\n- setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队\n- ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队\n\n# Node的事件循环\nnode是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行\n\n当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环\n\n与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：\n- timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调\n  * 检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调\n  * 检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- idle, prepare：仅系统内部使用\n- Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒\n首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。\n  * 第一种情况：\n    - 如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调\n    - 检查是否有 process.nextTick 回调，如果有，全部执行\n    - 检查是否有 microtaks，如果有，全部执行\n    - 退出该阶段\n  * 第二种情况：\n    - 如果没有可用回调\n    - 检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知\n    - 如果不存在尚未完成的回调，退出poll阶段\n- Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 check 阶段\n- Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on('close', ...). 用于资源清理\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 closing 阶段\n一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序\n\n事件循环过程如下图示意*每个框内代表一个阶段*：\n\n```js\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n```\n每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段\n\n由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值\n\n在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净\n\n补充：\n1. setImmediate 对比 setTimeout\nsetImmediate 和 setTimeout 很类似，但何时调用行为完全不同\n  - setImmediate 设计为在当前 轮询 阶段完成后执行脚本\n  - setTimeout 计划在毫秒的最小阈值经过后运行的脚本\n执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）\n\n2. process.nextTick\nprocess.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码\n任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段\n\n以上简要介绍JS/Node的事件循环，存在相关错误请指出😄\n\nLink：\n  - [The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)\n  - [深入分析Node.js事件循环](https://blog.csdn.net/i10630226/article/details/81369841)\n\n**end**\n","slug":"writeSomething/EventLoop","published":1,"updated":"2019-03-07T08:55:50.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxxx003aax48uv8a1jv1","content":"<p>JS特色之一是单线程，那所谓的基于事件的异步机制是什么？<br><a id=\"more\"></a></p>\n<h1 id=\"JS是单线程\"><a href=\"#JS是单线程\" class=\"headerlink\" title=\"JS是单线程\"></a>JS是单线程</h1><p>All we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8<br>另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因</p>\n<p>另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步</p>\n<p>那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列</p>\n<h1 id=\"JS事件循环\"><a href=\"#JS事件循环\" class=\"headerlink\" title=\"JS事件循环\"></a>JS事件循环</h1><p>类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数</p>\n<p>一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行</p>\n<p>在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中</p>\n<p>每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环</p>\n<h3 id=\"宏任务（Macrotask）\"><a href=\"#宏任务（Macrotask）\" class=\"headerlink\" title=\"宏任务（Macrotask）\"></a>宏任务（Macrotask）</h3><ul>\n<li>整体代码(script)</li>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate（node）</li>\n<li>I/O</li>\n<li>UI rendering</li>\n<li>requestAnimationFrame（浏览器）</li>\n</ul>\n<h3 id=\"微任务（Microtask）\"><a href=\"#微任务（Microtask）\" class=\"headerlink\" title=\"微任务（Microtask）\"></a>微任务（Microtask）</h3><ul>\n<li>process.nextTick（node）</li>\n<li>Promise.then catch finally</li>\n<li>Object.observe（已废弃）</li>\n<li>MutationObserver（浏览器）</li>\n</ul>\n<p><em>括号内表示支持的环境</em></p>\n<h3 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局scripts macrotask</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts start'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// macrotask</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1 inner: microtask'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 1'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 2'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts end'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VM322:1  macrotask scripts start</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:16 macrotask scripts end</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:11 microtask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:14 microtask 2</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:7  macrotask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:5  macrotask 1 inner: microtask</span></span><br></pre></td></tr></table></figure>\n<p>首先进入 <strong>全局scripts macrotask</strong></p>\n<ul>\n<li>执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:1  macrotask scripts start</li>\n<li>// VM322:16 macrotask scripts end</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:11 microtask 1</li>\n<li>// VM322:14 microtask 2</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环</li>\n<li>新一轮循环执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:7  macrotask 1</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:5  macrotask 1 inner: microtask</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环<ul>\n<li>执行完毕结束循环</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"误解\"><a href=\"#误解\" class=\"headerlink\" title=\"误解\"></a>误解</h3><p>面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”</p>\n<ul>\n<li>一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列</li>\n<li>键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列</li>\n<li>setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队</li>\n<li>ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队</li>\n</ul>\n<h1 id=\"Node的事件循环\"><a href=\"#Node的事件循环\" class=\"headerlink\" title=\"Node的事件循环\"></a>Node的事件循环</h1><p>node是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行</p>\n<p>当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环</p>\n<p>与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：</p>\n<ul>\n<li>timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调<ul>\n<li>检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调<ul>\n<li>检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>idle, prepare：仅系统内部使用</li>\n<li>Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒<br>首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。<ul>\n<li>第一种情况：<ul>\n<li>如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>第二种情况：<ul>\n<li>如果没有可用回调</li>\n<li>检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知</li>\n<li>如果不存在尚未完成的回调，退出poll阶段</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 check 阶段</li>\n</ul>\n</li>\n<li>Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on(‘close’, …). 用于资源清理<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 closing 阶段<br>一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序</li>\n</ul>\n</li>\n</ul>\n<p>事件循环过程如下图示意<em>每个框内代表一个阶段</em>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   ┌───────────────────────────┐</span><br><span class=\"line\">┌─&gt;│           timers          │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │     pending callbacks     │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │       idle, prepare       │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class=\"line\">│  │           poll            │&lt;─────┤  connections, │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class=\"line\">│  │           check           │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">└──┤      close callbacks      │</span><br><span class=\"line\">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>\n<p>每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段</p>\n<p>由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值</p>\n<p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净</p>\n<p>补充：</p>\n<ol>\n<li><p>setImmediate 对比 setTimeout<br>setImmediate 和 setTimeout 很类似，但何时调用行为完全不同</p>\n<ul>\n<li>setImmediate 设计为在当前 轮询 阶段完成后执行脚本</li>\n<li>setTimeout 计划在毫秒的最小阈值经过后运行的脚本<br>执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）</li>\n</ul>\n</li>\n<li><p>process.nextTick<br>process.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码<br>任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段</p>\n</li>\n</ol>\n<p>以上简要介绍JS/Node的事件循环，存在相关错误请指出😄</p>\n<p>Link：</p>\n<ul>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"noopener\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n<li><a href=\"https://blog.csdn.net/i10630226/article/details/81369841\" target=\"_blank\" rel=\"noopener\">深入分析Node.js事件循环</a></li>\n</ul>\n<p><strong>end</strong></p>\n","site":{"data":{}},"excerpt":"<p>JS特色之一是单线程，那所谓的基于事件的异步机制是什么？<br></p>","more":"<p></p>\n<h1 id=\"JS是单线程\"><a href=\"#JS是单线程\" class=\"headerlink\" title=\"JS是单线程\"></a>JS是单线程</h1><p>All we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8<br>另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因</p>\n<p>另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步</p>\n<p>那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列</p>\n<h1 id=\"JS事件循环\"><a href=\"#JS事件循环\" class=\"headerlink\" title=\"JS事件循环\"></a>JS事件循环</h1><p>类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数</p>\n<p>一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行</p>\n<p>在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中</p>\n<p>每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环</p>\n<h3 id=\"宏任务（Macrotask）\"><a href=\"#宏任务（Macrotask）\" class=\"headerlink\" title=\"宏任务（Macrotask）\"></a>宏任务（Macrotask）</h3><ul>\n<li>整体代码(script)</li>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate（node）</li>\n<li>I/O</li>\n<li>UI rendering</li>\n<li>requestAnimationFrame（浏览器）</li>\n</ul>\n<h3 id=\"微任务（Microtask）\"><a href=\"#微任务（Microtask）\" class=\"headerlink\" title=\"微任务（Microtask）\"></a>微任务（Microtask）</h3><ul>\n<li>process.nextTick（node）</li>\n<li>Promise.then catch finally</li>\n<li>Object.observe（已废弃）</li>\n<li>MutationObserver（浏览器）</li>\n</ul>\n<p><em>括号内表示支持的环境</em></p>\n<h3 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局scripts macrotask</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts start'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// macrotask</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1 inner: microtask'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 1'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 2'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts end'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VM322:1  macrotask scripts start</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:16 macrotask scripts end</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:11 microtask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:14 microtask 2</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:7  macrotask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:5  macrotask 1 inner: microtask</span></span><br></pre></td></tr></table></figure>\n<p>首先进入 <strong>全局scripts macrotask</strong></p>\n<ul>\n<li>执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:1  macrotask scripts start</li>\n<li>// VM322:16 macrotask scripts end</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:11 microtask 1</li>\n<li>// VM322:14 microtask 2</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环</li>\n<li>新一轮循环执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:7  macrotask 1</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:5  macrotask 1 inner: microtask</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环<ul>\n<li>执行完毕结束循环</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"误解\"><a href=\"#误解\" class=\"headerlink\" title=\"误解\"></a>误解</h3><p>面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”</p>\n<ul>\n<li>一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列</li>\n<li>键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列</li>\n<li>setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队</li>\n<li>ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队</li>\n</ul>\n<h1 id=\"Node的事件循环\"><a href=\"#Node的事件循环\" class=\"headerlink\" title=\"Node的事件循环\"></a>Node的事件循环</h1><p>node是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行</p>\n<p>当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环</p>\n<p>与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：</p>\n<ul>\n<li>timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调<ul>\n<li>检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调<ul>\n<li>检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>idle, prepare：仅系统内部使用</li>\n<li>Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒<br>首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。<ul>\n<li>第一种情况：<ul>\n<li>如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>第二种情况：<ul>\n<li>如果没有可用回调</li>\n<li>检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知</li>\n<li>如果不存在尚未完成的回调，退出poll阶段</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 check 阶段</li>\n</ul>\n</li>\n<li>Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on(‘close’, …). 用于资源清理<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 closing 阶段<br>一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序</li>\n</ul>\n</li>\n</ul>\n<p>事件循环过程如下图示意<em>每个框内代表一个阶段</em>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   ┌───────────────────────────┐</span><br><span class=\"line\">┌─&gt;│           timers          │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │     pending callbacks     │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │       idle, prepare       │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class=\"line\">│  │           poll            │&lt;─────┤  connections, │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class=\"line\">│  │           check           │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">└──┤      close callbacks      │</span><br><span class=\"line\">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>\n<p>每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段</p>\n<p>由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值</p>\n<p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净</p>\n<p>补充：</p>\n<ol>\n<li><p>setImmediate 对比 setTimeout<br>setImmediate 和 setTimeout 很类似，但何时调用行为完全不同</p>\n<ul>\n<li>setImmediate 设计为在当前 轮询 阶段完成后执行脚本</li>\n<li>setTimeout 计划在毫秒的最小阈值经过后运行的脚本<br>执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）</li>\n</ul>\n</li>\n<li><p>process.nextTick<br>process.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码<br>任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段</p>\n</li>\n</ol>\n<p>以上简要介绍JS/Node的事件循环，存在相关错误请指出😄</p>\n<p>Link：</p>\n<ul>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"noopener\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n<li><a href=\"https://blog.csdn.net/i10630226/article/details/81369841\" target=\"_blank\" rel=\"noopener\">深入分析Node.js事件循环</a></li>\n</ul>\n<p><strong>end</strong></p>"},{"title":"使用ts封装一个fetch请求库---拦截器promise链的提前终止","date":"2019-05-21T06:30:00.000Z","_content":"当你的promise链某一个环节需要显式的抛出异常，这个时候后面的所有剩余的then回调其实就不必要执行，那么如何终止这个Promise链呢\n\n`记录帖`\n\n<!-- more -->\n\n> 处理拦截器回调的 `curl` 方法 [curl](https://rollawaypoint.github.io/2019/04/13/writeSomething/Fetch_1/#%E6%9E%84%E9%80%A0curl%E6%96%B9%E6%B3%95)\n\n代码：\n```js\n/**\n* @main 拦截器入栈\n* @description request前置，response后置\n*/\n// this.interceptors.request.reducer((fns) => {\n//   chain.unshift(fns);\n// });\n\n// this.interceptors.response.reducer((fns) => {\n//   chain.push(fns);\n// });\nconst chain = [\n  ...this.interceptors.request.handlers,\n  [dispatchRequest, undefined],\n  ...this.interceptors.response.handlers,\n];\n\n/**\n  * @main promise链调用\n  */\nreturn chain.reduce(\n  (promise, interceptors) => (promise = promise.then(...interceptors)),\n  Promise.resolve(options),\n);\n```\n\n想到这个问题的时候真的是百思不得其解，试图请教交流群的“大佬”，得到的答复全是“既然你使用promise那就是一个承诺，现在突然告诉他你的承诺不算话了违背promise”、“为什么用reduce”、“用rxjs解决一切”，etc...\n\n难受，难道就没有hack的方式吗？\n\n正常情况是需要主动抛出异常之后，然后在接下来promise所有catch回调中都要交进行接收Error和抛出Error（难以忍受这种工作）\n```js\ndoSth()\n.then(value => {\n  if (sthErrorOccured()) {\n    throw new Error('BIG_ERROR')\n  }\n  // normal logic\n})\n.catch(reason => {\n  if (reason.message === 'BIG_ERROR') {\n    throw reason\n  }\n  // normal logic\n})\n.then()\n.catch(reason => {\n  if (reason.message === 'BIG_ERROR') {\n    throw reason\n  }\n  // normal logic\n})\n.then()\n.catch(reason => {\n  if (reason.message === 'BIG_ERROR') {\n    throw reason\n  }\n  // normal logic\n})\n```\n这种方案的问题在于，你需要在每一个catch里多写一个if来判断这个特殊的Error，繁琐不说，还增加了耦合度以及重构的困难。\n\n如果有什么办法能直接在发生这种错误后停止后面所有Promise链的执行，我们就不需要在每个catch里检测这种错误了，只需要编写处理该catch块本应处理的错误的代码就可以了。\n\n**有没有办法不在每个catch里做这种判断呢？**\n\n办法确实是有的，那就是在发生无法继续的错误后，直接返回一个始终不resolve也不reject的Promise，即这个Promise永远处于pending状态，那么后面的Promise链当然也就一直不会执行了，因为会一直等着。类似下面这样的代码\n```js\nPromise.stop = function() {\n  return new Promise(function(){})\n}\n\ndoSth()\n.then(value => {\n  if (sthBigErrorOccured()) {\n    return Promise.stop()\n  }\n  // normal logic\n})\n.catch(reason => {// will never get called\n  // normal logic\n})\n.then()\n.catch(reason => {// will never get called\n  // normal logic\n})\n.then()\n.catch(reason => {// will never get called\n  // normal logic\n})\n```\n这种方案的好处在于你几乎不需要更改任何现有代码，而且兼容性也非常好，不管你使用的哪个Promise库，甚至是不同的Promise之间相互调用，都可以达到目的。\n\n然而这个方案有一个不那么明显的缺陷，那就是会造成潜在的内存泄露。\n\n试想，当你把回调函数传给Promise的then方法后，如果这时Promise的状态还没有确定下来，那么Promise实例肯定会在内部保留这些回调函数的引用；在一个robust的实现中，回调函数在执行完成后，Promise实例应该会释放掉这些回调函数的引用。如果使用上述方案，那么返回一个永远处于pending状态的Promise之后的Promise链上的所有Promise都将处于pending状态，这意味着后面所有的回调函数的内存将一直得不到释放。在简单的页面里使用这种方案也许还行得通，但在WebApp或者Node里，这种方案明显是不可接受的。\n\n**那有没有办法即达到停止后面的链，同时又避免内存泄露呢。**\n\n让我们回到一开始的思路，我们在Promise链上所有的catch里都加上一句if，来判断传来的错误是否为一个无法处理的错误，如果是则一直往后面抛，这样就达到了即没有运行后面的逻辑，又避免了内存泄露的问题。\n\n这是一个高度一致的逻辑，我们当然可以把它抽离出来。我们可以实现一个叫next的函数，挂在Promise.prototype上面，然后在里面判断是否是我们能处理的错误，如果是，则执行回调，如果不是，则一直往下传：\n```js\nvar BIG_ERROR = new Error('BIG_ERROR')\n\nPromise.prototype.next = function(onResolved, onRejected) {\n  return this.then(function(value) {\n    if (value === BIG_ERROR) {\n      return BIG_ERROR\n    } else {\n      return onResolved(value)\n    }\n  }, onRejected)\n}\n\ndoSth()\n.next(function(value) {\n  if (sthBigErrorOccured()) {\n    return BIG_ERROR\n  }\n  // normal logic\n})\n.next(value => {\n  // will never get called\n})\n```\n进一步，如果把上面代码中“致命错误”的语义换成“跳过后面所有的Promise”，我们就可以得到跳过后续Promise的方式了：\n```js\nvar STOP_SUBSEQUENT_PROMISE_CHAIN = new Error()\n\nPromise.prototype.next = function(onResolved, onRejected) {\n  return this.then(function(value) {\n    if (value === STOP_SUBSEQUENT_PROMISE_CHAIN) {\n      return STOP_SUBSEQUENT_PROMISE_CHAIN\n    } else {\n      return onResolved(value)\n    }\n  }, onRejected)\n}\n\ndoSth()\n.next(function(value) {\n  if (sthBigErrorOccured()) {\n    return STOP_SUBSEQUENT_PROMISE_CHAIN\n  }\n  // normal logic\n})\n.next(value => {\n  // will never get called\n})\n```\n为了更明显的语义，我们可以把“跳过后面所有的Promise”单独封装成一个Promise：\n```js\nvar STOP = {}\nPromise.stop = function(){\n  return Promise.resolve(STOP)\n}\n\nPromise.prototype.next = function(onResolved, onRejected) {\n  return this.then(function(value) {\n    if (value === STOP) {\n      return STOP\n    } else {\n      return onResolved(value)\n    }\n  }, onRejected)\n}\n\ndoSth()\n.next(function(value) {\n  if (sthBigErrorOccured()) {\n    return Promise.stop()\n  }\n  // normal logic\n})\n.next(value => {\n  // will never get called\n})\n```\n这样就实现了在语义明确的情况下，不造成内存泄露，而且还停止了后面的Promise链。\n\n为了对现有代码尽量少做改动，我们甚至可以不用新增next方法而是直接重写then：\n```js\n(function() {\n  var STOP_VALUE = Symbol()//构造一个Symbol以表达特殊的语义\n  var STOPPER_PROMISE = Promise.resolve(STOP_VALUE)\n\n  Promise.prototype._then = Promise.prototype.then\n\n  Promise.stop = function() {\n    return STOPPER_PROMISE//不是每次返回一个新的Promise，可以节省内存\n  }\n\n  Promise.prototype.then = function(onResolved, onRejected) {\n    return this._then(function(value) {\n      return value === STOP_VALUE ? STOP_VALUE : onResolved(value)\n    }, onRejected)\n  }\n}())\n\nPromise.resolve(8).then(v => {\n  console.log(v)\n  return 9\n}).then(v => {\n  console.log(v)\n  return Promise.stop()//较为明确的语义\n}).catch(function(){// will never called but will be GCed\n  console.log('catch')\n}).then(function(){// will never called but will be GCed\n  console.log('then')\n})\n```\n以上对then的重写并不会造成什么问题，闭包里的对象在外界是访问不到，外界也永远也无法构造出一个跟闭包里Symbol一样的对象，考虑到我们只需要构造一个外界无法“===”的对象，我们完全可以用一个Object来代替：\n```js\n(function() {\n  var STOP_VALUE = {}//只要外界无法“===”这个对象就可以了\n  var STOPPER_PROMISE = Promise.resolve(STOP_VALUE)\n\n  Promise.prototype._then = Promise.prototype.then\n\n  Promise.stop = function() {\n    return STOPPER_PROMISE//不是每次返回一个新的Promise，可以节省内存\n  }\n\n  Promise.prototype.then = function(onResolved, onRejected) {\n    return this._then(function(value) {\n      return value === STOP_VALUE ? STOP_VALUE : onResolved(value)\n    }, onRejected)\n  }\n}())\n\nPromise.resolve(8).then(v => {\n  console.log(v)\n  return 9\n}).then(v => {\n  console.log(v)\n  return Promise.stop()//较为明确的语义\n}).catch(function(){// will never called but will be GCed\n  console.log('catch')\n}).then(function(){// will never called but will be GCed\n  console.log('then')\n})\n```\n这个方案的另一个好处（好处之一是不会造成内存泄露）是可以让你非常平滑地（甚至是一次性的）从“返回一个永远pending的Promise”过度到这个方案，因为代码及其语义都基本没有变化。在之前，你可以定义一个Promise.stop()方法来返回一个永远pending的Promise；在之后，Promise.stop()返回一个外界无法得到的值，用以表达“跳过后面所有的Promise”，然后在我们重写的then方法里使用。\n\n这样就解决了停止Promise链这样一个让人纠结的问题。\n\nLink:\n> [从如何停掉 Promise 链说起](https://github.com/xieranmaya/blog/issues/5)\n","source":"_posts/writeSomething/Fetch_2.md","raw":"---\ntitle: 使用ts封装一个fetch请求库---拦截器promise链的提前终止\ntags:\n  - fetch\ndate: 2019-05-21 14:30:00\ncategories: 封装\n---\n当你的promise链某一个环节需要显式的抛出异常，这个时候后面的所有剩余的then回调其实就不必要执行，那么如何终止这个Promise链呢\n\n`记录帖`\n\n<!-- more -->\n\n> 处理拦截器回调的 `curl` 方法 [curl](https://rollawaypoint.github.io/2019/04/13/writeSomething/Fetch_1/#%E6%9E%84%E9%80%A0curl%E6%96%B9%E6%B3%95)\n\n代码：\n```js\n/**\n* @main 拦截器入栈\n* @description request前置，response后置\n*/\n// this.interceptors.request.reducer((fns) => {\n//   chain.unshift(fns);\n// });\n\n// this.interceptors.response.reducer((fns) => {\n//   chain.push(fns);\n// });\nconst chain = [\n  ...this.interceptors.request.handlers,\n  [dispatchRequest, undefined],\n  ...this.interceptors.response.handlers,\n];\n\n/**\n  * @main promise链调用\n  */\nreturn chain.reduce(\n  (promise, interceptors) => (promise = promise.then(...interceptors)),\n  Promise.resolve(options),\n);\n```\n\n想到这个问题的时候真的是百思不得其解，试图请教交流群的“大佬”，得到的答复全是“既然你使用promise那就是一个承诺，现在突然告诉他你的承诺不算话了违背promise”、“为什么用reduce”、“用rxjs解决一切”，etc...\n\n难受，难道就没有hack的方式吗？\n\n正常情况是需要主动抛出异常之后，然后在接下来promise所有catch回调中都要交进行接收Error和抛出Error（难以忍受这种工作）\n```js\ndoSth()\n.then(value => {\n  if (sthErrorOccured()) {\n    throw new Error('BIG_ERROR')\n  }\n  // normal logic\n})\n.catch(reason => {\n  if (reason.message === 'BIG_ERROR') {\n    throw reason\n  }\n  // normal logic\n})\n.then()\n.catch(reason => {\n  if (reason.message === 'BIG_ERROR') {\n    throw reason\n  }\n  // normal logic\n})\n.then()\n.catch(reason => {\n  if (reason.message === 'BIG_ERROR') {\n    throw reason\n  }\n  // normal logic\n})\n```\n这种方案的问题在于，你需要在每一个catch里多写一个if来判断这个特殊的Error，繁琐不说，还增加了耦合度以及重构的困难。\n\n如果有什么办法能直接在发生这种错误后停止后面所有Promise链的执行，我们就不需要在每个catch里检测这种错误了，只需要编写处理该catch块本应处理的错误的代码就可以了。\n\n**有没有办法不在每个catch里做这种判断呢？**\n\n办法确实是有的，那就是在发生无法继续的错误后，直接返回一个始终不resolve也不reject的Promise，即这个Promise永远处于pending状态，那么后面的Promise链当然也就一直不会执行了，因为会一直等着。类似下面这样的代码\n```js\nPromise.stop = function() {\n  return new Promise(function(){})\n}\n\ndoSth()\n.then(value => {\n  if (sthBigErrorOccured()) {\n    return Promise.stop()\n  }\n  // normal logic\n})\n.catch(reason => {// will never get called\n  // normal logic\n})\n.then()\n.catch(reason => {// will never get called\n  // normal logic\n})\n.then()\n.catch(reason => {// will never get called\n  // normal logic\n})\n```\n这种方案的好处在于你几乎不需要更改任何现有代码，而且兼容性也非常好，不管你使用的哪个Promise库，甚至是不同的Promise之间相互调用，都可以达到目的。\n\n然而这个方案有一个不那么明显的缺陷，那就是会造成潜在的内存泄露。\n\n试想，当你把回调函数传给Promise的then方法后，如果这时Promise的状态还没有确定下来，那么Promise实例肯定会在内部保留这些回调函数的引用；在一个robust的实现中，回调函数在执行完成后，Promise实例应该会释放掉这些回调函数的引用。如果使用上述方案，那么返回一个永远处于pending状态的Promise之后的Promise链上的所有Promise都将处于pending状态，这意味着后面所有的回调函数的内存将一直得不到释放。在简单的页面里使用这种方案也许还行得通，但在WebApp或者Node里，这种方案明显是不可接受的。\n\n**那有没有办法即达到停止后面的链，同时又避免内存泄露呢。**\n\n让我们回到一开始的思路，我们在Promise链上所有的catch里都加上一句if，来判断传来的错误是否为一个无法处理的错误，如果是则一直往后面抛，这样就达到了即没有运行后面的逻辑，又避免了内存泄露的问题。\n\n这是一个高度一致的逻辑，我们当然可以把它抽离出来。我们可以实现一个叫next的函数，挂在Promise.prototype上面，然后在里面判断是否是我们能处理的错误，如果是，则执行回调，如果不是，则一直往下传：\n```js\nvar BIG_ERROR = new Error('BIG_ERROR')\n\nPromise.prototype.next = function(onResolved, onRejected) {\n  return this.then(function(value) {\n    if (value === BIG_ERROR) {\n      return BIG_ERROR\n    } else {\n      return onResolved(value)\n    }\n  }, onRejected)\n}\n\ndoSth()\n.next(function(value) {\n  if (sthBigErrorOccured()) {\n    return BIG_ERROR\n  }\n  // normal logic\n})\n.next(value => {\n  // will never get called\n})\n```\n进一步，如果把上面代码中“致命错误”的语义换成“跳过后面所有的Promise”，我们就可以得到跳过后续Promise的方式了：\n```js\nvar STOP_SUBSEQUENT_PROMISE_CHAIN = new Error()\n\nPromise.prototype.next = function(onResolved, onRejected) {\n  return this.then(function(value) {\n    if (value === STOP_SUBSEQUENT_PROMISE_CHAIN) {\n      return STOP_SUBSEQUENT_PROMISE_CHAIN\n    } else {\n      return onResolved(value)\n    }\n  }, onRejected)\n}\n\ndoSth()\n.next(function(value) {\n  if (sthBigErrorOccured()) {\n    return STOP_SUBSEQUENT_PROMISE_CHAIN\n  }\n  // normal logic\n})\n.next(value => {\n  // will never get called\n})\n```\n为了更明显的语义，我们可以把“跳过后面所有的Promise”单独封装成一个Promise：\n```js\nvar STOP = {}\nPromise.stop = function(){\n  return Promise.resolve(STOP)\n}\n\nPromise.prototype.next = function(onResolved, onRejected) {\n  return this.then(function(value) {\n    if (value === STOP) {\n      return STOP\n    } else {\n      return onResolved(value)\n    }\n  }, onRejected)\n}\n\ndoSth()\n.next(function(value) {\n  if (sthBigErrorOccured()) {\n    return Promise.stop()\n  }\n  // normal logic\n})\n.next(value => {\n  // will never get called\n})\n```\n这样就实现了在语义明确的情况下，不造成内存泄露，而且还停止了后面的Promise链。\n\n为了对现有代码尽量少做改动，我们甚至可以不用新增next方法而是直接重写then：\n```js\n(function() {\n  var STOP_VALUE = Symbol()//构造一个Symbol以表达特殊的语义\n  var STOPPER_PROMISE = Promise.resolve(STOP_VALUE)\n\n  Promise.prototype._then = Promise.prototype.then\n\n  Promise.stop = function() {\n    return STOPPER_PROMISE//不是每次返回一个新的Promise，可以节省内存\n  }\n\n  Promise.prototype.then = function(onResolved, onRejected) {\n    return this._then(function(value) {\n      return value === STOP_VALUE ? STOP_VALUE : onResolved(value)\n    }, onRejected)\n  }\n}())\n\nPromise.resolve(8).then(v => {\n  console.log(v)\n  return 9\n}).then(v => {\n  console.log(v)\n  return Promise.stop()//较为明确的语义\n}).catch(function(){// will never called but will be GCed\n  console.log('catch')\n}).then(function(){// will never called but will be GCed\n  console.log('then')\n})\n```\n以上对then的重写并不会造成什么问题，闭包里的对象在外界是访问不到，外界也永远也无法构造出一个跟闭包里Symbol一样的对象，考虑到我们只需要构造一个外界无法“===”的对象，我们完全可以用一个Object来代替：\n```js\n(function() {\n  var STOP_VALUE = {}//只要外界无法“===”这个对象就可以了\n  var STOPPER_PROMISE = Promise.resolve(STOP_VALUE)\n\n  Promise.prototype._then = Promise.prototype.then\n\n  Promise.stop = function() {\n    return STOPPER_PROMISE//不是每次返回一个新的Promise，可以节省内存\n  }\n\n  Promise.prototype.then = function(onResolved, onRejected) {\n    return this._then(function(value) {\n      return value === STOP_VALUE ? STOP_VALUE : onResolved(value)\n    }, onRejected)\n  }\n}())\n\nPromise.resolve(8).then(v => {\n  console.log(v)\n  return 9\n}).then(v => {\n  console.log(v)\n  return Promise.stop()//较为明确的语义\n}).catch(function(){// will never called but will be GCed\n  console.log('catch')\n}).then(function(){// will never called but will be GCed\n  console.log('then')\n})\n```\n这个方案的另一个好处（好处之一是不会造成内存泄露）是可以让你非常平滑地（甚至是一次性的）从“返回一个永远pending的Promise”过度到这个方案，因为代码及其语义都基本没有变化。在之前，你可以定义一个Promise.stop()方法来返回一个永远pending的Promise；在之后，Promise.stop()返回一个外界无法得到的值，用以表达“跳过后面所有的Promise”，然后在我们重写的then方法里使用。\n\n这样就解决了停止Promise链这样一个让人纠结的问题。\n\nLink:\n> [从如何停掉 Promise 链说起](https://github.com/xieranmaya/blog/issues/5)\n","slug":"writeSomething/Fetch_2","published":1,"updated":"2019-05-21T07:01:17.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxxz003bax48srd4qt4d","content":"<p>当你的promise链某一个环节需要显式的抛出异常，这个时候后面的所有剩余的then回调其实就不必要执行，那么如何终止这个Promise链呢</p>\n<p><code>记录帖</code></p>\n<a id=\"more\"></a>\n<blockquote>\n<p>处理拦截器回调的 <code>curl</code> 方法 <a href=\"https://rollawaypoint.github.io/2019/04/13/writeSomething/Fetch_1/#%E6%9E%84%E9%80%A0curl%E6%96%B9%E6%B3%95\">curl</a></p>\n</blockquote>\n<p>代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* @main 拦截器入栈</span></span><br><span class=\"line\"><span class=\"comment\">* @description request前置，response后置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// this.interceptors.request.reducer((fns) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   chain.unshift(fns);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this.interceptors.response.reducer((fns) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   chain.push(fns);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;);</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chain = [</span><br><span class=\"line\">  ...this.interceptors.request.handlers,</span><br><span class=\"line\">  [dispatchRequest, <span class=\"literal\">undefined</span>],</span><br><span class=\"line\">  ...this.interceptors.response.handlers,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @main promise链调用</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> chain.reduce(</span><br><span class=\"line\">  (promise, interceptors) =&gt; (promise = promise.then(...interceptors)),</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve(options),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>想到这个问题的时候真的是百思不得其解，试图请教交流群的“大佬”，得到的答复全是“既然你使用promise那就是一个承诺，现在突然告诉他你的承诺不算话了违背promise”、“为什么用reduce”、“用rxjs解决一切”，etc…</p>\n<p>难受，难道就没有hack的方式吗？</p>\n<p>正常情况是需要主动抛出异常之后，然后在接下来promise所有catch回调中都要交进行接收Error和抛出Error（难以忍受这种工作）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSth()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sthErrorOccured()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'BIG_ERROR'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (reason.message === <span class=\"string\">'BIG_ERROR'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then()</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (reason.message === <span class=\"string\">'BIG_ERROR'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then()</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (reason.message === <span class=\"string\">'BIG_ERROR'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这种方案的问题在于，你需要在每一个catch里多写一个if来判断这个特殊的Error，繁琐不说，还增加了耦合度以及重构的困难。</p>\n<p>如果有什么办法能直接在发生这种错误后停止后面所有Promise链的执行，我们就不需要在每个catch里检测这种错误了，只需要编写处理该catch块本应处理的错误的代码就可以了。</p>\n<p><strong>有没有办法不在每个catch里做这种判断呢？</strong></p>\n<p>办法确实是有的，那就是在发生无法继续的错误后，直接返回一个始终不resolve也不reject的Promise，即这个Promise永远处于pending状态，那么后面的Promise链当然也就一直不会执行了，因为会一直等着。类似下面这样的代码<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.stop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSth()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sthBigErrorOccured()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.stop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;<span class=\"comment\">// will never get called</span></span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then()</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;<span class=\"comment\">// will never get called</span></span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then()</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;<span class=\"comment\">// will never get called</span></span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这种方案的好处在于你几乎不需要更改任何现有代码，而且兼容性也非常好，不管你使用的哪个Promise库，甚至是不同的Promise之间相互调用，都可以达到目的。</p>\n<p>然而这个方案有一个不那么明显的缺陷，那就是会造成潜在的内存泄露。</p>\n<p>试想，当你把回调函数传给Promise的then方法后，如果这时Promise的状态还没有确定下来，那么Promise实例肯定会在内部保留这些回调函数的引用；在一个robust的实现中，回调函数在执行完成后，Promise实例应该会释放掉这些回调函数的引用。如果使用上述方案，那么返回一个永远处于pending状态的Promise之后的Promise链上的所有Promise都将处于pending状态，这意味着后面所有的回调函数的内存将一直得不到释放。在简单的页面里使用这种方案也许还行得通，但在WebApp或者Node里，这种方案明显是不可接受的。</p>\n<p><strong>那有没有办法即达到停止后面的链，同时又避免内存泄露呢。</strong></p>\n<p>让我们回到一开始的思路，我们在Promise链上所有的catch里都加上一句if，来判断传来的错误是否为一个无法处理的错误，如果是则一直往后面抛，这样就达到了即没有运行后面的逻辑，又避免了内存泄露的问题。</p>\n<p>这是一个高度一致的逻辑，我们当然可以把它抽离出来。我们可以实现一个叫next的函数，挂在Promise.prototype上面，然后在里面判断是否是我们能处理的错误，如果是，则执行回调，如果不是，则一直往下传：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> BIG_ERROR = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'BIG_ERROR'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === BIG_ERROR) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> BIG_ERROR</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> onResolved(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, onRejected)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSth()</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sthBigErrorOccured()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BIG_ERROR</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// will never get called</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>进一步，如果把上面代码中“致命错误”的语义换成“跳过后面所有的Promise”，我们就可以得到跳过后续Promise的方式了：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> STOP_SUBSEQUENT_PROMISE_CHAIN = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === STOP_SUBSEQUENT_PROMISE_CHAIN) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> STOP_SUBSEQUENT_PROMISE_CHAIN</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> onResolved(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, onRejected)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSth()</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sthBigErrorOccured()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> STOP_SUBSEQUENT_PROMISE_CHAIN</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// will never get called</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>为了更明显的语义，我们可以把“跳过后面所有的Promise”单独封装成一个Promise：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> STOP = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.stop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(STOP)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === STOP) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> STOP</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> onResolved(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, onRejected)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSth()</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sthBigErrorOccured()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.stop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// will never get called</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这样就实现了在语义明确的情况下，不造成内存泄露，而且还停止了后面的Promise链。</p>\n<p>为了对现有代码尽量少做改动，我们甚至可以不用新增next方法而是直接重写then：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> STOP_VALUE = <span class=\"built_in\">Symbol</span>()<span class=\"comment\">//构造一个Symbol以表达特殊的语义</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> STOPPER_PROMISE = <span class=\"built_in\">Promise</span>.resolve(STOP_VALUE)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype._then = <span class=\"built_in\">Promise</span>.prototype.then</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.stop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> STOPPER_PROMISE<span class=\"comment\">//不是每次返回一个新的Promise，可以节省内存</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value === STOP_VALUE ? STOP_VALUE : onResolved(value)</span><br><span class=\"line\">    &#125;, onRejected)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">8</span>).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">9</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.stop()<span class=\"comment\">//较为明确的语义</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">// will never called but will be GCed</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'catch'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">// will never called but will be GCed</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'then'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>以上对then的重写并不会造成什么问题，闭包里的对象在外界是访问不到，外界也永远也无法构造出一个跟闭包里Symbol一样的对象，考虑到我们只需要构造一个外界无法“===”的对象，我们完全可以用一个Object来代替：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> STOP_VALUE = &#123;&#125;<span class=\"comment\">//只要外界无法“===”这个对象就可以了</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> STOPPER_PROMISE = <span class=\"built_in\">Promise</span>.resolve(STOP_VALUE)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype._then = <span class=\"built_in\">Promise</span>.prototype.then</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.stop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> STOPPER_PROMISE<span class=\"comment\">//不是每次返回一个新的Promise，可以节省内存</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value === STOP_VALUE ? STOP_VALUE : onResolved(value)</span><br><span class=\"line\">    &#125;, onRejected)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">8</span>).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">9</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.stop()<span class=\"comment\">//较为明确的语义</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">// will never called but will be GCed</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'catch'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">// will never called but will be GCed</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'then'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这个方案的另一个好处（好处之一是不会造成内存泄露）是可以让你非常平滑地（甚至是一次性的）从“返回一个永远pending的Promise”过度到这个方案，因为代码及其语义都基本没有变化。在之前，你可以定义一个Promise.stop()方法来返回一个永远pending的Promise；在之后，Promise.stop()返回一个外界无法得到的值，用以表达“跳过后面所有的Promise”，然后在我们重写的then方法里使用。</p>\n<p>这样就解决了停止Promise链这样一个让人纠结的问题。</p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://github.com/xieranmaya/blog/issues/5\" target=\"_blank\" rel=\"noopener\">从如何停掉 Promise 链说起</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>当你的promise链某一个环节需要显式的抛出异常，这个时候后面的所有剩余的then回调其实就不必要执行，那么如何终止这个Promise链呢</p>\n<p><code>记录帖</code></p>","more":"<blockquote>\n<p>处理拦截器回调的 <code>curl</code> 方法 <a href=\"https://rollawaypoint.github.io/2019/04/13/writeSomething/Fetch_1/#%E6%9E%84%E9%80%A0curl%E6%96%B9%E6%B3%95\">curl</a></p>\n</blockquote>\n<p>代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* @main 拦截器入栈</span></span><br><span class=\"line\"><span class=\"comment\">* @description request前置，response后置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// this.interceptors.request.reducer((fns) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   chain.unshift(fns);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this.interceptors.response.reducer((fns) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   chain.push(fns);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;);</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chain = [</span><br><span class=\"line\">  ...this.interceptors.request.handlers,</span><br><span class=\"line\">  [dispatchRequest, <span class=\"literal\">undefined</span>],</span><br><span class=\"line\">  ...this.interceptors.response.handlers,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @main promise链调用</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> chain.reduce(</span><br><span class=\"line\">  (promise, interceptors) =&gt; (promise = promise.then(...interceptors)),</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve(options),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>想到这个问题的时候真的是百思不得其解，试图请教交流群的“大佬”，得到的答复全是“既然你使用promise那就是一个承诺，现在突然告诉他你的承诺不算话了违背promise”、“为什么用reduce”、“用rxjs解决一切”，etc…</p>\n<p>难受，难道就没有hack的方式吗？</p>\n<p>正常情况是需要主动抛出异常之后，然后在接下来promise所有catch回调中都要交进行接收Error和抛出Error（难以忍受这种工作）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSth()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sthErrorOccured()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'BIG_ERROR'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (reason.message === <span class=\"string\">'BIG_ERROR'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then()</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (reason.message === <span class=\"string\">'BIG_ERROR'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then()</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (reason.message === <span class=\"string\">'BIG_ERROR'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这种方案的问题在于，你需要在每一个catch里多写一个if来判断这个特殊的Error，繁琐不说，还增加了耦合度以及重构的困难。</p>\n<p>如果有什么办法能直接在发生这种错误后停止后面所有Promise链的执行，我们就不需要在每个catch里检测这种错误了，只需要编写处理该catch块本应处理的错误的代码就可以了。</p>\n<p><strong>有没有办法不在每个catch里做这种判断呢？</strong></p>\n<p>办法确实是有的，那就是在发生无法继续的错误后，直接返回一个始终不resolve也不reject的Promise，即这个Promise永远处于pending状态，那么后面的Promise链当然也就一直不会执行了，因为会一直等着。类似下面这样的代码<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.stop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSth()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sthBigErrorOccured()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.stop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;<span class=\"comment\">// will never get called</span></span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then()</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;<span class=\"comment\">// will never get called</span></span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then()</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;<span class=\"comment\">// will never get called</span></span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这种方案的好处在于你几乎不需要更改任何现有代码，而且兼容性也非常好，不管你使用的哪个Promise库，甚至是不同的Promise之间相互调用，都可以达到目的。</p>\n<p>然而这个方案有一个不那么明显的缺陷，那就是会造成潜在的内存泄露。</p>\n<p>试想，当你把回调函数传给Promise的then方法后，如果这时Promise的状态还没有确定下来，那么Promise实例肯定会在内部保留这些回调函数的引用；在一个robust的实现中，回调函数在执行完成后，Promise实例应该会释放掉这些回调函数的引用。如果使用上述方案，那么返回一个永远处于pending状态的Promise之后的Promise链上的所有Promise都将处于pending状态，这意味着后面所有的回调函数的内存将一直得不到释放。在简单的页面里使用这种方案也许还行得通，但在WebApp或者Node里，这种方案明显是不可接受的。</p>\n<p><strong>那有没有办法即达到停止后面的链，同时又避免内存泄露呢。</strong></p>\n<p>让我们回到一开始的思路，我们在Promise链上所有的catch里都加上一句if，来判断传来的错误是否为一个无法处理的错误，如果是则一直往后面抛，这样就达到了即没有运行后面的逻辑，又避免了内存泄露的问题。</p>\n<p>这是一个高度一致的逻辑，我们当然可以把它抽离出来。我们可以实现一个叫next的函数，挂在Promise.prototype上面，然后在里面判断是否是我们能处理的错误，如果是，则执行回调，如果不是，则一直往下传：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> BIG_ERROR = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'BIG_ERROR'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === BIG_ERROR) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> BIG_ERROR</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> onResolved(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, onRejected)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSth()</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sthBigErrorOccured()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BIG_ERROR</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// will never get called</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>进一步，如果把上面代码中“致命错误”的语义换成“跳过后面所有的Promise”，我们就可以得到跳过后续Promise的方式了：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> STOP_SUBSEQUENT_PROMISE_CHAIN = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === STOP_SUBSEQUENT_PROMISE_CHAIN) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> STOP_SUBSEQUENT_PROMISE_CHAIN</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> onResolved(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, onRejected)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSth()</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sthBigErrorOccured()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> STOP_SUBSEQUENT_PROMISE_CHAIN</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// will never get called</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>为了更明显的语义，我们可以把“跳过后面所有的Promise”单独封装成一个Promise：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> STOP = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.stop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(STOP)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === STOP) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> STOP</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> onResolved(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, onRejected)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSth()</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sthBigErrorOccured()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.stop()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// normal logic</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.next(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// will never get called</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这样就实现了在语义明确的情况下，不造成内存泄露，而且还停止了后面的Promise链。</p>\n<p>为了对现有代码尽量少做改动，我们甚至可以不用新增next方法而是直接重写then：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> STOP_VALUE = <span class=\"built_in\">Symbol</span>()<span class=\"comment\">//构造一个Symbol以表达特殊的语义</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> STOPPER_PROMISE = <span class=\"built_in\">Promise</span>.resolve(STOP_VALUE)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype._then = <span class=\"built_in\">Promise</span>.prototype.then</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.stop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> STOPPER_PROMISE<span class=\"comment\">//不是每次返回一个新的Promise，可以节省内存</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value === STOP_VALUE ? STOP_VALUE : onResolved(value)</span><br><span class=\"line\">    &#125;, onRejected)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">8</span>).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">9</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.stop()<span class=\"comment\">//较为明确的语义</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">// will never called but will be GCed</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'catch'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">// will never called but will be GCed</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'then'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>以上对then的重写并不会造成什么问题，闭包里的对象在外界是访问不到，外界也永远也无法构造出一个跟闭包里Symbol一样的对象，考虑到我们只需要构造一个外界无法“===”的对象，我们完全可以用一个Object来代替：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> STOP_VALUE = &#123;&#125;<span class=\"comment\">//只要外界无法“===”这个对象就可以了</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> STOPPER_PROMISE = <span class=\"built_in\">Promise</span>.resolve(STOP_VALUE)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype._then = <span class=\"built_in\">Promise</span>.prototype.then</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.stop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> STOPPER_PROMISE<span class=\"comment\">//不是每次返回一个新的Promise，可以节省内存</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value === STOP_VALUE ? STOP_VALUE : onResolved(value)</span><br><span class=\"line\">    &#125;, onRejected)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">8</span>).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">9</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.stop()<span class=\"comment\">//较为明确的语义</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">// will never called but will be GCed</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'catch'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">// will never called but will be GCed</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'then'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这个方案的另一个好处（好处之一是不会造成内存泄露）是可以让你非常平滑地（甚至是一次性的）从“返回一个永远pending的Promise”过度到这个方案，因为代码及其语义都基本没有变化。在之前，你可以定义一个Promise.stop()方法来返回一个永远pending的Promise；在之后，Promise.stop()返回一个外界无法得到的值，用以表达“跳过后面所有的Promise”，然后在我们重写的then方法里使用。</p>\n<p>这样就解决了停止Promise链这样一个让人纠结的问题。</p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://github.com/xieranmaya/blog/issues/5\" target=\"_blank\" rel=\"noopener\">从如何停掉 Promise 链说起</a></p>\n</blockquote>"},{"title":"你应该注意的那些JS（相关）","date":"2019-03-11T04:35:00.000Z","_content":"记录基本的JS相关的使用或者遇到的issues\n持续更新👏\n<!-- more -->\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=1340842066&auto=1&height=66\"></iframe>\n*没有分类顺序可能杂乱😝*\n\n# 小数部分进行数学运算可能会生成过多的小数位\n很多人应该都遇到过类似的问题：`0.1 + 0.2 === 0.3` 返回值是 false，顿为惊叹\n在浏览器输入后发现 `0.1 + 0.2` 返回值是 `0.30000000000000004`(小数17位，<a href=\"#JS（Java）浮点数的数字长度\">关于这个</a>)\n查了一下找到了个解释：\n> Computer in dealing with digital mathematical operations (such as the decimal), its first converted to binary again, the decimal Numbers to binary may occur in the process of precision loss, can be used by toFixed and round method comprehensive to solve this problem.\n\n计算机是只认识二进制的，数学运算中进制转换的过程可能会发现精度损失的情况\n\n*可以使用 `toFixed` 或者 `round` 方法兼容处理*\n\n# JS（Java）浮点数的数字长度\nECMAScript Number（Java： float | double） 是使用 IEEE754 格式来表示整数和浮点数，浮点数的最高精度为 17 位小数\n\n*`Number.EPSILON`(1 与大于 1 的最小浮点数之间的差, 换句话说其实就是JS支持的最小精度) 值为2^-52，约等于2.2e-16，浮点数运算的过程中，如果误差小于这个数值，可以认为误差是不存在的，所以说第17位上的小数，其实没有意义*\n\n# JS箭轴函数\n如下代码：\n```js\nfunction make () {\n  return () => console.log(this)\n}\nconst testFunc = make.call({ name:'foo' });\n\ntestFunc() // { name: \"foo\" } \ntestFunc.call({ name:'bar' }); // { name: \"foo\" }\n```\n可以看到箭头函数在定义之后，this 就不会发生改变了，无论用什么样的方式调用它，this 都不会改变\n\n原因：箭头函数不会自动绑定局部变量，如this，arguments，super(ES6)，new.target(ES6)等\n\n所以箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用\n\n箭轴函数有如下等特性：\n- 箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象\n- 箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误\n- 箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替\n- 不可以使用yield命令，因此箭头函数不能用作Generator函数\n\n# 关于创建vue中的vnode(virture dom)\n公司之前有个文件上传组件，由于每次都会创建一个实例dom导致一些不可预知的样式错误，于是同事改用vnode来处理这部分\n\n拿来主义：\n![virturedom](/virturedom.png)\n\n**Vue2.x版本中VNode属性：**\n- tag:当前节点标签名\n- data：当前节点数据对象\n- children：子节点数组\n- text：当前节点文本\n- elm：当前虚拟节点对应的真实dom节点\n- ns：节点的namespace( 名称空间)\n- content：编译作用域\n- functionalContext：函数化组件的作用域，即全局上下文\n- key：节点标识，有利于patch优化\n- componentOptions：创建组件实例时的options\n- child：当前节点对应的组件实例\n- parent：组件的占位节点\n- raw：原始html\n- isStatic：是否是静态节点\n- isRootInsert：是否作为跟节点插入，若被包裹的节点，该属性值为false\n- isComment：是否为注释节点\n- isCloned：是否为克隆节点\n- isOnce：是否只改变(渲染)一次，或是否有v-once指令\n其中这里面又有几种VNode类型\n- TextVNode：文本节点\n- ElementVNode：普通元素节点\n- ComponentVNode：组件节点\n- EmptyVNode：空节点，或者说是没有内容的注释节点\n- CloneVNode：克隆节点，可以是以上任意类型节\n\n什么时候用虚拟dom才比较好呢？其实我们使用的单文件组件就已经够好了。但是当某些代码冗余的时候如果写单文件组件的话会有好多重复的内容\n\n接下来介绍其核心函数createElement(h)：\ncreateElement接收3个参数：\n- 第一个参数可以是HTML标签名，组件或者函数都可以；此参数是必须的\n- 第二个为数据对象（可选）\n- 第三个为子节点（可选）\n\n**附上简单demo：**\n```js\nconst Instance = new Vue({\n  data: Object.assign({}, _props, {\n\n  }),\n  render(h) {\n    const vnode = h('input', {\n      attrs: {\n        type: 'file',\n        accept: 'image/*'\n      },\n      style: {\n        display: 'none'\n      },\n      ref: 'tuhu_upload_input'\n    })\n\n    return h('div', {\n      class: 'tuhu_upload_layout'\n    }, [vnode])\n  }\n})\n```\n\n# 使用instanceof判断构造函数的问题\n测试代码：\n```js\nfunction A() {}\n\nvar a = new A\nconsole.log(a instanceof A) // true\nconsole.log(a instanceof Object) // true\n\nvar obj = {}\nA.prototype = obj\n// a.__proto__ = obj // console.log(a instanceof A) // true\nvar a2 = new A\nconsole.log(a2 instanceof A) // true\nconsole.log(a instanceof A) // false\n\nconsole.log(a instanceof Object) // true\n```\n所以综上所述 instanceof 并不能从字面意思来判断谁是否是谁的实例对象\n鱼泡泡的面试题：instanceof 判断构造函数可能会出现不准确的情况吗？如 `const arr = []; arr instanceof Array === false`。大都说不出其中几何, 其实同样只需要更改 `arr.__proto__ = Object // Number etc.`\n\ninstanceof本意：\n> MDN: The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object.\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof](url)\n\n**就是说 instanceof 是用来判断 A.prototype 是否存在于参数 a 的原型链上**\n\n所以当A的prototype被指向任意一个其他对象的时候 A.prototype是不在a的原型链上的\n\na所在的原型链: a ==> a.__proto__ ==> Object.prototype ==> null\n\na2所在的原型链: a2 ==> obj ==> Object.prototype ==> null\n\n所以此时如果赋值a.__proto__ = obj，a instanceof A 同样会返回true\n\n*JS是一门基于原型的语言，而原型是动态的并非一定不变所以会有上述情况*\n\n# 将function声明的函数的函数式调用改为new 关键字调用\nes6的class声明类的方式是必须通过new关键字进行调用的\n\n而传统的利用function关键字声明的构造函数如何避免被函数式调用呢？或者说就算是函数式调用但是依然想要生成实例对象呢\n很简单 判断constructor即可\n\n```js\n// eg:\n\nfunction A() {\n  if (this.constructor !== arguments.callee) {\n    return new A\n  }\n  this.name = 'chris'\n  this.age = 23\n  this.job = function() {\n    console.log('A front-end engineer')\n  }\n  A.work = function() {\n    console.log('working hard')\n  }\n}\nA().job() // that's all\n\n```\n补充：\n*`Array()` 和 `new Array()` 是完全一致的*\n> The Array constructor is the %Array% intrinsic object and the initial value of the Array property of the global object. When called as a constructor it creates and initializes a new exotic Array object. When Array is called as a function rather than as a constructor, it also creates and initializes a new Array object. Thus the function call Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.\nhttps://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor\n\n关于 `Object()` 与 `new Object()` 之间的差异，ES规范中说Object()会进行类型转换\n> The Object constructor is the %Object% intrinsic object and the initial value of the Object property of the global object. When called as a constructor it creates a new ordinary object. When Object is called as a function rather than as a constructor, it performs a type conversion.\nThe Object constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition.\nhttps://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor\n\n# The play() request was interrupted by a call to pause()\n做桌面通知的一个需求，需要自定义桌面通知是否带有提示音，使用的是h5的Notification API，在api 的 silent配置项不work的时候自定义new Audio在有新消息的时候触发，然后在延时器中关闭的时候出现以下错误：\n*The play() request was interrupted by a call to pause()*\n\ngoogle后发现 *Moreover since Chrome 50, a play() call on an a or element returns a Promise*\n\nplay是一个异步函数， 返回一个promise\n**所以正确的方式应该先获取这个promise， 在then回调中安全的将其pause掉**\n\n```js\nconst playSound = () => {\n  let timer = null\n  const audio = new Audio(fileUrl)\n  const playPromise = audio.play()\n  if (playPromise !== undefined) {\n    playPromise.then(() => {\n      timer = setTimeout(() => {\n        audio.pause()\n        clearTimeout(timer)\n      }, 2000)\n    }).catch(err => {\n      console.log(err)\n    })\n  }\n}\n```\n> [https://developers.google.com/web/updates/2017/06/play-request-was-interrupted](https://developers.google.com/web/updates/2017/06/play-request-was-interrupted)\n\n# 实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行\n参考别人的实现看到里面有关resolve 和 reject 函数内部的代码异步执行 却没有解释原因\n> [剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类](https://github.com/xieranmaya/blog/issues/3)\n\n```js\nfunction resolve(value) {\n  setTimeout(function () {\n      if(self.status === 'pending') {\n          self.status = 'resolved';\n          self.data = value;\n          for(var i = 0; i < self.onResolvedCallback.length; i++) {\n              self.onResolvedCallback[i](value);\n          }\n      }\n  })\n}\n```\n以下为个人简单理解：\n\n举个例子：eventbus的实现\n在使用eventbus进行数据通信的时候，通常都是在一个地方emit事件名 在另外想要触发的地方on接收这个事件同时传入相应的回调，而这种使用方式很容易给小白造成一种误解：我使用emit派发，使用on来接收执行这个派发\n\n显然不是的\n自己封装一个简单的eventbus之后就会理解\nemit是静态的而on才是依赖收集的地方 这个顺序不能变----一定是先收集完依赖才可以派发\n\n所以对于promise的resolve和then之间是不是就可以理解为必须then收集依赖后才可以触发resolve这样resolve的参数才可以被then接收到（reject和catch同理）\n\n所以回到上面提出的resolve和reject函数内部为何一定要异步执行的问题\n\n首先涉及到一个初始化的机制\n\n假如是同步执行 resolve如果在new Promise时立即触发 此时是没有收集依赖函数的（then收集到的对应的微任务队列 `onResolvedCallback` 尚未执行）\n那么resolve中的数值无法被传递\n\n而如果加入异步（setTimeout）变为一次宏任务推入下次事件循环\n\n这样就确保了先收集了依赖再触发回调\n\n> [JS/Node事件循环](https://rollawaypoint.github.io/2019/03/07/writeSomething/EventLoop/)\n\n# 你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout\n#### setTimeout 定时器\n支持传递第三个以及之后参数作为第一个回调函数的参数\n```js\nconst delay = (fn, wait, ...args) => setTimeout(fn, wait, ...args)\n\ndelay(function(...args) { console.log(args)}, 1000, 1, 2, 3)\n```\n\n#### JSON.parse\n\nJSON.parse还可额外接受第二个处理函数 对原本生成的返回值进行修改\n\n#### JSON.stringify\n\nJSON.stringify可额外再接收两个参数\n* 第二个参数： 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化\n* 第三个参数：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格\n\n# Array.prototype.push.apply(obj, arr)\n_萌新日常问题_\n**今天看到之前写的一段代码大概为：**\n```js\nlet obj = {}\nlet arr = [1, 2, 3]\n\nArray.prototype.push.apply(obj, arr)\n```\n**最终的obj为：**\n```js\n{\n  0: 1,\n  1: 2,\n  2: 3\n}\n```\n那如果向一个map中push呢？\n```js\nlet map = new Map\nlet arr = [1, 2, 3]\n\nArray.prototype.push.apply(map, arr)\n```\n**最终的map为：**\n```js\nMap(0) {\n  0: 1,\n  1: 2,\n  2: 3,\n  length: 3,\n  size: 0,\n  [[Entries]]: Array(0),\n  length: 0\n}\n```\n依然是一放进对象方式放进了map，而map的entries是空的，length也为0，我知道map是通过实例化传入option或者通过set方法才可以设置键值对，那么为什么会有这样的输出呢？\n**Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢**\n----\n落后要挨打，不懂就要查？emmm，没google到...\n显然我对搜索引擎的应用远远不行\n落后要挨打，不懂就要问，菜鸡互啄之后：\n> 这个其实你可以看数组和对象的实现方式，map 和 obj 的实现是不一样的，而数组和 obj 的实现则是相似的\nobj 其实代表的应该是 record，而不是 dictionary，map 才是 dictionary，只要把 Object 当成 record 看，那它和数组就是一家人了\n所以可以试着在代码中做一点区分,map 对索引是有一些优化的，而 Object 对下标索引也有优化，唔，这种区分是指从代码编写者的角度来说的，record 和 dictionary 是两种很常见的数据结构，在不同语言中有不同的实现，比如 python 中的实现就是 tuple 和 map，这个其实可以结合着 v8 中对象模型的实现来理解，这就说来话长了\njs 就是动态类型，从类型角度来说没什么意义，更多的实现的角度来考虑，比如说：在 v8 中如果你的对象索引是数字，在访问的时候那就很快，这个就是 tuple 的特性，但是在 js 中就是 obj，当然 object 也能作为 dictionary 来用，但是这样访问的速度就很慢了，同理，js 数组中也可以存放不同类型的值，但是如果放同样类型的值，那利用偏移值访存就会很快\n\n所以 js 才专门出了一个 Map，也是希望规范这种使用，这种归纳是实现相关的\n\n*意思就是本质上其实数组与对象其实是同一个东西（实现方式一致），都是键值对组成的集合，只不过js中的数组将键以索引下标的形式展现而已*\n\n**什么是record类型?**\n> 记录(Record)类型类似于C语言中的结构数据类型，它把逻辑相关的、分离的、基本数据类型的变量组成一个整体存储起来，它必须包括至少一个标量型或RECORD数据类型的成员，称作PL/SQL RECORD的域(FIELD)，其作用是存放互不相同但逻辑相关的信息。在使用记录数据类型变量时，需要先在声明部分先定义记录的组成、记录的变量，然后在执行部分引用该记录变量本身或其中的成员\n\n\n\n.\n.\n.\n.\n.\n.\n未完待续...👏\n","source":"_posts/writeSomething/PayAttentionToThoseJs.md","raw":"---\ntitle: 你应该注意的那些JS（相关）\ntags:\n  - 你应该知道的\ndate: 2019-03-11 12:35:00\ncategories: 你应该知道的\n---\n记录基本的JS相关的使用或者遇到的issues\n持续更新👏\n<!-- more -->\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=1340842066&auto=1&height=66\"></iframe>\n*没有分类顺序可能杂乱😝*\n\n# 小数部分进行数学运算可能会生成过多的小数位\n很多人应该都遇到过类似的问题：`0.1 + 0.2 === 0.3` 返回值是 false，顿为惊叹\n在浏览器输入后发现 `0.1 + 0.2` 返回值是 `0.30000000000000004`(小数17位，<a href=\"#JS（Java）浮点数的数字长度\">关于这个</a>)\n查了一下找到了个解释：\n> Computer in dealing with digital mathematical operations (such as the decimal), its first converted to binary again, the decimal Numbers to binary may occur in the process of precision loss, can be used by toFixed and round method comprehensive to solve this problem.\n\n计算机是只认识二进制的，数学运算中进制转换的过程可能会发现精度损失的情况\n\n*可以使用 `toFixed` 或者 `round` 方法兼容处理*\n\n# JS（Java）浮点数的数字长度\nECMAScript Number（Java： float | double） 是使用 IEEE754 格式来表示整数和浮点数，浮点数的最高精度为 17 位小数\n\n*`Number.EPSILON`(1 与大于 1 的最小浮点数之间的差, 换句话说其实就是JS支持的最小精度) 值为2^-52，约等于2.2e-16，浮点数运算的过程中，如果误差小于这个数值，可以认为误差是不存在的，所以说第17位上的小数，其实没有意义*\n\n# JS箭轴函数\n如下代码：\n```js\nfunction make () {\n  return () => console.log(this)\n}\nconst testFunc = make.call({ name:'foo' });\n\ntestFunc() // { name: \"foo\" } \ntestFunc.call({ name:'bar' }); // { name: \"foo\" }\n```\n可以看到箭头函数在定义之后，this 就不会发生改变了，无论用什么样的方式调用它，this 都不会改变\n\n原因：箭头函数不会自动绑定局部变量，如this，arguments，super(ES6)，new.target(ES6)等\n\n所以箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用\n\n箭轴函数有如下等特性：\n- 箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象\n- 箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误\n- 箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替\n- 不可以使用yield命令，因此箭头函数不能用作Generator函数\n\n# 关于创建vue中的vnode(virture dom)\n公司之前有个文件上传组件，由于每次都会创建一个实例dom导致一些不可预知的样式错误，于是同事改用vnode来处理这部分\n\n拿来主义：\n![virturedom](/virturedom.png)\n\n**Vue2.x版本中VNode属性：**\n- tag:当前节点标签名\n- data：当前节点数据对象\n- children：子节点数组\n- text：当前节点文本\n- elm：当前虚拟节点对应的真实dom节点\n- ns：节点的namespace( 名称空间)\n- content：编译作用域\n- functionalContext：函数化组件的作用域，即全局上下文\n- key：节点标识，有利于patch优化\n- componentOptions：创建组件实例时的options\n- child：当前节点对应的组件实例\n- parent：组件的占位节点\n- raw：原始html\n- isStatic：是否是静态节点\n- isRootInsert：是否作为跟节点插入，若被包裹的节点，该属性值为false\n- isComment：是否为注释节点\n- isCloned：是否为克隆节点\n- isOnce：是否只改变(渲染)一次，或是否有v-once指令\n其中这里面又有几种VNode类型\n- TextVNode：文本节点\n- ElementVNode：普通元素节点\n- ComponentVNode：组件节点\n- EmptyVNode：空节点，或者说是没有内容的注释节点\n- CloneVNode：克隆节点，可以是以上任意类型节\n\n什么时候用虚拟dom才比较好呢？其实我们使用的单文件组件就已经够好了。但是当某些代码冗余的时候如果写单文件组件的话会有好多重复的内容\n\n接下来介绍其核心函数createElement(h)：\ncreateElement接收3个参数：\n- 第一个参数可以是HTML标签名，组件或者函数都可以；此参数是必须的\n- 第二个为数据对象（可选）\n- 第三个为子节点（可选）\n\n**附上简单demo：**\n```js\nconst Instance = new Vue({\n  data: Object.assign({}, _props, {\n\n  }),\n  render(h) {\n    const vnode = h('input', {\n      attrs: {\n        type: 'file',\n        accept: 'image/*'\n      },\n      style: {\n        display: 'none'\n      },\n      ref: 'tuhu_upload_input'\n    })\n\n    return h('div', {\n      class: 'tuhu_upload_layout'\n    }, [vnode])\n  }\n})\n```\n\n# 使用instanceof判断构造函数的问题\n测试代码：\n```js\nfunction A() {}\n\nvar a = new A\nconsole.log(a instanceof A) // true\nconsole.log(a instanceof Object) // true\n\nvar obj = {}\nA.prototype = obj\n// a.__proto__ = obj // console.log(a instanceof A) // true\nvar a2 = new A\nconsole.log(a2 instanceof A) // true\nconsole.log(a instanceof A) // false\n\nconsole.log(a instanceof Object) // true\n```\n所以综上所述 instanceof 并不能从字面意思来判断谁是否是谁的实例对象\n鱼泡泡的面试题：instanceof 判断构造函数可能会出现不准确的情况吗？如 `const arr = []; arr instanceof Array === false`。大都说不出其中几何, 其实同样只需要更改 `arr.__proto__ = Object // Number etc.`\n\ninstanceof本意：\n> MDN: The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object.\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof](url)\n\n**就是说 instanceof 是用来判断 A.prototype 是否存在于参数 a 的原型链上**\n\n所以当A的prototype被指向任意一个其他对象的时候 A.prototype是不在a的原型链上的\n\na所在的原型链: a ==> a.__proto__ ==> Object.prototype ==> null\n\na2所在的原型链: a2 ==> obj ==> Object.prototype ==> null\n\n所以此时如果赋值a.__proto__ = obj，a instanceof A 同样会返回true\n\n*JS是一门基于原型的语言，而原型是动态的并非一定不变所以会有上述情况*\n\n# 将function声明的函数的函数式调用改为new 关键字调用\nes6的class声明类的方式是必须通过new关键字进行调用的\n\n而传统的利用function关键字声明的构造函数如何避免被函数式调用呢？或者说就算是函数式调用但是依然想要生成实例对象呢\n很简单 判断constructor即可\n\n```js\n// eg:\n\nfunction A() {\n  if (this.constructor !== arguments.callee) {\n    return new A\n  }\n  this.name = 'chris'\n  this.age = 23\n  this.job = function() {\n    console.log('A front-end engineer')\n  }\n  A.work = function() {\n    console.log('working hard')\n  }\n}\nA().job() // that's all\n\n```\n补充：\n*`Array()` 和 `new Array()` 是完全一致的*\n> The Array constructor is the %Array% intrinsic object and the initial value of the Array property of the global object. When called as a constructor it creates and initializes a new exotic Array object. When Array is called as a function rather than as a constructor, it also creates and initializes a new Array object. Thus the function call Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.\nhttps://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor\n\n关于 `Object()` 与 `new Object()` 之间的差异，ES规范中说Object()会进行类型转换\n> The Object constructor is the %Object% intrinsic object and the initial value of the Object property of the global object. When called as a constructor it creates a new ordinary object. When Object is called as a function rather than as a constructor, it performs a type conversion.\nThe Object constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition.\nhttps://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor\n\n# The play() request was interrupted by a call to pause()\n做桌面通知的一个需求，需要自定义桌面通知是否带有提示音，使用的是h5的Notification API，在api 的 silent配置项不work的时候自定义new Audio在有新消息的时候触发，然后在延时器中关闭的时候出现以下错误：\n*The play() request was interrupted by a call to pause()*\n\ngoogle后发现 *Moreover since Chrome 50, a play() call on an a or element returns a Promise*\n\nplay是一个异步函数， 返回一个promise\n**所以正确的方式应该先获取这个promise， 在then回调中安全的将其pause掉**\n\n```js\nconst playSound = () => {\n  let timer = null\n  const audio = new Audio(fileUrl)\n  const playPromise = audio.play()\n  if (playPromise !== undefined) {\n    playPromise.then(() => {\n      timer = setTimeout(() => {\n        audio.pause()\n        clearTimeout(timer)\n      }, 2000)\n    }).catch(err => {\n      console.log(err)\n    })\n  }\n}\n```\n> [https://developers.google.com/web/updates/2017/06/play-request-was-interrupted](https://developers.google.com/web/updates/2017/06/play-request-was-interrupted)\n\n# 实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行\n参考别人的实现看到里面有关resolve 和 reject 函数内部的代码异步执行 却没有解释原因\n> [剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类](https://github.com/xieranmaya/blog/issues/3)\n\n```js\nfunction resolve(value) {\n  setTimeout(function () {\n      if(self.status === 'pending') {\n          self.status = 'resolved';\n          self.data = value;\n          for(var i = 0; i < self.onResolvedCallback.length; i++) {\n              self.onResolvedCallback[i](value);\n          }\n      }\n  })\n}\n```\n以下为个人简单理解：\n\n举个例子：eventbus的实现\n在使用eventbus进行数据通信的时候，通常都是在一个地方emit事件名 在另外想要触发的地方on接收这个事件同时传入相应的回调，而这种使用方式很容易给小白造成一种误解：我使用emit派发，使用on来接收执行这个派发\n\n显然不是的\n自己封装一个简单的eventbus之后就会理解\nemit是静态的而on才是依赖收集的地方 这个顺序不能变----一定是先收集完依赖才可以派发\n\n所以对于promise的resolve和then之间是不是就可以理解为必须then收集依赖后才可以触发resolve这样resolve的参数才可以被then接收到（reject和catch同理）\n\n所以回到上面提出的resolve和reject函数内部为何一定要异步执行的问题\n\n首先涉及到一个初始化的机制\n\n假如是同步执行 resolve如果在new Promise时立即触发 此时是没有收集依赖函数的（then收集到的对应的微任务队列 `onResolvedCallback` 尚未执行）\n那么resolve中的数值无法被传递\n\n而如果加入异步（setTimeout）变为一次宏任务推入下次事件循环\n\n这样就确保了先收集了依赖再触发回调\n\n> [JS/Node事件循环](https://rollawaypoint.github.io/2019/03/07/writeSomething/EventLoop/)\n\n# 你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout\n#### setTimeout 定时器\n支持传递第三个以及之后参数作为第一个回调函数的参数\n```js\nconst delay = (fn, wait, ...args) => setTimeout(fn, wait, ...args)\n\ndelay(function(...args) { console.log(args)}, 1000, 1, 2, 3)\n```\n\n#### JSON.parse\n\nJSON.parse还可额外接受第二个处理函数 对原本生成的返回值进行修改\n\n#### JSON.stringify\n\nJSON.stringify可额外再接收两个参数\n* 第二个参数： 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化\n* 第三个参数：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格\n\n# Array.prototype.push.apply(obj, arr)\n_萌新日常问题_\n**今天看到之前写的一段代码大概为：**\n```js\nlet obj = {}\nlet arr = [1, 2, 3]\n\nArray.prototype.push.apply(obj, arr)\n```\n**最终的obj为：**\n```js\n{\n  0: 1,\n  1: 2,\n  2: 3\n}\n```\n那如果向一个map中push呢？\n```js\nlet map = new Map\nlet arr = [1, 2, 3]\n\nArray.prototype.push.apply(map, arr)\n```\n**最终的map为：**\n```js\nMap(0) {\n  0: 1,\n  1: 2,\n  2: 3,\n  length: 3,\n  size: 0,\n  [[Entries]]: Array(0),\n  length: 0\n}\n```\n依然是一放进对象方式放进了map，而map的entries是空的，length也为0，我知道map是通过实例化传入option或者通过set方法才可以设置键值对，那么为什么会有这样的输出呢？\n**Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢**\n----\n落后要挨打，不懂就要查？emmm，没google到...\n显然我对搜索引擎的应用远远不行\n落后要挨打，不懂就要问，菜鸡互啄之后：\n> 这个其实你可以看数组和对象的实现方式，map 和 obj 的实现是不一样的，而数组和 obj 的实现则是相似的\nobj 其实代表的应该是 record，而不是 dictionary，map 才是 dictionary，只要把 Object 当成 record 看，那它和数组就是一家人了\n所以可以试着在代码中做一点区分,map 对索引是有一些优化的，而 Object 对下标索引也有优化，唔，这种区分是指从代码编写者的角度来说的，record 和 dictionary 是两种很常见的数据结构，在不同语言中有不同的实现，比如 python 中的实现就是 tuple 和 map，这个其实可以结合着 v8 中对象模型的实现来理解，这就说来话长了\njs 就是动态类型，从类型角度来说没什么意义，更多的实现的角度来考虑，比如说：在 v8 中如果你的对象索引是数字，在访问的时候那就很快，这个就是 tuple 的特性，但是在 js 中就是 obj，当然 object 也能作为 dictionary 来用，但是这样访问的速度就很慢了，同理，js 数组中也可以存放不同类型的值，但是如果放同样类型的值，那利用偏移值访存就会很快\n\n所以 js 才专门出了一个 Map，也是希望规范这种使用，这种归纳是实现相关的\n\n*意思就是本质上其实数组与对象其实是同一个东西（实现方式一致），都是键值对组成的集合，只不过js中的数组将键以索引下标的形式展现而已*\n\n**什么是record类型?**\n> 记录(Record)类型类似于C语言中的结构数据类型，它把逻辑相关的、分离的、基本数据类型的变量组成一个整体存储起来，它必须包括至少一个标量型或RECORD数据类型的成员，称作PL/SQL RECORD的域(FIELD)，其作用是存放互不相同但逻辑相关的信息。在使用记录数据类型变量时，需要先在声明部分先定义记录的组成、记录的变量，然后在执行部分引用该记录变量本身或其中的成员\n\n\n\n.\n.\n.\n.\n.\n.\n未完待续...👏\n","slug":"writeSomething/PayAttentionToThoseJs","published":1,"updated":"2019-03-11T07:58:05.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxy1003eax48zwgnh4dc","content":"<p>记录基本的JS相关的使用或者遇到的issues<br>持续更新👏<br><a id=\"more\"></a></p>\n<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=1340842066&auto=1&height=66\"></iframe><br><em>没有分类顺序可能杂乱😝</em></p>\n<h1 id=\"小数部分进行数学运算可能会生成过多的小数位\"><a href=\"#小数部分进行数学运算可能会生成过多的小数位\" class=\"headerlink\" title=\"小数部分进行数学运算可能会生成过多的小数位\"></a>小数部分进行数学运算可能会生成过多的小数位</h1><p>很多人应该都遇到过类似的问题：<code>0.1 + 0.2 === 0.3</code> 返回值是 false，顿为惊叹<br>在浏览器输入后发现 <code>0.1 + 0.2</code> 返回值是 <code>0.30000000000000004</code>(小数17位，<a href=\"#JS（Java）浮点数的数字长度\">关于这个</a>)<br>查了一下找到了个解释：</p>\n<blockquote>\n<p>Computer in dealing with digital mathematical operations (such as the decimal), its first converted to binary again, the decimal Numbers to binary may occur in the process of precision loss, can be used by toFixed and round method comprehensive to solve this problem.</p>\n</blockquote>\n<p>计算机是只认识二进制的，数学运算中进制转换的过程可能会发现精度损失的情况</p>\n<p><em>可以使用 <code>toFixed</code> 或者 <code>round</code> 方法兼容处理</em></p>\n<h1 id=\"JS（Java）浮点数的数字长度\"><a href=\"#JS（Java）浮点数的数字长度\" class=\"headerlink\" title=\"JS（Java）浮点数的数字长度\"></a>JS（Java）浮点数的数字长度</h1><p>ECMAScript Number（Java： float | double） 是使用 IEEE754 格式来表示整数和浮点数，浮点数的最高精度为 17 位小数</p>\n<p><em><code>Number.EPSILON</code>(1 与大于 1 的最小浮点数之间的差, 换句话说其实就是JS支持的最小精度) 值为2^-52，约等于2.2e-16，浮点数运算的过程中，如果误差小于这个数值，可以认为误差是不存在的，所以说第17位上的小数，其实没有意义</em></p>\n<h1 id=\"JS箭轴函数\"><a href=\"#JS箭轴函数\" class=\"headerlink\" title=\"JS箭轴函数\"></a>JS箭轴函数</h1><p>如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> testFunc = make.call(&#123; <span class=\"attr\">name</span>:<span class=\"string\">'foo'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">testFunc() <span class=\"comment\">// &#123; name: \"foo\" &#125; </span></span><br><span class=\"line\">testFunc.call(&#123; <span class=\"attr\">name</span>:<span class=\"string\">'bar'</span> &#125;); <span class=\"comment\">// &#123; name: \"foo\" &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到箭头函数在定义之后，this 就不会发生改变了，无论用什么样的方式调用它，this 都不会改变</p>\n<p>原因：箭头函数不会自动绑定局部变量，如this，arguments，super(ES6)，new.target(ES6)等</p>\n<p>所以箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用</p>\n<p>箭轴函数有如下等特性：</p>\n<ul>\n<li>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象</li>\n<li>箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误</li>\n<li>箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替</li>\n<li>不可以使用yield命令，因此箭头函数不能用作Generator函数</li>\n</ul>\n<h1 id=\"关于创建vue中的vnode-virture-dom\"><a href=\"#关于创建vue中的vnode-virture-dom\" class=\"headerlink\" title=\"关于创建vue中的vnode(virture dom)\"></a>关于创建vue中的vnode(virture dom)</h1><p>公司之前有个文件上传组件，由于每次都会创建一个实例dom导致一些不可预知的样式错误，于是同事改用vnode来处理这部分</p>\n<p>拿来主义：<br><img src=\"/2019/03/11/writeSomething/PayAttentionToThoseJs/virturedom.png\" alt=\"virturedom\"></p>\n<p><strong>Vue2.x版本中VNode属性：</strong></p>\n<ul>\n<li>tag:当前节点标签名</li>\n<li>data：当前节点数据对象</li>\n<li>children：子节点数组</li>\n<li>text：当前节点文本</li>\n<li>elm：当前虚拟节点对应的真实dom节点</li>\n<li>ns：节点的namespace( 名称空间)</li>\n<li>content：编译作用域</li>\n<li>functionalContext：函数化组件的作用域，即全局上下文</li>\n<li>key：节点标识，有利于patch优化</li>\n<li>componentOptions：创建组件实例时的options</li>\n<li>child：当前节点对应的组件实例</li>\n<li>parent：组件的占位节点</li>\n<li>raw：原始html</li>\n<li>isStatic：是否是静态节点</li>\n<li>isRootInsert：是否作为跟节点插入，若被包裹的节点，该属性值为false</li>\n<li>isComment：是否为注释节点</li>\n<li>isCloned：是否为克隆节点</li>\n<li>isOnce：是否只改变(渲染)一次，或是否有v-once指令<br>其中这里面又有几种VNode类型</li>\n<li>TextVNode：文本节点</li>\n<li>ElementVNode：普通元素节点</li>\n<li>ComponentVNode：组件节点</li>\n<li>EmptyVNode：空节点，或者说是没有内容的注释节点</li>\n<li>CloneVNode：克隆节点，可以是以上任意类型节</li>\n</ul>\n<p>什么时候用虚拟dom才比较好呢？其实我们使用的单文件组件就已经够好了。但是当某些代码冗余的时候如果写单文件组件的话会有好多重复的内容</p>\n<p>接下来介绍其核心函数createElement(h)：<br>createElement接收3个参数：</p>\n<ul>\n<li>第一个参数可以是HTML标签名，组件或者函数都可以；此参数是必须的</li>\n<li>第二个为数据对象（可选）</li>\n<li>第三个为子节点（可选）</li>\n</ul>\n<p><strong>附上简单demo：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Instance = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: <span class=\"built_in\">Object</span>.assign(&#123;&#125;, _props, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  render(h) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> vnode = h(<span class=\"string\">'input'</span>, &#123;</span><br><span class=\"line\">      attrs: &#123;</span><br><span class=\"line\">        type: <span class=\"string\">'file'</span>,</span><br><span class=\"line\">        accept: <span class=\"string\">'image/*'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      style: &#123;</span><br><span class=\"line\">        display: <span class=\"string\">'none'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      ref: <span class=\"string\">'tuhu_upload_input'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> h(<span class=\"string\">'div'</span>, &#123;</span><br><span class=\"line\">      class: 'tuhu_upload_layout'</span><br><span class=\"line\">    &#125;, [vnode])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"使用instanceof判断构造函数的问题\"><a href=\"#使用instanceof判断构造函数的问题\" class=\"headerlink\" title=\"使用instanceof判断构造函数的问题\"></a>使用instanceof判断构造函数的问题</h1><p>测试代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;</span><br><span class=\"line\">A.prototype = obj</span><br><span class=\"line\"><span class=\"comment\">// a.__proto__ = obj // console.log(a instanceof A) // true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a2 = <span class=\"keyword\">new</span> A</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a2 <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>所以综上所述 instanceof 并不能从字面意思来判断谁是否是谁的实例对象<br>鱼泡泡的面试题：instanceof 判断构造函数可能会出现不准确的情况吗？如 <code>const arr = []; arr instanceof Array === false</code>。大都说不出其中几何, 其实同样只需要更改 <code>arr.__proto__ = Object // Number etc.</code></p>\n<p>instanceof本意：</p>\n<blockquote>\n<p>MDN: The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object.<br><a href=\"url\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof</a></p>\n</blockquote>\n<p><strong>就是说 instanceof 是用来判断 A.prototype 是否存在于参数 a 的原型链上</strong></p>\n<p>所以当A的prototype被指向任意一个其他对象的时候 A.prototype是不在a的原型链上的</p>\n<p>a所在的原型链: a ==&gt; a.<strong>proto</strong> ==&gt; Object.prototype ==&gt; null</p>\n<p>a2所在的原型链: a2 ==&gt; obj ==&gt; Object.prototype ==&gt; null</p>\n<p>所以此时如果赋值a.<strong>proto</strong> = obj，a instanceof A 同样会返回true</p>\n<p><em>JS是一门基于原型的语言，而原型是动态的并非一定不变所以会有上述情况</em></p>\n<h1 id=\"将function声明的函数的函数式调用改为new-关键字调用\"><a href=\"#将function声明的函数的函数式调用改为new-关键字调用\" class=\"headerlink\" title=\"将function声明的函数的函数式调用改为new 关键字调用\"></a>将function声明的函数的函数式调用改为new 关键字调用</h1><p>es6的class声明类的方式是必须通过new关键字进行调用的</p>\n<p>而传统的利用function关键字声明的构造函数如何避免被函数式调用呢？或者说就算是函数式调用但是依然想要生成实例对象呢<br>很简单 判断constructor即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eg:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.constructor !== <span class=\"built_in\">arguments</span>.callee) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'chris'</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">23</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'A front-end engineer'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  A.work = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'working hard'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A().job() <span class=\"comment\">// that's all</span></span><br></pre></td></tr></table></figure>\n<p>补充：<br><em><code>Array()</code> 和 <code>new Array()</code> 是完全一致的</em></p>\n<blockquote>\n<p>The Array constructor is the %Array% intrinsic object and the initial value of the Array property of the global object. When called as a constructor it creates and initializes a new exotic Array object. When Array is called as a function rather than as a constructor, it also creates and initializes a new Array object. Thus the function call Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.<br><a href=\"https://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor\" target=\"_blank\" rel=\"noopener\">https://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor</a></p>\n</blockquote>\n<p>关于 <code>Object()</code> 与 <code>new Object()</code> 之间的差异，ES规范中说Object()会进行类型转换</p>\n<blockquote>\n<p>The Object constructor is the %Object% intrinsic object and the initial value of the Object property of the global object. When called as a constructor it creates a new ordinary object. When Object is called as a function rather than as a constructor, it performs a type conversion.<br>The Object constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition.<br><a href=\"https://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor\" target=\"_blank\" rel=\"noopener\">https://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor</a></p>\n</blockquote>\n<h1 id=\"The-play-request-was-interrupted-by-a-call-to-pause\"><a href=\"#The-play-request-was-interrupted-by-a-call-to-pause\" class=\"headerlink\" title=\"The play() request was interrupted by a call to pause()\"></a>The play() request was interrupted by a call to pause()</h1><p>做桌面通知的一个需求，需要自定义桌面通知是否带有提示音，使用的是h5的Notification API，在api 的 silent配置项不work的时候自定义new Audio在有新消息的时候触发，然后在延时器中关闭的时候出现以下错误：<br><em>The play() request was interrupted by a call to pause()</em></p>\n<p>google后发现 <em>Moreover since Chrome 50, a play() call on an a or element returns a Promise</em></p>\n<p>play是一个异步函数， 返回一个promise<br><strong>所以正确的方式应该先获取这个promise， 在then回调中安全的将其pause掉</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> playSound = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> audio = <span class=\"keyword\">new</span> Audio(fileUrl)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> playPromise = audio.play()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (playPromise !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    playPromise.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        audio.pause()</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">      &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">    &#125;).catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://developers.google.com/web/updates/2017/06/play-request-was-interrupted\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/updates/2017/06/play-request-was-interrupted</a></p>\n</blockquote>\n<h1 id=\"实现-Promise-的-resolve-和-reject-函数时内部为何要异步执行\"><a href=\"#实现-Promise-的-resolve-和-reject-函数时内部为何要异步执行\" class=\"headerlink\" title=\"实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行\"></a>实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行</h1><p>参考别人的实现看到里面有关resolve 和 reject 函数内部的代码异步执行 却没有解释原因</p>\n<blockquote>\n<p><a href=\"https://github.com/xieranmaya/blog/issues/3\" target=\"_blank\" rel=\"noopener\">剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类</a></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">          self.status = <span class=\"string\">'resolved'</span>;</span><br><span class=\"line\">          self.data = value;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class=\"line\">              self.onResolvedCallback[i](value);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下为个人简单理解：</p>\n<p>举个例子：eventbus的实现<br>在使用eventbus进行数据通信的时候，通常都是在一个地方emit事件名 在另外想要触发的地方on接收这个事件同时传入相应的回调，而这种使用方式很容易给小白造成一种误解：我使用emit派发，使用on来接收执行这个派发</p>\n<p>显然不是的<br>自己封装一个简单的eventbus之后就会理解<br>emit是静态的而on才是依赖收集的地方 这个顺序不能变—-一定是先收集完依赖才可以派发</p>\n<p>所以对于promise的resolve和then之间是不是就可以理解为必须then收集依赖后才可以触发resolve这样resolve的参数才可以被then接收到（reject和catch同理）</p>\n<p>所以回到上面提出的resolve和reject函数内部为何一定要异步执行的问题</p>\n<p>首先涉及到一个初始化的机制</p>\n<p>假如是同步执行 resolve如果在new Promise时立即触发 此时是没有收集依赖函数的（then收集到的对应的微任务队列 <code>onResolvedCallback</code> 尚未执行）<br>那么resolve中的数值无法被传递</p>\n<p>而如果加入异步（setTimeout）变为一次宏任务推入下次事件循环</p>\n<p>这样就确保了先收集了依赖再触发回调</p>\n<blockquote>\n<p><a href=\"https://rollawaypoint.github.io/2019/03/07/writeSomething/EventLoop/\">JS/Node事件循环</a></p>\n</blockquote>\n<h1 id=\"你不知道的原生方法更多使用方式-JSON-parse、JSON-stringify、setTimeout\"><a href=\"#你不知道的原生方法更多使用方式-JSON-parse、JSON-stringify、setTimeout\" class=\"headerlink\" title=\"你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout\"></a>你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout</h1><h4 id=\"setTimeout-定时器\"><a href=\"#setTimeout-定时器\" class=\"headerlink\" title=\"setTimeout 定时器\"></a>setTimeout 定时器</h4><p>支持传递第三个以及之后参数作为第一个回调函数的参数<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\">(<span class=\"params\">fn, wait, ...args</span>) =&gt;</span> setTimeout(fn, wait, ...args)</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123; <span class=\"built_in\">console</span>.log(args)&#125;, <span class=\"number\">1000</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JSON-parse\"><a href=\"#JSON-parse\" class=\"headerlink\" title=\"JSON.parse\"></a>JSON.parse</h4><p>JSON.parse还可额外接受第二个处理函数 对原本生成的返回值进行修改</p>\n<h4 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify\"></a>JSON.stringify</h4><p>JSON.stringify可额外再接收两个参数</p>\n<ul>\n<li>第二个参数： 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化</li>\n<li>第三个参数：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格</li>\n</ul>\n<h1 id=\"Array-prototype-push-apply-obj-arr\"><a href=\"#Array-prototype-push-apply-obj-arr\" class=\"headerlink\" title=\"Array.prototype.push.apply(obj, arr)\"></a>Array.prototype.push.apply(obj, arr)</h1><p><em>萌新日常问题</em><br><strong>今天看到之前写的一段代码大概为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(obj, arr)</span><br></pre></td></tr></table></figure></p>\n<p><strong>最终的obj为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那如果向一个map中push呢？<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(map, arr)</span><br></pre></td></tr></table></figure></p>\n<p><strong>最终的map为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span>(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span>,</span><br><span class=\"line\">  size: <span class=\"number\">0</span>,</span><br><span class=\"line\">  [[Entries]]: <span class=\"built_in\">Array</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">  length: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>依然是一放进对象方式放进了map，而map的entries是空的，length也为0，我知道map是通过实例化传入option或者通过set方法才可以设置键值对，那么为什么会有这样的输出呢？</p>\n<h2 id=\"Q-为什么会以数组下标和值组成键值对的方式放进这个对象呢\"><a href=\"#Q-为什么会以数组下标和值组成键值对的方式放进这个对象呢\" class=\"headerlink\" title=\"Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢\"></a><strong>Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢</strong></h2><p>落后要挨打，不懂就要查？emmm，没google到…<br>显然我对搜索引擎的应用远远不行<br>落后要挨打，不懂就要问，菜鸡互啄之后：</p>\n<blockquote>\n<p>这个其实你可以看数组和对象的实现方式，map 和 obj 的实现是不一样的，而数组和 obj 的实现则是相似的<br>obj 其实代表的应该是 record，而不是 dictionary，map 才是 dictionary，只要把 Object 当成 record 看，那它和数组就是一家人了<br>所以可以试着在代码中做一点区分,map 对索引是有一些优化的，而 Object 对下标索引也有优化，唔，这种区分是指从代码编写者的角度来说的，record 和 dictionary 是两种很常见的数据结构，在不同语言中有不同的实现，比如 python 中的实现就是 tuple 和 map，这个其实可以结合着 v8 中对象模型的实现来理解，这就说来话长了<br>js 就是动态类型，从类型角度来说没什么意义，更多的实现的角度来考虑，比如说：在 v8 中如果你的对象索引是数字，在访问的时候那就很快，这个就是 tuple 的特性，但是在 js 中就是 obj，当然 object 也能作为 dictionary 来用，但是这样访问的速度就很慢了，同理，js 数组中也可以存放不同类型的值，但是如果放同样类型的值，那利用偏移值访存就会很快</p>\n</blockquote>\n<p>所以 js 才专门出了一个 Map，也是希望规范这种使用，这种归纳是实现相关的</p>\n<p><em>意思就是本质上其实数组与对象其实是同一个东西（实现方式一致），都是键值对组成的集合，只不过js中的数组将键以索引下标的形式展现而已</em></p>\n<p><strong>什么是record类型?</strong></p>\n<blockquote>\n<p>记录(Record)类型类似于C语言中的结构数据类型，它把逻辑相关的、分离的、基本数据类型的变量组成一个整体存储起来，它必须包括至少一个标量型或RECORD数据类型的成员，称作PL/SQL RECORD的域(FIELD)，其作用是存放互不相同但逻辑相关的信息。在使用记录数据类型变量时，需要先在声明部分先定义记录的组成、记录的变量，然后在执行部分引用该记录变量本身或其中的成员</p>\n</blockquote>\n<p>.<br>.<br>.<br>.<br>.<br>.<br>未完待续…👏</p>\n","site":{"data":{}},"excerpt":"<p>记录基本的JS相关的使用或者遇到的issues<br>持续更新👏<br></p>","more":"<p></p>\n<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=1340842066&auto=1&height=66\"></iframe><br><em>没有分类顺序可能杂乱😝</em></p>\n<h1 id=\"小数部分进行数学运算可能会生成过多的小数位\"><a href=\"#小数部分进行数学运算可能会生成过多的小数位\" class=\"headerlink\" title=\"小数部分进行数学运算可能会生成过多的小数位\"></a>小数部分进行数学运算可能会生成过多的小数位</h1><p>很多人应该都遇到过类似的问题：<code>0.1 + 0.2 === 0.3</code> 返回值是 false，顿为惊叹<br>在浏览器输入后发现 <code>0.1 + 0.2</code> 返回值是 <code>0.30000000000000004</code>(小数17位，<a href=\"#JS（Java）浮点数的数字长度\">关于这个</a>)<br>查了一下找到了个解释：</p>\n<blockquote>\n<p>Computer in dealing with digital mathematical operations (such as the decimal), its first converted to binary again, the decimal Numbers to binary may occur in the process of precision loss, can be used by toFixed and round method comprehensive to solve this problem.</p>\n</blockquote>\n<p>计算机是只认识二进制的，数学运算中进制转换的过程可能会发现精度损失的情况</p>\n<p><em>可以使用 <code>toFixed</code> 或者 <code>round</code> 方法兼容处理</em></p>\n<h1 id=\"JS（Java）浮点数的数字长度\"><a href=\"#JS（Java）浮点数的数字长度\" class=\"headerlink\" title=\"JS（Java）浮点数的数字长度\"></a>JS（Java）浮点数的数字长度</h1><p>ECMAScript Number（Java： float | double） 是使用 IEEE754 格式来表示整数和浮点数，浮点数的最高精度为 17 位小数</p>\n<p><em><code>Number.EPSILON</code>(1 与大于 1 的最小浮点数之间的差, 换句话说其实就是JS支持的最小精度) 值为2^-52，约等于2.2e-16，浮点数运算的过程中，如果误差小于这个数值，可以认为误差是不存在的，所以说第17位上的小数，其实没有意义</em></p>\n<h1 id=\"JS箭轴函数\"><a href=\"#JS箭轴函数\" class=\"headerlink\" title=\"JS箭轴函数\"></a>JS箭轴函数</h1><p>如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> testFunc = make.call(&#123; <span class=\"attr\">name</span>:<span class=\"string\">'foo'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">testFunc() <span class=\"comment\">// &#123; name: \"foo\" &#125; </span></span><br><span class=\"line\">testFunc.call(&#123; <span class=\"attr\">name</span>:<span class=\"string\">'bar'</span> &#125;); <span class=\"comment\">// &#123; name: \"foo\" &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到箭头函数在定义之后，this 就不会发生改变了，无论用什么样的方式调用它，this 都不会改变</p>\n<p>原因：箭头函数不会自动绑定局部变量，如this，arguments，super(ES6)，new.target(ES6)等</p>\n<p>所以箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用</p>\n<p>箭轴函数有如下等特性：</p>\n<ul>\n<li>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象</li>\n<li>箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误</li>\n<li>箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替</li>\n<li>不可以使用yield命令，因此箭头函数不能用作Generator函数</li>\n</ul>\n<h1 id=\"关于创建vue中的vnode-virture-dom\"><a href=\"#关于创建vue中的vnode-virture-dom\" class=\"headerlink\" title=\"关于创建vue中的vnode(virture dom)\"></a>关于创建vue中的vnode(virture dom)</h1><p>公司之前有个文件上传组件，由于每次都会创建一个实例dom导致一些不可预知的样式错误，于是同事改用vnode来处理这部分</p>\n<p>拿来主义：<br><img src=\"/2019/03/11/writeSomething/PayAttentionToThoseJs/virturedom.png\" alt=\"virturedom\"></p>\n<p><strong>Vue2.x版本中VNode属性：</strong></p>\n<ul>\n<li>tag:当前节点标签名</li>\n<li>data：当前节点数据对象</li>\n<li>children：子节点数组</li>\n<li>text：当前节点文本</li>\n<li>elm：当前虚拟节点对应的真实dom节点</li>\n<li>ns：节点的namespace( 名称空间)</li>\n<li>content：编译作用域</li>\n<li>functionalContext：函数化组件的作用域，即全局上下文</li>\n<li>key：节点标识，有利于patch优化</li>\n<li>componentOptions：创建组件实例时的options</li>\n<li>child：当前节点对应的组件实例</li>\n<li>parent：组件的占位节点</li>\n<li>raw：原始html</li>\n<li>isStatic：是否是静态节点</li>\n<li>isRootInsert：是否作为跟节点插入，若被包裹的节点，该属性值为false</li>\n<li>isComment：是否为注释节点</li>\n<li>isCloned：是否为克隆节点</li>\n<li>isOnce：是否只改变(渲染)一次，或是否有v-once指令<br>其中这里面又有几种VNode类型</li>\n<li>TextVNode：文本节点</li>\n<li>ElementVNode：普通元素节点</li>\n<li>ComponentVNode：组件节点</li>\n<li>EmptyVNode：空节点，或者说是没有内容的注释节点</li>\n<li>CloneVNode：克隆节点，可以是以上任意类型节</li>\n</ul>\n<p>什么时候用虚拟dom才比较好呢？其实我们使用的单文件组件就已经够好了。但是当某些代码冗余的时候如果写单文件组件的话会有好多重复的内容</p>\n<p>接下来介绍其核心函数createElement(h)：<br>createElement接收3个参数：</p>\n<ul>\n<li>第一个参数可以是HTML标签名，组件或者函数都可以；此参数是必须的</li>\n<li>第二个为数据对象（可选）</li>\n<li>第三个为子节点（可选）</li>\n</ul>\n<p><strong>附上简单demo：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Instance = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: <span class=\"built_in\">Object</span>.assign(&#123;&#125;, _props, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  render(h) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> vnode = h(<span class=\"string\">'input'</span>, &#123;</span><br><span class=\"line\">      attrs: &#123;</span><br><span class=\"line\">        type: <span class=\"string\">'file'</span>,</span><br><span class=\"line\">        accept: <span class=\"string\">'image/*'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      style: &#123;</span><br><span class=\"line\">        display: <span class=\"string\">'none'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      ref: <span class=\"string\">'tuhu_upload_input'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> h(<span class=\"string\">'div'</span>, &#123;</span><br><span class=\"line\">      class: 'tuhu_upload_layout'</span><br><span class=\"line\">    &#125;, [vnode])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"使用instanceof判断构造函数的问题\"><a href=\"#使用instanceof判断构造函数的问题\" class=\"headerlink\" title=\"使用instanceof判断构造函数的问题\"></a>使用instanceof判断构造函数的问题</h1><p>测试代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;</span><br><span class=\"line\">A.prototype = obj</span><br><span class=\"line\"><span class=\"comment\">// a.__proto__ = obj // console.log(a instanceof A) // true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a2 = <span class=\"keyword\">new</span> A</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a2 <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>所以综上所述 instanceof 并不能从字面意思来判断谁是否是谁的实例对象<br>鱼泡泡的面试题：instanceof 判断构造函数可能会出现不准确的情况吗？如 <code>const arr = []; arr instanceof Array === false</code>。大都说不出其中几何, 其实同样只需要更改 <code>arr.__proto__ = Object // Number etc.</code></p>\n<p>instanceof本意：</p>\n<blockquote>\n<p>MDN: The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object.<br><a href=\"url\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof</a></p>\n</blockquote>\n<p><strong>就是说 instanceof 是用来判断 A.prototype 是否存在于参数 a 的原型链上</strong></p>\n<p>所以当A的prototype被指向任意一个其他对象的时候 A.prototype是不在a的原型链上的</p>\n<p>a所在的原型链: a ==&gt; a.<strong>proto</strong> ==&gt; Object.prototype ==&gt; null</p>\n<p>a2所在的原型链: a2 ==&gt; obj ==&gt; Object.prototype ==&gt; null</p>\n<p>所以此时如果赋值a.<strong>proto</strong> = obj，a instanceof A 同样会返回true</p>\n<p><em>JS是一门基于原型的语言，而原型是动态的并非一定不变所以会有上述情况</em></p>\n<h1 id=\"将function声明的函数的函数式调用改为new-关键字调用\"><a href=\"#将function声明的函数的函数式调用改为new-关键字调用\" class=\"headerlink\" title=\"将function声明的函数的函数式调用改为new 关键字调用\"></a>将function声明的函数的函数式调用改为new 关键字调用</h1><p>es6的class声明类的方式是必须通过new关键字进行调用的</p>\n<p>而传统的利用function关键字声明的构造函数如何避免被函数式调用呢？或者说就算是函数式调用但是依然想要生成实例对象呢<br>很简单 判断constructor即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eg:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.constructor !== <span class=\"built_in\">arguments</span>.callee) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'chris'</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">23</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'A front-end engineer'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  A.work = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'working hard'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A().job() <span class=\"comment\">// that's all</span></span><br></pre></td></tr></table></figure>\n<p>补充：<br><em><code>Array()</code> 和 <code>new Array()</code> 是完全一致的</em></p>\n<blockquote>\n<p>The Array constructor is the %Array% intrinsic object and the initial value of the Array property of the global object. When called as a constructor it creates and initializes a new exotic Array object. When Array is called as a function rather than as a constructor, it also creates and initializes a new Array object. Thus the function call Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.<br><a href=\"https://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor\" target=\"_blank\" rel=\"noopener\">https://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor</a></p>\n</blockquote>\n<p>关于 <code>Object()</code> 与 <code>new Object()</code> 之间的差异，ES规范中说Object()会进行类型转换</p>\n<blockquote>\n<p>The Object constructor is the %Object% intrinsic object and the initial value of the Object property of the global object. When called as a constructor it creates a new ordinary object. When Object is called as a function rather than as a constructor, it performs a type conversion.<br>The Object constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition.<br><a href=\"https://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor\" target=\"_blank\" rel=\"noopener\">https://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor</a></p>\n</blockquote>\n<h1 id=\"The-play-request-was-interrupted-by-a-call-to-pause\"><a href=\"#The-play-request-was-interrupted-by-a-call-to-pause\" class=\"headerlink\" title=\"The play() request was interrupted by a call to pause()\"></a>The play() request was interrupted by a call to pause()</h1><p>做桌面通知的一个需求，需要自定义桌面通知是否带有提示音，使用的是h5的Notification API，在api 的 silent配置项不work的时候自定义new Audio在有新消息的时候触发，然后在延时器中关闭的时候出现以下错误：<br><em>The play() request was interrupted by a call to pause()</em></p>\n<p>google后发现 <em>Moreover since Chrome 50, a play() call on an a or element returns a Promise</em></p>\n<p>play是一个异步函数， 返回一个promise<br><strong>所以正确的方式应该先获取这个promise， 在then回调中安全的将其pause掉</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> playSound = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> audio = <span class=\"keyword\">new</span> Audio(fileUrl)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> playPromise = audio.play()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (playPromise !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    playPromise.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        audio.pause()</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">      &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">    &#125;).catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://developers.google.com/web/updates/2017/06/play-request-was-interrupted\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/updates/2017/06/play-request-was-interrupted</a></p>\n</blockquote>\n<h1 id=\"实现-Promise-的-resolve-和-reject-函数时内部为何要异步执行\"><a href=\"#实现-Promise-的-resolve-和-reject-函数时内部为何要异步执行\" class=\"headerlink\" title=\"实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行\"></a>实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行</h1><p>参考别人的实现看到里面有关resolve 和 reject 函数内部的代码异步执行 却没有解释原因</p>\n<blockquote>\n<p><a href=\"https://github.com/xieranmaya/blog/issues/3\" target=\"_blank\" rel=\"noopener\">剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类</a></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">          self.status = <span class=\"string\">'resolved'</span>;</span><br><span class=\"line\">          self.data = value;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class=\"line\">              self.onResolvedCallback[i](value);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下为个人简单理解：</p>\n<p>举个例子：eventbus的实现<br>在使用eventbus进行数据通信的时候，通常都是在一个地方emit事件名 在另外想要触发的地方on接收这个事件同时传入相应的回调，而这种使用方式很容易给小白造成一种误解：我使用emit派发，使用on来接收执行这个派发</p>\n<p>显然不是的<br>自己封装一个简单的eventbus之后就会理解<br>emit是静态的而on才是依赖收集的地方 这个顺序不能变—-一定是先收集完依赖才可以派发</p>\n<p>所以对于promise的resolve和then之间是不是就可以理解为必须then收集依赖后才可以触发resolve这样resolve的参数才可以被then接收到（reject和catch同理）</p>\n<p>所以回到上面提出的resolve和reject函数内部为何一定要异步执行的问题</p>\n<p>首先涉及到一个初始化的机制</p>\n<p>假如是同步执行 resolve如果在new Promise时立即触发 此时是没有收集依赖函数的（then收集到的对应的微任务队列 <code>onResolvedCallback</code> 尚未执行）<br>那么resolve中的数值无法被传递</p>\n<p>而如果加入异步（setTimeout）变为一次宏任务推入下次事件循环</p>\n<p>这样就确保了先收集了依赖再触发回调</p>\n<blockquote>\n<p><a href=\"https://rollawaypoint.github.io/2019/03/07/writeSomething/EventLoop/\">JS/Node事件循环</a></p>\n</blockquote>\n<h1 id=\"你不知道的原生方法更多使用方式-JSON-parse、JSON-stringify、setTimeout\"><a href=\"#你不知道的原生方法更多使用方式-JSON-parse、JSON-stringify、setTimeout\" class=\"headerlink\" title=\"你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout\"></a>你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout</h1><h4 id=\"setTimeout-定时器\"><a href=\"#setTimeout-定时器\" class=\"headerlink\" title=\"setTimeout 定时器\"></a>setTimeout 定时器</h4><p>支持传递第三个以及之后参数作为第一个回调函数的参数<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\">(<span class=\"params\">fn, wait, ...args</span>) =&gt;</span> setTimeout(fn, wait, ...args)</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123; <span class=\"built_in\">console</span>.log(args)&#125;, <span class=\"number\">1000</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JSON-parse\"><a href=\"#JSON-parse\" class=\"headerlink\" title=\"JSON.parse\"></a>JSON.parse</h4><p>JSON.parse还可额外接受第二个处理函数 对原本生成的返回值进行修改</p>\n<h4 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify\"></a>JSON.stringify</h4><p>JSON.stringify可额外再接收两个参数</p>\n<ul>\n<li>第二个参数： 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化</li>\n<li>第三个参数：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格</li>\n</ul>\n<h1 id=\"Array-prototype-push-apply-obj-arr\"><a href=\"#Array-prototype-push-apply-obj-arr\" class=\"headerlink\" title=\"Array.prototype.push.apply(obj, arr)\"></a>Array.prototype.push.apply(obj, arr)</h1><p><em>萌新日常问题</em><br><strong>今天看到之前写的一段代码大概为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(obj, arr)</span><br></pre></td></tr></table></figure></p>\n<p><strong>最终的obj为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那如果向一个map中push呢？<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(map, arr)</span><br></pre></td></tr></table></figure></p>\n<p><strong>最终的map为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span>(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span>,</span><br><span class=\"line\">  size: <span class=\"number\">0</span>,</span><br><span class=\"line\">  [[Entries]]: <span class=\"built_in\">Array</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">  length: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>依然是一放进对象方式放进了map，而map的entries是空的，length也为0，我知道map是通过实例化传入option或者通过set方法才可以设置键值对，那么为什么会有这样的输出呢？</p>\n<h2 id=\"Q-为什么会以数组下标和值组成键值对的方式放进这个对象呢\"><a href=\"#Q-为什么会以数组下标和值组成键值对的方式放进这个对象呢\" class=\"headerlink\" title=\"Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢\"></a><strong>Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢</strong></h2><p>落后要挨打，不懂就要查？emmm，没google到…<br>显然我对搜索引擎的应用远远不行<br>落后要挨打，不懂就要问，菜鸡互啄之后：</p>\n<blockquote>\n<p>这个其实你可以看数组和对象的实现方式，map 和 obj 的实现是不一样的，而数组和 obj 的实现则是相似的<br>obj 其实代表的应该是 record，而不是 dictionary，map 才是 dictionary，只要把 Object 当成 record 看，那它和数组就是一家人了<br>所以可以试着在代码中做一点区分,map 对索引是有一些优化的，而 Object 对下标索引也有优化，唔，这种区分是指从代码编写者的角度来说的，record 和 dictionary 是两种很常见的数据结构，在不同语言中有不同的实现，比如 python 中的实现就是 tuple 和 map，这个其实可以结合着 v8 中对象模型的实现来理解，这就说来话长了<br>js 就是动态类型，从类型角度来说没什么意义，更多的实现的角度来考虑，比如说：在 v8 中如果你的对象索引是数字，在访问的时候那就很快，这个就是 tuple 的特性，但是在 js 中就是 obj，当然 object 也能作为 dictionary 来用，但是这样访问的速度就很慢了，同理，js 数组中也可以存放不同类型的值，但是如果放同样类型的值，那利用偏移值访存就会很快</p>\n</blockquote>\n<p>所以 js 才专门出了一个 Map，也是希望规范这种使用，这种归纳是实现相关的</p>\n<p><em>意思就是本质上其实数组与对象其实是同一个东西（实现方式一致），都是键值对组成的集合，只不过js中的数组将键以索引下标的形式展现而已</em></p>\n<p><strong>什么是record类型?</strong></p>\n<blockquote>\n<p>记录(Record)类型类似于C语言中的结构数据类型，它把逻辑相关的、分离的、基本数据类型的变量组成一个整体存储起来，它必须包括至少一个标量型或RECORD数据类型的成员，称作PL/SQL RECORD的域(FIELD)，其作用是存放互不相同但逻辑相关的信息。在使用记录数据类型变量时，需要先在声明部分先定义记录的组成、记录的变量，然后在执行部分引用该记录变量本身或其中的成员</p>\n</blockquote>\n<p>.<br>.<br>.<br>.<br>.<br>.<br>未完待续…👏</p>"},{"title":"小程序的路由封装","date":"2018-12-09T08:00:00.000Z","_content":"\n基于 `mpvue` 小程序的路由封装\n\n<!--more-->\n\n[toc]\n\n## 基本使用\n\n组件内使用方法：\n```js\n\n  // 不携带路由参数\n  this.$router.push('/home/page/index')\n  // 携带路由参数\n  this.$router.push({\n    path: '/home/page/index',\n    query: {\n      //\n    },\n    reLaunch: true, // 调用wx.reLaunch\n    isTab: true // 调用wx.switchTag\n  })\n\n  // 读取当前页面路由参数\n\n  const { query } = this.$route\n\n```\n组件外部使用只需要引入router.js内部导出的push方法即可\n\n\n## 封装起步\n\n分为两点切入：\n  1. 了解微信提供的api\n  2. 自己的需求\n\n总结为以下几点：\n\n- 对微信小程序的 `switchTab、reLaunch、navigateTo、redirectTo` 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 `this.$router.push` 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 `this.$route.query` 读取。\n\n- 路由默认跳转为 `wx.navigateTo` 静态跳转，调用其他跳转方式需传递相应参数\n\n* 封装的跳转优先级：\n```\n    wx.switchTab >> wx.reLaunch >> wx.navigateTo\n```\n\n- 路由拥有拦截器，分为全局拦截和针对指定页面根据 `path` 拦截。\n\n_注意： 路由不支持指定 `wx.redireactTo` 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）_\n\n\n下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题\n\n\n### 如何完成基本跳转功能\n\n_需求：页面内使用 `this.$router.push` 方法跳转页面_\n\n首先就是新建 `index.js` 自定义一个最基本的 `push` 方法用来跳转页面\n\n``` js\n  // location 为路由传参\n  function push(location) {\n\n    const params = { url: location.path }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n\n然后为了让我们可以在页面中使用这个方法需要将 `push` 方法挂载在页面的实例上, 同时使用插件式调用在 `index.js` 文件中导出 `install` 方法\n\n``` js\n  // 导出\n  export default {\n    install(Vue) {\n\n      const _router = {\n        mode: 'history',\n        push\n      }\n      // 定义描述符getter（也可直接赋值value）\n      const $router = {\n        get() {\n          return _router\n        }\n      }\n      // 挂载 (各凭喜好也可以直接赋值在prototype上）\n      Object.defineProperty(Vue.prototype, '$router', $router)\n    }\n  }\n```\n\n接下来在项目入口文件注入上面 `index.js` 文件并执行 `Vue.use`\n\n``` js\n  import Vue from 'vue'\n  import router from './index.js'\n  \n  Vue.use(router) \n```\n\n即可在任意页面使用 `this.$router.push` 方法并传入相应跳转方式和路径\n\n这里存在一个问题： 项目跳转为了更美观主要使用 `wx.navigateTo`， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释\n\n### 页面之间如何读写参数\n\n_需求： 页面内跳转通过路由参数 `query` 字段传参， 通过 `this.$route.query` 读取参数_\n\n所以我们需要一个能够简单解析 `push` 方法参数的功能型函数 `parseUrl`，里面包括将所传的 `query` 字段以地址栏参数形式拼接在 `path` 后面的一个 `stringifyQuery` 函数\n\n``` js\n  function parseUrl(location) {\n    const { path, query } = location\n    const queryStr = stringifyQuery(query)\n\n    return `${path}${queryStr}`\n  }\n\n  function stringifyQuery(obj) {\n    const res = obj\n      ? Object.keys(obj)\n          .filter(Boolean)\n          .map(key => {\n            let val = obj[key]\n\n            if ([Array, Object].includes(val.constructor)) {\n              val = JSON.stringify(obj[key])\n            }\n            return `${key}=${val}`\n          })\n          \n          .join('&')\n      : null\n\n    return res ? `?${res}` : ''\n  }\n```\n\n把 `parseUrl` 方法添加到上面的 `push` 方法，同时参数内部是支持小程序路由跳转过程的`success`, `fail`, `complete` 钩子的 \n\n``` js\n  // location 为路由传参\n  function push(location) {\n    // others 为用户可能传递的 `success`, `fail`, `complete`\n    const { path, query, ...others } = location\n\n    const url = parseUrl({ path, query })\n\n    const params = { url, ...others }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 `$route` 对象与前面的 `$router` 一致挂载页面实例上\n\n这一层读mpvue的实例创建一个 `parseRoute` 函数简单处理一下数据即可\n\n此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0\n以下同时简单处理一下\n\n``` js\n  function parseRoute($mp) {\n    // $mp 为mpvue实例root上挂载的对象\n    const _mp = $mp || {}\n    const path = _mp.page && _mp.page.route\n    const parseQuery = {}\n    const tempQuery = _mp.query\n\n    for (let k in tempQuery) {\n      let cur = tempQuery[k]\n\n      try {\n        // 解决长整型丢失精度\n        const transfer = JSON.parse(tempQuery[k])\n\n        if (!(typeof transfer === 'number')) {\n          cur = transfer\n        }\n      } catch (e) {}\n\n      parseQuery[k] = cur\n    }\n\n    return {\n      parseQuery\n    }\n  }\n```\n\n最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 `onShow` 钩子上\n\n``` js\n  const _route = {}\n\n  Vue.mixin({\n    onShow() {\n      const { $mp } = this.$root\n\n      _route = parseRoute($mp)\n    }\n  })\n\n  const $route = {\n    get() {\n      return _route\n    }\n  }\n\n  Object.defineProperty(Vue.prototype, '$route', $route)\n```\n以上便完成路由参数的读写\n\n### 解决上面提出的小程序堆栈限制问题\n\n小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 `wx.redirectTo` 即可（其他时间项目中仅使用 `navigateTo` 即可）\n\n首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 `push` 方法\n\n``` js\n  // 当前页面堆栈长度\n  let pageStackLen = 0\n  // 堆栈限制\n  const maxStackLen = 10\n\n  function push(location, success, ...ohters) {\n    pageStackLen = getCurrentPages().length + 1\n\n    const url = parseUrl(location)\n\n    // 包装跳转成功的回调\n    const _success = function() {\n      pageStackLen = getCurrentPages().length + 1\n\n      success && success()\n    }\n\n    const params = { url, success: _success, ...ohters}\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n      pageStackLen = 1\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n\n      pageStackLen = 1\n    } else {\n      if (pageStackLen >= maxStackLen) {\n        wx.redirectTo(params)\n        return\n      }\n      wx.navigateTo(params)\n    }\n  }\n```\n以上基本解决小程序堆栈限制问题\n\n### 完善路由跳转功能\n\n现在对路由的跳转做一些基本辅助功能的支持 `go`、 `back`, `replace` 等方法\n\n``` js\n  function replace(location, ...others) {\n    const url = parseUrl(location)\n\n    wx.redirectTo({\n      url,\n      ...others\n    })\n  }\n\n  function go(delta) {\n    wx.navigateBack({\n      delta\n    })\n  }\n\n  function back() {\n    wx.navigateBack()\n  }\n```\n\n将这些挂到 `$router` 对象\n\n``` js\n  const _router = {\n    mode: 'history',\n    push,\n    replace,\n    go,\n    back\n  }\n\n  const $router = {\n    get() {\n      return _router\n    }\n  }\n\n```\n\n此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 `push` 方法方便组件外部调用等优化\n\n最后我们还差路由拦截器功能的实现\n\n### 路由拦截器\n\n需求： 对象形式配置自己路由规则\n  - `[triggerAll]`： 所有路由跳转均会触发\n  - `[triggerMatch]`： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发\n\n参数介绍：\n- `config`: 携带当前路由跳转信息（路由参数）\n- `to`: 控制跳转（调用 `to()` ）\n\n\n使用方式：\n\n``` js\nexport default {\n  triggerAll(config, to) {\n    console.log(config, 'enter interceptor')\n    to()\n  },\n  triggerMatch: {\n    '/home/pages/categoryList': [\n      (config, to) => {\n        if (/*flag*/) {\n          console.log(1)\n          to()\n        }\n      }\n    ]\n  }\n}\n```\n\n本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的\n\n新建 `interceptor.js`\n\n首先引入之前的路由方便在实例上调用，定义 `triggerMatch` 的对象存储存入的函数 `key` 为当前路由的路径，`value` 为 中间件函数组成的数组\n\n关键： 将 `push` 方法当做单独的一个中间件并放在所有中间件的最后执行\n\n``` js\n  // 引入\n  import router from './index.js'\n  // 挂载\n  Vue.use(router)\n  // 存匹配指定路由的业务函数\n  let matchMiddlewares = {}\n\n```\n接下来要构建一个处理推入规则的业务函数（中间件）的 `compose` 函数\n\n这个函数的作用主要分为两个：\n - 依次派发推入拦截器的业务函数\n - 控制下一次派发的开始\n\n``` js\n  const compose = middlewares => (...args) => {\n    function dispatch(i) {\n      return !middlewares[i]\n        ? Promise.resolve('no arguments')\n        : Promise.resolve(\n            middlewares[i](...args, function() {\n              // 派发下个调用\n              // 此处即是拦截器中第二个实参 to 方法的函数体\n              // 调动 to() 即开启下一次派发\n              return dispatch(++i)\n            })\n          )\n    }\n    // 开启调用\n    return dispatch(0)\n  }\n```\n\n创建一个函数 `getMatchMiddlewares` 用来根据指定键值读取 `matchMiddlewares` 中中间件函数数组\n\n```js\n  function getMatchMiddlewares(path) {\n    return matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []\n  }\n```\n\n\n路由同样使用 `Vue.use` 方法注册，这里导出 `install` 方法, 在里面统一所有中间件函数\n\n``` js\n  // 包装 push\n  let $push\n\n  function pushMiddware(...args) {\n    $push(...args)\n  }\n\n  export default {\n    install(Vue, { triggerAll, triggerMatch }) {\n      // 存储原 push 函数\n      $push = Vue.prototype.$router.push\n      // 接收传入的匹配函数\n      matchMiddlewares = Object.assign({}, triggerMatch)\n      \n      // 重新赋值\n      Vue.prototype.$router.push = (...args) => {\n        // 合并\n        compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(\n          ...args\n        )\n      }\n    }\n  }\n\n\n```\n\n之后在入口文件中引入即可\n\n``` js\n  import Vue from 'vue'\n  import interceptor from './interceptor.js'\n\n  Vue.use(interceptor)\n```\n\n至此便完成了路由的所有功能的基本封装\n\n详细代码可以查看 [小程序路由](http://git..com/fe/applet/iverson/tree/master/src/global/lib/router)\n\n此篇文章已经发布在 [http://doc..com](http://doc..com/pages/viewpage.action?pageId=7176857)\n\n## 总结\n路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步\n\n## 最后\npo一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：\n","source":"_posts/writeSomething/appletRouter.md","raw":"---\ntitle: 小程序的路由封装\ntags:\n  - 微信小程序\n  - mpvue\n  - 路由\ndate: 2018-12-09 16:00:00\ncategories: 封装\n---\n\n基于 `mpvue` 小程序的路由封装\n\n<!--more-->\n\n[toc]\n\n## 基本使用\n\n组件内使用方法：\n```js\n\n  // 不携带路由参数\n  this.$router.push('/home/page/index')\n  // 携带路由参数\n  this.$router.push({\n    path: '/home/page/index',\n    query: {\n      //\n    },\n    reLaunch: true, // 调用wx.reLaunch\n    isTab: true // 调用wx.switchTag\n  })\n\n  // 读取当前页面路由参数\n\n  const { query } = this.$route\n\n```\n组件外部使用只需要引入router.js内部导出的push方法即可\n\n\n## 封装起步\n\n分为两点切入：\n  1. 了解微信提供的api\n  2. 自己的需求\n\n总结为以下几点：\n\n- 对微信小程序的 `switchTab、reLaunch、navigateTo、redirectTo` 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 `this.$router.push` 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 `this.$route.query` 读取。\n\n- 路由默认跳转为 `wx.navigateTo` 静态跳转，调用其他跳转方式需传递相应参数\n\n* 封装的跳转优先级：\n```\n    wx.switchTab >> wx.reLaunch >> wx.navigateTo\n```\n\n- 路由拥有拦截器，分为全局拦截和针对指定页面根据 `path` 拦截。\n\n_注意： 路由不支持指定 `wx.redireactTo` 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）_\n\n\n下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题\n\n\n### 如何完成基本跳转功能\n\n_需求：页面内使用 `this.$router.push` 方法跳转页面_\n\n首先就是新建 `index.js` 自定义一个最基本的 `push` 方法用来跳转页面\n\n``` js\n  // location 为路由传参\n  function push(location) {\n\n    const params = { url: location.path }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n\n然后为了让我们可以在页面中使用这个方法需要将 `push` 方法挂载在页面的实例上, 同时使用插件式调用在 `index.js` 文件中导出 `install` 方法\n\n``` js\n  // 导出\n  export default {\n    install(Vue) {\n\n      const _router = {\n        mode: 'history',\n        push\n      }\n      // 定义描述符getter（也可直接赋值value）\n      const $router = {\n        get() {\n          return _router\n        }\n      }\n      // 挂载 (各凭喜好也可以直接赋值在prototype上）\n      Object.defineProperty(Vue.prototype, '$router', $router)\n    }\n  }\n```\n\n接下来在项目入口文件注入上面 `index.js` 文件并执行 `Vue.use`\n\n``` js\n  import Vue from 'vue'\n  import router from './index.js'\n  \n  Vue.use(router) \n```\n\n即可在任意页面使用 `this.$router.push` 方法并传入相应跳转方式和路径\n\n这里存在一个问题： 项目跳转为了更美观主要使用 `wx.navigateTo`， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释\n\n### 页面之间如何读写参数\n\n_需求： 页面内跳转通过路由参数 `query` 字段传参， 通过 `this.$route.query` 读取参数_\n\n所以我们需要一个能够简单解析 `push` 方法参数的功能型函数 `parseUrl`，里面包括将所传的 `query` 字段以地址栏参数形式拼接在 `path` 后面的一个 `stringifyQuery` 函数\n\n``` js\n  function parseUrl(location) {\n    const { path, query } = location\n    const queryStr = stringifyQuery(query)\n\n    return `${path}${queryStr}`\n  }\n\n  function stringifyQuery(obj) {\n    const res = obj\n      ? Object.keys(obj)\n          .filter(Boolean)\n          .map(key => {\n            let val = obj[key]\n\n            if ([Array, Object].includes(val.constructor)) {\n              val = JSON.stringify(obj[key])\n            }\n            return `${key}=${val}`\n          })\n          \n          .join('&')\n      : null\n\n    return res ? `?${res}` : ''\n  }\n```\n\n把 `parseUrl` 方法添加到上面的 `push` 方法，同时参数内部是支持小程序路由跳转过程的`success`, `fail`, `complete` 钩子的 \n\n``` js\n  // location 为路由传参\n  function push(location) {\n    // others 为用户可能传递的 `success`, `fail`, `complete`\n    const { path, query, ...others } = location\n\n    const url = parseUrl({ path, query })\n\n    const params = { url, ...others }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 `$route` 对象与前面的 `$router` 一致挂载页面实例上\n\n这一层读mpvue的实例创建一个 `parseRoute` 函数简单处理一下数据即可\n\n此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0\n以下同时简单处理一下\n\n``` js\n  function parseRoute($mp) {\n    // $mp 为mpvue实例root上挂载的对象\n    const _mp = $mp || {}\n    const path = _mp.page && _mp.page.route\n    const parseQuery = {}\n    const tempQuery = _mp.query\n\n    for (let k in tempQuery) {\n      let cur = tempQuery[k]\n\n      try {\n        // 解决长整型丢失精度\n        const transfer = JSON.parse(tempQuery[k])\n\n        if (!(typeof transfer === 'number')) {\n          cur = transfer\n        }\n      } catch (e) {}\n\n      parseQuery[k] = cur\n    }\n\n    return {\n      parseQuery\n    }\n  }\n```\n\n最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 `onShow` 钩子上\n\n``` js\n  const _route = {}\n\n  Vue.mixin({\n    onShow() {\n      const { $mp } = this.$root\n\n      _route = parseRoute($mp)\n    }\n  })\n\n  const $route = {\n    get() {\n      return _route\n    }\n  }\n\n  Object.defineProperty(Vue.prototype, '$route', $route)\n```\n以上便完成路由参数的读写\n\n### 解决上面提出的小程序堆栈限制问题\n\n小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 `wx.redirectTo` 即可（其他时间项目中仅使用 `navigateTo` 即可）\n\n首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 `push` 方法\n\n``` js\n  // 当前页面堆栈长度\n  let pageStackLen = 0\n  // 堆栈限制\n  const maxStackLen = 10\n\n  function push(location, success, ...ohters) {\n    pageStackLen = getCurrentPages().length + 1\n\n    const url = parseUrl(location)\n\n    // 包装跳转成功的回调\n    const _success = function() {\n      pageStackLen = getCurrentPages().length + 1\n\n      success && success()\n    }\n\n    const params = { url, success: _success, ...ohters}\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n      pageStackLen = 1\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n\n      pageStackLen = 1\n    } else {\n      if (pageStackLen >= maxStackLen) {\n        wx.redirectTo(params)\n        return\n      }\n      wx.navigateTo(params)\n    }\n  }\n```\n以上基本解决小程序堆栈限制问题\n\n### 完善路由跳转功能\n\n现在对路由的跳转做一些基本辅助功能的支持 `go`、 `back`, `replace` 等方法\n\n``` js\n  function replace(location, ...others) {\n    const url = parseUrl(location)\n\n    wx.redirectTo({\n      url,\n      ...others\n    })\n  }\n\n  function go(delta) {\n    wx.navigateBack({\n      delta\n    })\n  }\n\n  function back() {\n    wx.navigateBack()\n  }\n```\n\n将这些挂到 `$router` 对象\n\n``` js\n  const _router = {\n    mode: 'history',\n    push,\n    replace,\n    go,\n    back\n  }\n\n  const $router = {\n    get() {\n      return _router\n    }\n  }\n\n```\n\n此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 `push` 方法方便组件外部调用等优化\n\n最后我们还差路由拦截器功能的实现\n\n### 路由拦截器\n\n需求： 对象形式配置自己路由规则\n  - `[triggerAll]`： 所有路由跳转均会触发\n  - `[triggerMatch]`： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发\n\n参数介绍：\n- `config`: 携带当前路由跳转信息（路由参数）\n- `to`: 控制跳转（调用 `to()` ）\n\n\n使用方式：\n\n``` js\nexport default {\n  triggerAll(config, to) {\n    console.log(config, 'enter interceptor')\n    to()\n  },\n  triggerMatch: {\n    '/home/pages/categoryList': [\n      (config, to) => {\n        if (/*flag*/) {\n          console.log(1)\n          to()\n        }\n      }\n    ]\n  }\n}\n```\n\n本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的\n\n新建 `interceptor.js`\n\n首先引入之前的路由方便在实例上调用，定义 `triggerMatch` 的对象存储存入的函数 `key` 为当前路由的路径，`value` 为 中间件函数组成的数组\n\n关键： 将 `push` 方法当做单独的一个中间件并放在所有中间件的最后执行\n\n``` js\n  // 引入\n  import router from './index.js'\n  // 挂载\n  Vue.use(router)\n  // 存匹配指定路由的业务函数\n  let matchMiddlewares = {}\n\n```\n接下来要构建一个处理推入规则的业务函数（中间件）的 `compose` 函数\n\n这个函数的作用主要分为两个：\n - 依次派发推入拦截器的业务函数\n - 控制下一次派发的开始\n\n``` js\n  const compose = middlewares => (...args) => {\n    function dispatch(i) {\n      return !middlewares[i]\n        ? Promise.resolve('no arguments')\n        : Promise.resolve(\n            middlewares[i](...args, function() {\n              // 派发下个调用\n              // 此处即是拦截器中第二个实参 to 方法的函数体\n              // 调动 to() 即开启下一次派发\n              return dispatch(++i)\n            })\n          )\n    }\n    // 开启调用\n    return dispatch(0)\n  }\n```\n\n创建一个函数 `getMatchMiddlewares` 用来根据指定键值读取 `matchMiddlewares` 中中间件函数数组\n\n```js\n  function getMatchMiddlewares(path) {\n    return matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []\n  }\n```\n\n\n路由同样使用 `Vue.use` 方法注册，这里导出 `install` 方法, 在里面统一所有中间件函数\n\n``` js\n  // 包装 push\n  let $push\n\n  function pushMiddware(...args) {\n    $push(...args)\n  }\n\n  export default {\n    install(Vue, { triggerAll, triggerMatch }) {\n      // 存储原 push 函数\n      $push = Vue.prototype.$router.push\n      // 接收传入的匹配函数\n      matchMiddlewares = Object.assign({}, triggerMatch)\n      \n      // 重新赋值\n      Vue.prototype.$router.push = (...args) => {\n        // 合并\n        compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(\n          ...args\n        )\n      }\n    }\n  }\n\n\n```\n\n之后在入口文件中引入即可\n\n``` js\n  import Vue from 'vue'\n  import interceptor from './interceptor.js'\n\n  Vue.use(interceptor)\n```\n\n至此便完成了路由的所有功能的基本封装\n\n详细代码可以查看 [小程序路由](http://git..com/fe/applet/iverson/tree/master/src/global/lib/router)\n\n此篇文章已经发布在 [http://doc..com](http://doc..com/pages/viewpage.action?pageId=7176857)\n\n## 总结\n路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步\n\n## 最后\npo一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：\n","slug":"writeSomething/appletRouter","published":1,"updated":"2019-07-08T03:23:10.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxy2003gax48vkjilh7a","content":"<p>基于 <code>mpvue</code> 小程序的路由封装</p>\n<a id=\"more\"></a>\n<p>[toc]</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>组件内使用方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/home/page/index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/home/page/index'</span>,</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reLaunch: <span class=\"literal\">true</span>, <span class=\"comment\">// 调用wx.reLaunch</span></span><br><span class=\"line\">  isTab: <span class=\"literal\">true</span> <span class=\"comment\">// 调用wx.switchTag</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取当前页面路由参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; query &#125; = <span class=\"keyword\">this</span>.$route</span><br></pre></td></tr></table></figure></p>\n<p>组件外部使用只需要引入router.js内部导出的push方法即可</p>\n<h2 id=\"封装起步\"><a href=\"#封装起步\" class=\"headerlink\" title=\"封装起步\"></a>封装起步</h2><p>分为两点切入：</p>\n<ol>\n<li>了解微信提供的api</li>\n<li>自己的需求</li>\n</ol>\n<p>总结为以下几点：</p>\n<ul>\n<li><p>对微信小程序的 <code>switchTab、reLaunch、navigateTo、redirectTo</code> 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 <code>this.$router.push</code> 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 <code>this.$route.query</code> 读取。</p>\n</li>\n<li><p>路由默认跳转为 <code>wx.navigateTo</code> 静态跳转，调用其他跳转方式需传递相应参数</p>\n</li>\n</ul>\n<ul>\n<li>封装的跳转优先级：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.switchTab &gt;&gt; wx.reLaunch &gt;&gt; wx.navigateTo</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>路由拥有拦截器，分为全局拦截和针对指定页面根据 <code>path</code> 拦截。</li>\n</ul>\n<p><em>注意： 路由不支持指定 <code>wx.redireactTo</code> 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）</em></p>\n<p>下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题</p>\n<h3 id=\"如何完成基本跳转功能\"><a href=\"#如何完成基本跳转功能\" class=\"headerlink\" title=\"如何完成基本跳转功能\"></a>如何完成基本跳转功能</h3><p><em>需求：页面内使用 <code>this.$router.push</code> 方法跳转页面</em></p>\n<p>首先就是新建 <code>index.js</code> 自定义一个最基本的 <code>push</code> 方法用来跳转页面</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; <span class=\"attr\">url</span>: location.path &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后为了让我们可以在页面中使用这个方法需要将 <code>push</code> 方法挂载在页面的实例上, 同时使用插件式调用在 <code>index.js</code> 文件中导出 <code>install</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">      mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">      push</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义描述符getter（也可直接赋值value）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载 (各凭喜好也可以直接赋值在prototype上）</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$router'</span>, $router)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在项目入口文件注入上面 <code>index.js</code> 文件并执行 <code>Vue.use</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(router)</span><br></pre></td></tr></table></figure>\n<p>即可在任意页面使用 <code>this.$router.push</code> 方法并传入相应跳转方式和路径</p>\n<p>这里存在一个问题： 项目跳转为了更美观主要使用 <code>wx.navigateTo</code>， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释</p>\n<h3 id=\"页面之间如何读写参数\"><a href=\"#页面之间如何读写参数\" class=\"headerlink\" title=\"页面之间如何读写参数\"></a>页面之间如何读写参数</h3><p><em>需求： 页面内跳转通过路由参数 <code>query</code> 字段传参， 通过 <code>this.$route.query</code> 读取参数</em></p>\n<p>所以我们需要一个能够简单解析 <code>push</code> 方法参数的功能型函数 <code>parseUrl</code>，里面包括将所传的 <code>query</code> 字段以地址栏参数形式拼接在 <code>path</code> 后面的一个 <code>stringifyQuery</code> 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseUrl</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query &#125; = location</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queryStr = stringifyQuery(query)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;path&#125;</span><span class=\"subst\">$&#123;queryStr&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringifyQuery</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = obj</span><br><span class=\"line\">    ? <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">        .filter(<span class=\"built_in\">Boolean</span>)</span><br><span class=\"line\">        .map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> val = obj[key]</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ([<span class=\"built_in\">Array</span>, <span class=\"built_in\">Object</span>].includes(val.constructor)) &#123;</span><br><span class=\"line\">            val = <span class=\"built_in\">JSON</span>.stringify(obj[key])</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;val&#125;</span>`</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        .join(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? <span class=\"string\">`?<span class=\"subst\">$&#123;res&#125;</span>`</span> : <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 <code>parseUrl</code> 方法添加到上面的 <code>push</code> 方法，同时参数内部是支持小程序路由跳转过程的<code>success</code>, <code>fail</code>, <code>complete</code> 钩子的 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// others 为用户可能传递的 `success`, `fail`, `complete`</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query, ...others &#125; = location</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(&#123; path, query &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, ...others &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 <code>$route</code> 对象与前面的 <code>$router</code> 一致挂载页面实例上</p>\n<p>这一层读mpvue的实例创建一个 <code>parseRoute</code> 函数简单处理一下数据即可</p>\n<p>此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0<br>以下同时简单处理一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseRoute</span>(<span class=\"params\">$mp</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $mp 为mpvue实例root上挂载的对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _mp = $mp || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = _mp.page &amp;&amp; _mp.page.route</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parseQuery = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tempQuery = _mp.query</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> tempQuery) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cur = tempQuery[k]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 解决长整型丢失精度</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> transfer = <span class=\"built_in\">JSON</span>.parse(tempQuery[k])</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(<span class=\"keyword\">typeof</span> transfer === <span class=\"string\">'number'</span>)) &#123;</span><br><span class=\"line\">        cur = transfer</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parseQuery[k] = cur</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    parseQuery</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 <code>onShow</code> 钩子上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _route = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.mixin(&#123;</span><br><span class=\"line\">  onShow() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; $mp &#125; = <span class=\"keyword\">this</span>.$root</span><br><span class=\"line\"></span><br><span class=\"line\">    _route = parseRoute($mp)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $route = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _route</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$route'</span>, $route)</span><br></pre></td></tr></table></figure>\n<p>以上便完成路由参数的读写</p>\n<h3 id=\"解决上面提出的小程序堆栈限制问题\"><a href=\"#解决上面提出的小程序堆栈限制问题\" class=\"headerlink\" title=\"解决上面提出的小程序堆栈限制问题\"></a>解决上面提出的小程序堆栈限制问题</h3><p>小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 <code>wx.redirectTo</code> 即可（其他时间项目中仅使用 <code>navigateTo</code> 即可）</p>\n<p>首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 <code>push</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前页面堆栈长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pageStackLen = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 堆栈限制</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxStackLen = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location, success, ...ohters</span>) </span>&#123;</span><br><span class=\"line\">  pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 包装跳转成功的回调</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _success = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    success &amp;&amp; success()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, <span class=\"attr\">success</span>: _success, ...ohters&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pageStackLen &gt;= maxStackLen) &#123;</span><br><span class=\"line\">      wx.redirectTo(params)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上基本解决小程序堆栈限制问题</p>\n<h3 id=\"完善路由跳转功能\"><a href=\"#完善路由跳转功能\" class=\"headerlink\" title=\"完善路由跳转功能\"></a>完善路由跳转功能</h3><p>现在对路由的跳转做一些基本辅助功能的支持 <code>go</code>、 <code>back</code>, <code>replace</code> 等方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">location, ...others</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  wx.redirectTo(&#123;</span><br><span class=\"line\">    url,</span><br><span class=\"line\">    ...others</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">delta</span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack(&#123;</span><br><span class=\"line\">    delta</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">back</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这些挂到 <code>$router</code> 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">  push,</span><br><span class=\"line\">  replace,</span><br><span class=\"line\">  go,</span><br><span class=\"line\">  back</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 <code>push</code> 方法方便组件外部调用等优化</p>\n<p>最后我们还差路由拦截器功能的实现</p>\n<h3 id=\"路由拦截器\"><a href=\"#路由拦截器\" class=\"headerlink\" title=\"路由拦截器\"></a>路由拦截器</h3><p>需求： 对象形式配置自己路由规则</p>\n<ul>\n<li><code>[triggerAll]</code>： 所有路由跳转均会触发</li>\n<li><code>[triggerMatch]</code>： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发</li>\n</ul>\n<p>参数介绍：</p>\n<ul>\n<li><code>config</code>: 携带当前路由跳转信息（路由参数）</li>\n<li><code>to</code>: 控制跳转（调用 <code>to()</code> ）</li>\n</ul>\n<p>使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  triggerAll(config, to) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(config, <span class=\"string\">'enter interceptor'</span>)</span><br><span class=\"line\">    to()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  triggerMatch: &#123;</span><br><span class=\"line\">    <span class=\"string\">'/home/pages/categoryList'</span>: [</span><br><span class=\"line\">      (config, to) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*flag*/</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">          to()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的</p>\n<p>新建 <code>interceptor.js</code></p>\n<p>首先引入之前的路由方便在实例上调用，定义 <code>triggerMatch</code> 的对象存储存入的函数 <code>key</code> 为当前路由的路径，<code>value</code> 为 中间件函数组成的数组</p>\n<p>关键： 将 <code>push</code> 方法当做单独的一个中间件并放在所有中间件的最后执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 挂载</span></span><br><span class=\"line\">Vue.use(router)</span><br><span class=\"line\"><span class=\"comment\">// 存匹配指定路由的业务函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> matchMiddlewares = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来要构建一个处理推入规则的业务函数（中间件）的 <code>compose</code> 函数</p>\n<p>这个函数的作用主要分为两个：</p>\n<ul>\n<li>依次派发推入拦截器的业务函数</li>\n<li>控制下一次派发的开始</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !middlewares[i]</span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'no arguments'</span>)</span><br><span class=\"line\">      : <span class=\"built_in\">Promise</span>.resolve(</span><br><span class=\"line\">          middlewares[i](...args, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 派发下个调用</span></span><br><span class=\"line\">            <span class=\"comment\">// 此处即是拦截器中第二个实参 to 方法的函数体</span></span><br><span class=\"line\">            <span class=\"comment\">// 调动 to() 即开启下一次派发</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatch(++i)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 开启调用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个函数 <code>getMatchMiddlewares</code> 用来根据指定键值读取 <code>matchMiddlewares</code> 中中间件函数数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMatchMiddlewares</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路由同样使用 <code>Vue.use</code> 方法注册，这里导出 <code>install</code> 方法, 在里面统一所有中间件函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包装 push</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> $push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushMiddware</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  $push(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue, &#123; triggerAll, triggerMatch &#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储原 push 函数</span></span><br><span class=\"line\">    $push = Vue.prototype.$router.push</span><br><span class=\"line\">    <span class=\"comment\">// 接收传入的匹配函数</span></span><br><span class=\"line\">    matchMiddlewares = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, triggerMatch)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">    Vue.prototype.$router.push = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 合并</span></span><br><span class=\"line\">      compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(</span><br><span class=\"line\">        ...args</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后在入口文件中引入即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> interceptor <span class=\"keyword\">from</span> <span class=\"string\">'./interceptor.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(interceptor)</span><br></pre></td></tr></table></figure>\n<p>至此便完成了路由的所有功能的基本封装</p>\n<p>详细代码可以查看 <a href=\"http://git..com/fe/applet/iverson/tree/master/src/global/lib/router\" target=\"_blank\" rel=\"noopener\">小程序路由</a></p>\n<p>此篇文章已经发布在 <a href=\"http://doc..com/pages/viewpage.action?pageId=7176857\" target=\"_blank\" rel=\"noopener\">http://doc..com</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>po一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：</p>\n","site":{"data":{}},"excerpt":"<p>基于 <code>mpvue</code> 小程序的路由封装</p>","more":"<p>[toc]</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>组件内使用方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/home/page/index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/home/page/index'</span>,</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reLaunch: <span class=\"literal\">true</span>, <span class=\"comment\">// 调用wx.reLaunch</span></span><br><span class=\"line\">  isTab: <span class=\"literal\">true</span> <span class=\"comment\">// 调用wx.switchTag</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取当前页面路由参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; query &#125; = <span class=\"keyword\">this</span>.$route</span><br></pre></td></tr></table></figure></p>\n<p>组件外部使用只需要引入router.js内部导出的push方法即可</p>\n<h2 id=\"封装起步\"><a href=\"#封装起步\" class=\"headerlink\" title=\"封装起步\"></a>封装起步</h2><p>分为两点切入：</p>\n<ol>\n<li>了解微信提供的api</li>\n<li>自己的需求</li>\n</ol>\n<p>总结为以下几点：</p>\n<ul>\n<li><p>对微信小程序的 <code>switchTab、reLaunch、navigateTo、redirectTo</code> 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 <code>this.$router.push</code> 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 <code>this.$route.query</code> 读取。</p>\n</li>\n<li><p>路由默认跳转为 <code>wx.navigateTo</code> 静态跳转，调用其他跳转方式需传递相应参数</p>\n</li>\n</ul>\n<ul>\n<li>封装的跳转优先级：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.switchTab &gt;&gt; wx.reLaunch &gt;&gt; wx.navigateTo</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>路由拥有拦截器，分为全局拦截和针对指定页面根据 <code>path</code> 拦截。</li>\n</ul>\n<p><em>注意： 路由不支持指定 <code>wx.redireactTo</code> 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）</em></p>\n<p>下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题</p>\n<h3 id=\"如何完成基本跳转功能\"><a href=\"#如何完成基本跳转功能\" class=\"headerlink\" title=\"如何完成基本跳转功能\"></a>如何完成基本跳转功能</h3><p><em>需求：页面内使用 <code>this.$router.push</code> 方法跳转页面</em></p>\n<p>首先就是新建 <code>index.js</code> 自定义一个最基本的 <code>push</code> 方法用来跳转页面</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; <span class=\"attr\">url</span>: location.path &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后为了让我们可以在页面中使用这个方法需要将 <code>push</code> 方法挂载在页面的实例上, 同时使用插件式调用在 <code>index.js</code> 文件中导出 <code>install</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">      mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">      push</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义描述符getter（也可直接赋值value）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载 (各凭喜好也可以直接赋值在prototype上）</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$router'</span>, $router)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在项目入口文件注入上面 <code>index.js</code> 文件并执行 <code>Vue.use</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(router)</span><br></pre></td></tr></table></figure>\n<p>即可在任意页面使用 <code>this.$router.push</code> 方法并传入相应跳转方式和路径</p>\n<p>这里存在一个问题： 项目跳转为了更美观主要使用 <code>wx.navigateTo</code>， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释</p>\n<h3 id=\"页面之间如何读写参数\"><a href=\"#页面之间如何读写参数\" class=\"headerlink\" title=\"页面之间如何读写参数\"></a>页面之间如何读写参数</h3><p><em>需求： 页面内跳转通过路由参数 <code>query</code> 字段传参， 通过 <code>this.$route.query</code> 读取参数</em></p>\n<p>所以我们需要一个能够简单解析 <code>push</code> 方法参数的功能型函数 <code>parseUrl</code>，里面包括将所传的 <code>query</code> 字段以地址栏参数形式拼接在 <code>path</code> 后面的一个 <code>stringifyQuery</code> 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseUrl</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query &#125; = location</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queryStr = stringifyQuery(query)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;path&#125;</span><span class=\"subst\">$&#123;queryStr&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringifyQuery</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = obj</span><br><span class=\"line\">    ? <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">        .filter(<span class=\"built_in\">Boolean</span>)</span><br><span class=\"line\">        .map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> val = obj[key]</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ([<span class=\"built_in\">Array</span>, <span class=\"built_in\">Object</span>].includes(val.constructor)) &#123;</span><br><span class=\"line\">            val = <span class=\"built_in\">JSON</span>.stringify(obj[key])</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;val&#125;</span>`</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        .join(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? <span class=\"string\">`?<span class=\"subst\">$&#123;res&#125;</span>`</span> : <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 <code>parseUrl</code> 方法添加到上面的 <code>push</code> 方法，同时参数内部是支持小程序路由跳转过程的<code>success</code>, <code>fail</code>, <code>complete</code> 钩子的 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// others 为用户可能传递的 `success`, `fail`, `complete`</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query, ...others &#125; = location</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(&#123; path, query &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, ...others &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 <code>$route</code> 对象与前面的 <code>$router</code> 一致挂载页面实例上</p>\n<p>这一层读mpvue的实例创建一个 <code>parseRoute</code> 函数简单处理一下数据即可</p>\n<p>此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0<br>以下同时简单处理一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseRoute</span>(<span class=\"params\">$mp</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $mp 为mpvue实例root上挂载的对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _mp = $mp || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = _mp.page &amp;&amp; _mp.page.route</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parseQuery = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tempQuery = _mp.query</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> tempQuery) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cur = tempQuery[k]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 解决长整型丢失精度</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> transfer = <span class=\"built_in\">JSON</span>.parse(tempQuery[k])</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(<span class=\"keyword\">typeof</span> transfer === <span class=\"string\">'number'</span>)) &#123;</span><br><span class=\"line\">        cur = transfer</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parseQuery[k] = cur</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    parseQuery</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 <code>onShow</code> 钩子上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _route = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.mixin(&#123;</span><br><span class=\"line\">  onShow() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; $mp &#125; = <span class=\"keyword\">this</span>.$root</span><br><span class=\"line\"></span><br><span class=\"line\">    _route = parseRoute($mp)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $route = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _route</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$route'</span>, $route)</span><br></pre></td></tr></table></figure>\n<p>以上便完成路由参数的读写</p>\n<h3 id=\"解决上面提出的小程序堆栈限制问题\"><a href=\"#解决上面提出的小程序堆栈限制问题\" class=\"headerlink\" title=\"解决上面提出的小程序堆栈限制问题\"></a>解决上面提出的小程序堆栈限制问题</h3><p>小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 <code>wx.redirectTo</code> 即可（其他时间项目中仅使用 <code>navigateTo</code> 即可）</p>\n<p>首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 <code>push</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前页面堆栈长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pageStackLen = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 堆栈限制</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxStackLen = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location, success, ...ohters</span>) </span>&#123;</span><br><span class=\"line\">  pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 包装跳转成功的回调</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _success = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    success &amp;&amp; success()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, <span class=\"attr\">success</span>: _success, ...ohters&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pageStackLen &gt;= maxStackLen) &#123;</span><br><span class=\"line\">      wx.redirectTo(params)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上基本解决小程序堆栈限制问题</p>\n<h3 id=\"完善路由跳转功能\"><a href=\"#完善路由跳转功能\" class=\"headerlink\" title=\"完善路由跳转功能\"></a>完善路由跳转功能</h3><p>现在对路由的跳转做一些基本辅助功能的支持 <code>go</code>、 <code>back</code>, <code>replace</code> 等方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">location, ...others</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  wx.redirectTo(&#123;</span><br><span class=\"line\">    url,</span><br><span class=\"line\">    ...others</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">delta</span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack(&#123;</span><br><span class=\"line\">    delta</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">back</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这些挂到 <code>$router</code> 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">  push,</span><br><span class=\"line\">  replace,</span><br><span class=\"line\">  go,</span><br><span class=\"line\">  back</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 <code>push</code> 方法方便组件外部调用等优化</p>\n<p>最后我们还差路由拦截器功能的实现</p>\n<h3 id=\"路由拦截器\"><a href=\"#路由拦截器\" class=\"headerlink\" title=\"路由拦截器\"></a>路由拦截器</h3><p>需求： 对象形式配置自己路由规则</p>\n<ul>\n<li><code>[triggerAll]</code>： 所有路由跳转均会触发</li>\n<li><code>[triggerMatch]</code>： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发</li>\n</ul>\n<p>参数介绍：</p>\n<ul>\n<li><code>config</code>: 携带当前路由跳转信息（路由参数）</li>\n<li><code>to</code>: 控制跳转（调用 <code>to()</code> ）</li>\n</ul>\n<p>使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  triggerAll(config, to) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(config, <span class=\"string\">'enter interceptor'</span>)</span><br><span class=\"line\">    to()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  triggerMatch: &#123;</span><br><span class=\"line\">    <span class=\"string\">'/home/pages/categoryList'</span>: [</span><br><span class=\"line\">      (config, to) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*flag*/</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">          to()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的</p>\n<p>新建 <code>interceptor.js</code></p>\n<p>首先引入之前的路由方便在实例上调用，定义 <code>triggerMatch</code> 的对象存储存入的函数 <code>key</code> 为当前路由的路径，<code>value</code> 为 中间件函数组成的数组</p>\n<p>关键： 将 <code>push</code> 方法当做单独的一个中间件并放在所有中间件的最后执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 挂载</span></span><br><span class=\"line\">Vue.use(router)</span><br><span class=\"line\"><span class=\"comment\">// 存匹配指定路由的业务函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> matchMiddlewares = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来要构建一个处理推入规则的业务函数（中间件）的 <code>compose</code> 函数</p>\n<p>这个函数的作用主要分为两个：</p>\n<ul>\n<li>依次派发推入拦截器的业务函数</li>\n<li>控制下一次派发的开始</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !middlewares[i]</span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'no arguments'</span>)</span><br><span class=\"line\">      : <span class=\"built_in\">Promise</span>.resolve(</span><br><span class=\"line\">          middlewares[i](...args, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 派发下个调用</span></span><br><span class=\"line\">            <span class=\"comment\">// 此处即是拦截器中第二个实参 to 方法的函数体</span></span><br><span class=\"line\">            <span class=\"comment\">// 调动 to() 即开启下一次派发</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatch(++i)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 开启调用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个函数 <code>getMatchMiddlewares</code> 用来根据指定键值读取 <code>matchMiddlewares</code> 中中间件函数数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMatchMiddlewares</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路由同样使用 <code>Vue.use</code> 方法注册，这里导出 <code>install</code> 方法, 在里面统一所有中间件函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包装 push</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> $push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushMiddware</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  $push(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue, &#123; triggerAll, triggerMatch &#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储原 push 函数</span></span><br><span class=\"line\">    $push = Vue.prototype.$router.push</span><br><span class=\"line\">    <span class=\"comment\">// 接收传入的匹配函数</span></span><br><span class=\"line\">    matchMiddlewares = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, triggerMatch)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">    Vue.prototype.$router.push = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 合并</span></span><br><span class=\"line\">      compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(</span><br><span class=\"line\">        ...args</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后在入口文件中引入即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> interceptor <span class=\"keyword\">from</span> <span class=\"string\">'./interceptor.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(interceptor)</span><br></pre></td></tr></table></figure>\n<p>至此便完成了路由的所有功能的基本封装</p>\n<p>详细代码可以查看 <a href=\"http://git..com/fe/applet/iverson/tree/master/src/global/lib/router\" target=\"_blank\" rel=\"noopener\">小程序路由</a></p>\n<p>此篇文章已经发布在 <a href=\"http://doc..com/pages/viewpage.action?pageId=7176857\" target=\"_blank\" rel=\"noopener\">http://doc..com</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>po一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：</p>"},{"title":"有趣的JS题目整理","date":"2019-03-12T11:33:00.000Z","_content":"\nJS相关各类型题目记录\n<!--more-->\n\n# JS执行上下文（作用域）以及变量提升\n先看题目：以下代码输出分别是什么\n\n###### 平安的一道笔试题\n```js\nvar a = 10\n\nfunction fn() {\n  a()\n\n  try {\n    a()\n    console.log(a, ' try')\n    a = 100\n  } catch (e) {\n    a = 1\n    console.log(a, ' catch')\n  }\n  \n  console.log(a, ' inner function fn')\n\n  function a() {\n    console.log(a, ' inner function a')\n    a = 1000\n  }\n}\n\nfn()\nconsole.log(a, 'outer result')\n\n```\n先试着预想一下执行结果\n.\n.\n.\n.\n.\n.\n输出\n```js\n// [Function] inner function a\n// 1 catch\n// 1 inner function fn\n// 10 outer result\n```\n是否和预想的一致呢？\n\n先来了解几个概念：\n - 每一个函数都有自己的执行上下文EC（执行环境 execution context）\n   - 全局脚本是一个全局上下文\n - EC预解析的时候会有变量提升\n   - 只有关键字声明的变量才会有变量提升\n   - 函数优先级高于普通变量\n\n下面开始分析一下执行结果\n首先 fn 会获得变量提升然后声明并且赋值全局变量 `var a = 10` \n\n执行fn：\n  - 首先 fn 内部进行变量提升\n    - 内部函数a提升到当前EC顶部\n    - ```js\n      function fn() {\n        function a() {\n          console.log(a, ' inner function a')\n          a = 1000\n        }\n        a()\n      }\n      ```\n    - 主要的一点：fn 内部的变量 a 已经被重新声明 相当于 `var a = function () {}` 所以此处 fn 内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局\n\nfn内部输出：\n  - a本身是个函数，invoke a() 输出 `[Function] inner function a`，然后将fn内部的 a 重新赋值为1000\n  - 执行try语句：\n    - a是1000所以 invoke a()会抛出异常 `a is not a function` 被catch语句捕获，当前try语句终端不在继续向下执行\n      - *try语句内部的 `a = 100` 只是简单的赋值操作，没有关键字声明所以没有变量提升*\n  - 执行catch语句\n    - 重新赋值 `a = 1`，输出 `a catch`\n  - try catch语句执行结束继续向下执行, 此时a已经被catch语句赋值为1输出 `1 inner function fn`\n\nfn执行结束继续执行全局上下文环境中的代码，上面说了fn内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局, 所以全局上下文中a依旧是10，输出 10\n运行结束\n\n# 深入理解“连等赋值”问题\n```js\nvar a = { n: 1 }\nvar b = a\na.x = a = { n: 2 }\nalert(a.x) // --> undefined\nalert(b.x) // --> { n: 2 }\n```\n\n理解该问题需要知道以下两点：\n- JS引擎对赋值表达式的处理过程\n- 赋值运算的右结合性\n\n#### JS引擎对赋值表达式的处理过程\n如赋值表达式 `A = B`\n1. 计算表达式左表达式A，得到一个引用refA\n2. 计算表达式B，得到一个引用refB\n3. 通过 `GetValue(refB)` 得到valueB\n4. 进行判断，当如下情况全部符合则抛出语法异常\n   1. refA是一个引用\n   2. refA是一个严格引用\n   3. refA是一个 `environment records`(**这里理解是refA是一个声明的变量或者是对象的某个属性**)\n   4. refA的引用名是’eval‘或’arguments‘\n5. 将valueB赋给refA指向的名称绑定\n6. 返回valueB\n\n*`GetValue(refB)` 是通过一系列判断得出value值，具体步骤参考[GetValue(refB)](http://es5.github.io/#x8.7.1)*\n\n具体参考：\n> [http://es5.github.io/#x11.13.1](http://es5.github.io/#x11.13.1)\n\n#### 结合性\n所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。\n赋值表达式是右结合的。这意味着：`A1 = A2 = A3 = A4` 等价于 `A1 = (A2 = (A3 = A4))`\n\n\n总的简单s来说就是：***先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用***\n\n#### 分析\n```js\na.x = a = { n: 2 }\n```\n首先得到 a.x 和 a 的两个引用\n得到右表达式是一个对象 `{ n: 2 }`\na.x 和 a 的两个引用并且判断属于 `environment records`（a.x 属于对象的某个属性，a属于当前上下文的变量a）\n将 `{ n: 2 }` 赋值给 当前上下文变量 a 的 refA，a已被重新赋值为 `{ n: 2 }`\n将 `{ n: 2 }` 赋值给 当前上下文变量 a.x 的 ref（a.x）*ref（a.x）与ref（b.x）是同一个*, refA已经与 `{ n: 2 }` 重新绑定，所以此时 b 为 `{ n: 1, x: { n: 2 } }`\n\n所以最终结果：a为 `{ n：2 }`，b为 `{ n: 1, x: { n: 2 } }`, 并且由于是同一个对象 `{ n: 2 }` 赋值给b.x以及a获得的引用相同，所以 `b.x === a`\n\n所以 `a.x` 为 `undefined`, `b.x` 为 `{ n: 2 }`\n\nLink:\n> [由ES规范学JavaScript(二)：深入理解“连等赋值”问题](https://segmentfault.com/a/1190000004224719)\n\n# 立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)\n```js\n(function A() {\n    console.log(A) // [Function A]\n    A = 1\n    console.log(window.A) // undefined\n    console.log(A) // [Function A]\n}())\n```\n上面立即执行函数中直接将1赋值给一个未声明的变量，正常逻辑下我们知道会将他绑定的全局作为全局变量，但是上面的输出显然不是如此，原因在于匿名执行函数有了名字且和赋值的变量A同名\n\n有了名字的函数（NFE）有两个特性：\n- 作为函数名的标识符（在这里是 A ）只能从函数体内部访问，在函数外部访问不到 (IE9+)\n- 绑定为函数名的标识符（在这里是A）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），所以在 NFE 函数体内对 A 重新赋值是无效的\n\n创建 NFE 的机制：\n> The production FunctionExpression : function Identifier (\nFormalParameterListopt ) { FunctionBody }\nis evaluated as follows:\n  - Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument\n  - Let envRec be funcEnv’s environment record.\n  - Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.\n  - Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.\n  - Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.\n  - Return closure.\n\n注意步骤 3 和 5，分别调用了 createImmutableBinding 和 InitializeImmutableBinding 内部方法，**创建的是不可更改的绑定**\n\n要理解这两个特性，最重要的是搞清楚标识符 A的绑定记录保存在哪里。让我们问自己几个问题：\n1. 标识符 A 与 该 NFE 是什么关系？ 两层关系：首先，该 NFE 的 name 属性是 字符串 'A'；更重要的是，A是该 NFE 的一个自由变量。在函数体内部，我们引用了 A，但 A 既不是该 NFE 的形参，又不是它的局部变量，那它不是自由变量是什么！解析自由变量，要从函数的 [[scope]] 内部属性所保存的词法环境 (Lexical Environment) 中查找变量的绑定记录。\n\n2. 标识符 A 保存在全局执行环境（Global Execution Context）的词法环境(Lexical Environment)中吗？ 答案是否。如果你仔细看过 ES5 Section 13 这一节，会发现创建 NFE 比创建 匿名函数表达式 （Anonymous Function Expression, AFE） 和 函数声明 (Function Declaration) 的过程要复杂得多\n\n那么为何创建 NFE 要搞得那么复杂呢？就是为了实现 NFE 的只能从函数内部访问A，而不能从外部访问这一特性！咋实现的？ 创建 NFE 时，创建了一个专门的词法环境用于保存 A 的绑定记录(见上面步骤 1~3)！对于 NFE, 有如下关系：\n```js\nA.[[scope]]\n  --->  Lexical Environment {'environment record': {A: function ...}, outer: --}\n  ---> Lexical Environment of Global Context {'environment record': {...}, outer --}\n  ---> null\n```\n\n可见，A 的绑定记录不在全局执行上下文的词法环境中，故不能从外部访问\n\n但是有个疑问：如果内部输出的时候进行赋值呢？\n```js\n(function A() {\n    console.log(A = 100) // 100\n}())\n```\n却可以打印出100，<a href=\"#JS引擎对赋值表达式的处理过程\">JS引擎对赋值表达式的处理过程</a>中我们知道赋值表达式最终结果是返回这个值，如果NFE内部没有成功赋值为何可以打印出100呢？\n\nLink:\n> [在JavaScript的立即执行的具名函数A内修改A的值时到底发生了什么](https://segmentfault.com/q/1010000002810093)","source":"_posts/writeSomething/interestingCode.md","raw":"---\ntitle: 有趣的JS题目整理\ntags:\n  - interview\ndate: 2019-03-012 19:33:00\ncategories: 你应该知道的\n---\n\nJS相关各类型题目记录\n<!--more-->\n\n# JS执行上下文（作用域）以及变量提升\n先看题目：以下代码输出分别是什么\n\n###### 平安的一道笔试题\n```js\nvar a = 10\n\nfunction fn() {\n  a()\n\n  try {\n    a()\n    console.log(a, ' try')\n    a = 100\n  } catch (e) {\n    a = 1\n    console.log(a, ' catch')\n  }\n  \n  console.log(a, ' inner function fn')\n\n  function a() {\n    console.log(a, ' inner function a')\n    a = 1000\n  }\n}\n\nfn()\nconsole.log(a, 'outer result')\n\n```\n先试着预想一下执行结果\n.\n.\n.\n.\n.\n.\n输出\n```js\n// [Function] inner function a\n// 1 catch\n// 1 inner function fn\n// 10 outer result\n```\n是否和预想的一致呢？\n\n先来了解几个概念：\n - 每一个函数都有自己的执行上下文EC（执行环境 execution context）\n   - 全局脚本是一个全局上下文\n - EC预解析的时候会有变量提升\n   - 只有关键字声明的变量才会有变量提升\n   - 函数优先级高于普通变量\n\n下面开始分析一下执行结果\n首先 fn 会获得变量提升然后声明并且赋值全局变量 `var a = 10` \n\n执行fn：\n  - 首先 fn 内部进行变量提升\n    - 内部函数a提升到当前EC顶部\n    - ```js\n      function fn() {\n        function a() {\n          console.log(a, ' inner function a')\n          a = 1000\n        }\n        a()\n      }\n      ```\n    - 主要的一点：fn 内部的变量 a 已经被重新声明 相当于 `var a = function () {}` 所以此处 fn 内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局\n\nfn内部输出：\n  - a本身是个函数，invoke a() 输出 `[Function] inner function a`，然后将fn内部的 a 重新赋值为1000\n  - 执行try语句：\n    - a是1000所以 invoke a()会抛出异常 `a is not a function` 被catch语句捕获，当前try语句终端不在继续向下执行\n      - *try语句内部的 `a = 100` 只是简单的赋值操作，没有关键字声明所以没有变量提升*\n  - 执行catch语句\n    - 重新赋值 `a = 1`，输出 `a catch`\n  - try catch语句执行结束继续向下执行, 此时a已经被catch语句赋值为1输出 `1 inner function fn`\n\nfn执行结束继续执行全局上下文环境中的代码，上面说了fn内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局, 所以全局上下文中a依旧是10，输出 10\n运行结束\n\n# 深入理解“连等赋值”问题\n```js\nvar a = { n: 1 }\nvar b = a\na.x = a = { n: 2 }\nalert(a.x) // --> undefined\nalert(b.x) // --> { n: 2 }\n```\n\n理解该问题需要知道以下两点：\n- JS引擎对赋值表达式的处理过程\n- 赋值运算的右结合性\n\n#### JS引擎对赋值表达式的处理过程\n如赋值表达式 `A = B`\n1. 计算表达式左表达式A，得到一个引用refA\n2. 计算表达式B，得到一个引用refB\n3. 通过 `GetValue(refB)` 得到valueB\n4. 进行判断，当如下情况全部符合则抛出语法异常\n   1. refA是一个引用\n   2. refA是一个严格引用\n   3. refA是一个 `environment records`(**这里理解是refA是一个声明的变量或者是对象的某个属性**)\n   4. refA的引用名是’eval‘或’arguments‘\n5. 将valueB赋给refA指向的名称绑定\n6. 返回valueB\n\n*`GetValue(refB)` 是通过一系列判断得出value值，具体步骤参考[GetValue(refB)](http://es5.github.io/#x8.7.1)*\n\n具体参考：\n> [http://es5.github.io/#x11.13.1](http://es5.github.io/#x11.13.1)\n\n#### 结合性\n所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。\n赋值表达式是右结合的。这意味着：`A1 = A2 = A3 = A4` 等价于 `A1 = (A2 = (A3 = A4))`\n\n\n总的简单s来说就是：***先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用***\n\n#### 分析\n```js\na.x = a = { n: 2 }\n```\n首先得到 a.x 和 a 的两个引用\n得到右表达式是一个对象 `{ n: 2 }`\na.x 和 a 的两个引用并且判断属于 `environment records`（a.x 属于对象的某个属性，a属于当前上下文的变量a）\n将 `{ n: 2 }` 赋值给 当前上下文变量 a 的 refA，a已被重新赋值为 `{ n: 2 }`\n将 `{ n: 2 }` 赋值给 当前上下文变量 a.x 的 ref（a.x）*ref（a.x）与ref（b.x）是同一个*, refA已经与 `{ n: 2 }` 重新绑定，所以此时 b 为 `{ n: 1, x: { n: 2 } }`\n\n所以最终结果：a为 `{ n：2 }`，b为 `{ n: 1, x: { n: 2 } }`, 并且由于是同一个对象 `{ n: 2 }` 赋值给b.x以及a获得的引用相同，所以 `b.x === a`\n\n所以 `a.x` 为 `undefined`, `b.x` 为 `{ n: 2 }`\n\nLink:\n> [由ES规范学JavaScript(二)：深入理解“连等赋值”问题](https://segmentfault.com/a/1190000004224719)\n\n# 立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)\n```js\n(function A() {\n    console.log(A) // [Function A]\n    A = 1\n    console.log(window.A) // undefined\n    console.log(A) // [Function A]\n}())\n```\n上面立即执行函数中直接将1赋值给一个未声明的变量，正常逻辑下我们知道会将他绑定的全局作为全局变量，但是上面的输出显然不是如此，原因在于匿名执行函数有了名字且和赋值的变量A同名\n\n有了名字的函数（NFE）有两个特性：\n- 作为函数名的标识符（在这里是 A ）只能从函数体内部访问，在函数外部访问不到 (IE9+)\n- 绑定为函数名的标识符（在这里是A）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），所以在 NFE 函数体内对 A 重新赋值是无效的\n\n创建 NFE 的机制：\n> The production FunctionExpression : function Identifier (\nFormalParameterListopt ) { FunctionBody }\nis evaluated as follows:\n  - Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument\n  - Let envRec be funcEnv’s environment record.\n  - Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.\n  - Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.\n  - Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.\n  - Return closure.\n\n注意步骤 3 和 5，分别调用了 createImmutableBinding 和 InitializeImmutableBinding 内部方法，**创建的是不可更改的绑定**\n\n要理解这两个特性，最重要的是搞清楚标识符 A的绑定记录保存在哪里。让我们问自己几个问题：\n1. 标识符 A 与 该 NFE 是什么关系？ 两层关系：首先，该 NFE 的 name 属性是 字符串 'A'；更重要的是，A是该 NFE 的一个自由变量。在函数体内部，我们引用了 A，但 A 既不是该 NFE 的形参，又不是它的局部变量，那它不是自由变量是什么！解析自由变量，要从函数的 [[scope]] 内部属性所保存的词法环境 (Lexical Environment) 中查找变量的绑定记录。\n\n2. 标识符 A 保存在全局执行环境（Global Execution Context）的词法环境(Lexical Environment)中吗？ 答案是否。如果你仔细看过 ES5 Section 13 这一节，会发现创建 NFE 比创建 匿名函数表达式 （Anonymous Function Expression, AFE） 和 函数声明 (Function Declaration) 的过程要复杂得多\n\n那么为何创建 NFE 要搞得那么复杂呢？就是为了实现 NFE 的只能从函数内部访问A，而不能从外部访问这一特性！咋实现的？ 创建 NFE 时，创建了一个专门的词法环境用于保存 A 的绑定记录(见上面步骤 1~3)！对于 NFE, 有如下关系：\n```js\nA.[[scope]]\n  --->  Lexical Environment {'environment record': {A: function ...}, outer: --}\n  ---> Lexical Environment of Global Context {'environment record': {...}, outer --}\n  ---> null\n```\n\n可见，A 的绑定记录不在全局执行上下文的词法环境中，故不能从外部访问\n\n但是有个疑问：如果内部输出的时候进行赋值呢？\n```js\n(function A() {\n    console.log(A = 100) // 100\n}())\n```\n却可以打印出100，<a href=\"#JS引擎对赋值表达式的处理过程\">JS引擎对赋值表达式的处理过程</a>中我们知道赋值表达式最终结果是返回这个值，如果NFE内部没有成功赋值为何可以打印出100呢？\n\nLink:\n> [在JavaScript的立即执行的具名函数A内修改A的值时到底发生了什么](https://segmentfault.com/q/1010000002810093)","slug":"writeSomething/interestingCode","published":1,"updated":"2019-03-16T10:15:35.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxy4003hax4858fjy1gw","content":"<p>JS相关各类型题目记录<br><a id=\"more\"></a></p>\n<h1 id=\"JS执行上下文（作用域）以及变量提升\"><a href=\"#JS执行上下文（作用域）以及变量提升\" class=\"headerlink\" title=\"JS执行上下文（作用域）以及变量提升\"></a>JS执行上下文（作用域）以及变量提升</h1><p>先看题目：以下代码输出分别是什么</p>\n<h6 id=\"平安的一道笔试题\"><a href=\"#平安的一道笔试题\" class=\"headerlink\" title=\"平安的一道笔试题\"></a>平安的一道笔试题</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  a()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    a()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' try'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">100</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' catch'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function fn'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function a'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">1000</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, <span class=\"string\">'outer result'</span>)</span><br></pre></td></tr></table></figure>\n<p>先试着预想一下执行结果<br>.<br>.<br>.<br>.<br>.<br>.<br>输出<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [Function] inner function a</span></span><br><span class=\"line\"><span class=\"comment\">// 1 catch</span></span><br><span class=\"line\"><span class=\"comment\">// 1 inner function fn</span></span><br><span class=\"line\"><span class=\"comment\">// 10 outer result</span></span><br></pre></td></tr></table></figure></p>\n<p>是否和预想的一致呢？</p>\n<p>先来了解几个概念：</p>\n<ul>\n<li>每一个函数都有自己的执行上下文EC（执行环境 execution context）<ul>\n<li>全局脚本是一个全局上下文</li>\n</ul>\n</li>\n<li>EC预解析的时候会有变量提升<ul>\n<li>只有关键字声明的变量才会有变量提升</li>\n<li>函数优先级高于普通变量</li>\n</ul>\n</li>\n</ul>\n<p>下面开始分析一下执行结果<br>首先 fn 会获得变量提升然后声明并且赋值全局变量 <code>var a = 10</code> </p>\n<p>执行fn：</p>\n<ul>\n<li><p>首先 fn 内部进行变量提升</p>\n<ul>\n<li>内部函数a提升到当前EC顶部</li>\n<li><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function a'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">1000</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  a()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>主要的一点：fn 内部的变量 a 已经被重新声明 相当于 <code>var a = function () {}</code> 所以此处 fn 内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>fn内部输出：</p>\n<ul>\n<li>a本身是个函数，invoke a() 输出 <code>[Function] inner function a</code>，然后将fn内部的 a 重新赋值为1000</li>\n<li>执行try语句：<ul>\n<li>a是1000所以 invoke a()会抛出异常 <code>a is not a function</code> 被catch语句捕获，当前try语句终端不在继续向下执行<ul>\n<li><em>try语句内部的 <code>a = 100</code> 只是简单的赋值操作，没有关键字声明所以没有变量提升</em></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>执行catch语句<ul>\n<li>重新赋值 <code>a = 1</code>，输出 <code>a catch</code></li>\n</ul>\n</li>\n<li>try catch语句执行结束继续向下执行, 此时a已经被catch语句赋值为1输出 <code>1 inner function fn</code></li>\n</ul>\n<p>fn执行结束继续执行全局上下文环境中的代码，上面说了fn内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局, 所以全局上下文中a依旧是10，输出 10<br>运行结束</p>\n<h1 id=\"深入理解“连等赋值”问题\"><a href=\"#深入理解“连等赋值”问题\" class=\"headerlink\" title=\"深入理解“连等赋值”问题\"></a>深入理解“连等赋值”问题</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a</span><br><span class=\"line\">a.x = a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">alert(a.x) <span class=\"comment\">// --&gt; undefined</span></span><br><span class=\"line\">alert(b.x) <span class=\"comment\">// --&gt; &#123; n: 2 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>理解该问题需要知道以下两点：</p>\n<ul>\n<li>JS引擎对赋值表达式的处理过程</li>\n<li>赋值运算的右结合性</li>\n</ul>\n<h4 id=\"JS引擎对赋值表达式的处理过程\"><a href=\"#JS引擎对赋值表达式的处理过程\" class=\"headerlink\" title=\"JS引擎对赋值表达式的处理过程\"></a>JS引擎对赋值表达式的处理过程</h4><p>如赋值表达式 <code>A = B</code></p>\n<ol>\n<li>计算表达式左表达式A，得到一个引用refA</li>\n<li>计算表达式B，得到一个引用refB</li>\n<li>通过 <code>GetValue(refB)</code> 得到valueB</li>\n<li>进行判断，当如下情况全部符合则抛出语法异常<ol>\n<li>refA是一个引用</li>\n<li>refA是一个严格引用</li>\n<li>refA是一个 <code>environment records</code>(<strong>这里理解是refA是一个声明的变量或者是对象的某个属性</strong>)</li>\n<li>refA的引用名是’eval‘或’arguments‘</li>\n</ol>\n</li>\n<li>将valueB赋给refA指向的名称绑定</li>\n<li>返回valueB</li>\n</ol>\n<p><em><code>GetValue(refB)</code> 是通过一系列判断得出value值，具体步骤参考<a href=\"http://es5.github.io/#x8.7.1\" target=\"_blank\" rel=\"noopener\">GetValue(refB)</a></em></p>\n<p>具体参考：</p>\n<blockquote>\n<p><a href=\"http://es5.github.io/#x11.13.1\" target=\"_blank\" rel=\"noopener\">http://es5.github.io/#x11.13.1</a></p>\n</blockquote>\n<h4 id=\"结合性\"><a href=\"#结合性\" class=\"headerlink\" title=\"结合性\"></a>结合性</h4><p>所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。<br>赋值表达式是右结合的。这意味着：<code>A1 = A2 = A3 = A4</code> 等价于 <code>A1 = (A2 = (A3 = A4))</code></p>\n<p>总的简单s来说就是：<strong><em>先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用</em></strong></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.x = a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">2</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>首先得到 a.x 和 a 的两个引用<br>得到右表达式是一个对象 <code>{ n: 2 }</code><br>a.x 和 a 的两个引用并且判断属于 <code>environment records</code>（a.x 属于对象的某个属性，a属于当前上下文的变量a）<br>将 <code>{ n: 2 }</code> 赋值给 当前上下文变量 a 的 refA，a已被重新赋值为 <code>{ n: 2 }</code><br>将 <code>{ n: 2 }</code> 赋值给 当前上下文变量 a.x 的 ref（a.x）<em>ref（a.x）与ref（b.x）是同一个</em>, refA已经与 <code>{ n: 2 }</code> 重新绑定，所以此时 b 为 <code>{ n: 1, x: { n: 2 } }</code></p>\n<p>所以最终结果：a为 <code>{ n：2 }</code>，b为 <code>{ n: 1, x: { n: 2 } }</code>, 并且由于是同一个对象 <code>{ n: 2 }</code> 赋值给b.x以及a获得的引用相同，所以 <code>b.x === a</code></p>\n<p>所以 <code>a.x</code> 为 <code>undefined</code>, <code>b.x</code> 为 <code>{ n: 2 }</code></p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000004224719\" target=\"_blank\" rel=\"noopener\">由ES规范学JavaScript(二)：深入理解“连等赋值”问题</a></p>\n</blockquote>\n<h1 id=\"立即执行的函数-Immediately-invoked-function-的具名函数表达式-Named-function-expression-NFE\"><a href=\"#立即执行的函数-Immediately-invoked-function-的具名函数表达式-Named-function-expression-NFE\" class=\"headerlink\" title=\"立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)\"></a>立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A) <span class=\"comment\">// [Function A]</span></span><br><span class=\"line\">    A = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.A) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A) <span class=\"comment\">// [Function A]</span></span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure>\n<p>上面立即执行函数中直接将1赋值给一个未声明的变量，正常逻辑下我们知道会将他绑定的全局作为全局变量，但是上面的输出显然不是如此，原因在于匿名执行函数有了名字且和赋值的变量A同名</p>\n<p>有了名字的函数（NFE）有两个特性：</p>\n<ul>\n<li>作为函数名的标识符（在这里是 A ）只能从函数体内部访问，在函数外部访问不到 (IE9+)</li>\n<li>绑定为函数名的标识符（在这里是A）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），所以在 NFE 函数体内对 A 重新赋值是无效的</li>\n</ul>\n<p>创建 NFE 的机制：</p>\n<blockquote>\n<p>The production FunctionExpression : function Identifier (<br>FormalParameterListopt ) { FunctionBody }<br>is evaluated as follows:</p>\n<ul>\n<li>Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument</li>\n<li>Let envRec be funcEnv’s environment record.</li>\n<li>Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.</li>\n<li>Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.</li>\n<li>Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.</li>\n<li>Return closure.</li>\n</ul>\n</blockquote>\n<p>注意步骤 3 和 5，分别调用了 createImmutableBinding 和 InitializeImmutableBinding 内部方法，<strong>创建的是不可更改的绑定</strong></p>\n<p>要理解这两个特性，最重要的是搞清楚标识符 A的绑定记录保存在哪里。让我们问自己几个问题：</p>\n<ol>\n<li><p>标识符 A 与 该 NFE 是什么关系？ 两层关系：首先，该 NFE 的 name 属性是 字符串 ‘A’；更重要的是，A是该 NFE 的一个自由变量。在函数体内部，我们引用了 A，但 A 既不是该 NFE 的形参，又不是它的局部变量，那它不是自由变量是什么！解析自由变量，要从函数的 [[scope]] 内部属性所保存的词法环境 (Lexical Environment) 中查找变量的绑定记录。</p>\n</li>\n<li><p>标识符 A 保存在全局执行环境（Global Execution Context）的词法环境(Lexical Environment)中吗？ 答案是否。如果你仔细看过 ES5 Section 13 这一节，会发现创建 NFE 比创建 匿名函数表达式 （Anonymous Function Expression, AFE） 和 函数声明 (Function Declaration) 的过程要复杂得多</p>\n</li>\n</ol>\n<p>那么为何创建 NFE 要搞得那么复杂呢？就是为了实现 NFE 的只能从函数内部访问A，而不能从外部访问这一特性！咋实现的？ 创建 NFE 时，创建了一个专门的词法环境用于保存 A 的绑定记录(见上面步骤 1~3)！对于 NFE, 有如下关系：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A.[[scope]]</span><br><span class=\"line\">  ---&gt;  Lexical Environment &#123;<span class=\"string\">'environment record'</span>: &#123;<span class=\"attr\">A</span>: <span class=\"function\"><span class=\"keyword\">function</span> ...&#125;, <span class=\"title\">outer</span>: --&#125;</span></span><br><span class=\"line\"><span class=\"function\">  ---&gt; <span class=\"title\">Lexical</span> <span class=\"title\">Environment</span> <span class=\"title\">of</span> <span class=\"title\">Global</span> <span class=\"title\">Context</span> </span>&#123;<span class=\"string\">'environment record'</span>: &#123;...&#125;, outer --&#125;</span><br><span class=\"line\">  ---&gt; <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure></p>\n<p>可见，A 的绑定记录不在全局执行上下文的词法环境中，故不能从外部访问</p>\n<p>但是有个疑问：如果内部输出的时候进行赋值呢？<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A = <span class=\"number\">100</span>) <span class=\"comment\">// 100</span></span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure></p>\n<p>却可以打印出100，<a href=\"#JS引擎对赋值表达式的处理过程\">JS引擎对赋值表达式的处理过程</a>中我们知道赋值表达式最终结果是返回这个值，如果NFE内部没有成功赋值为何可以打印出100呢？</p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/q/1010000002810093\" target=\"_blank\" rel=\"noopener\">在JavaScript的立即执行的具名函数A内修改A的值时到底发生了什么</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>JS相关各类型题目记录<br></p>","more":"<p></p>\n<h1 id=\"JS执行上下文（作用域）以及变量提升\"><a href=\"#JS执行上下文（作用域）以及变量提升\" class=\"headerlink\" title=\"JS执行上下文（作用域）以及变量提升\"></a>JS执行上下文（作用域）以及变量提升</h1><p>先看题目：以下代码输出分别是什么</p>\n<h6 id=\"平安的一道笔试题\"><a href=\"#平安的一道笔试题\" class=\"headerlink\" title=\"平安的一道笔试题\"></a>平安的一道笔试题</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  a()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    a()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' try'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">100</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' catch'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function fn'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function a'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">1000</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, <span class=\"string\">'outer result'</span>)</span><br></pre></td></tr></table></figure>\n<p>先试着预想一下执行结果<br>.<br>.<br>.<br>.<br>.<br>.<br>输出<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [Function] inner function a</span></span><br><span class=\"line\"><span class=\"comment\">// 1 catch</span></span><br><span class=\"line\"><span class=\"comment\">// 1 inner function fn</span></span><br><span class=\"line\"><span class=\"comment\">// 10 outer result</span></span><br></pre></td></tr></table></figure></p>\n<p>是否和预想的一致呢？</p>\n<p>先来了解几个概念：</p>\n<ul>\n<li>每一个函数都有自己的执行上下文EC（执行环境 execution context）<ul>\n<li>全局脚本是一个全局上下文</li>\n</ul>\n</li>\n<li>EC预解析的时候会有变量提升<ul>\n<li>只有关键字声明的变量才会有变量提升</li>\n<li>函数优先级高于普通变量</li>\n</ul>\n</li>\n</ul>\n<p>下面开始分析一下执行结果<br>首先 fn 会获得变量提升然后声明并且赋值全局变量 <code>var a = 10</code> </p>\n<p>执行fn：</p>\n<ul>\n<li><p>首先 fn 内部进行变量提升</p>\n<ul>\n<li>内部函数a提升到当前EC顶部</li>\n<li><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function a'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">1000</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  a()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>主要的一点：fn 内部的变量 a 已经被重新声明 相当于 <code>var a = function () {}</code> 所以此处 fn 内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>fn内部输出：</p>\n<ul>\n<li>a本身是个函数，invoke a() 输出 <code>[Function] inner function a</code>，然后将fn内部的 a 重新赋值为1000</li>\n<li>执行try语句：<ul>\n<li>a是1000所以 invoke a()会抛出异常 <code>a is not a function</code> 被catch语句捕获，当前try语句终端不在继续向下执行<ul>\n<li><em>try语句内部的 <code>a = 100</code> 只是简单的赋值操作，没有关键字声明所以没有变量提升</em></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>执行catch语句<ul>\n<li>重新赋值 <code>a = 1</code>，输出 <code>a catch</code></li>\n</ul>\n</li>\n<li>try catch语句执行结束继续向下执行, 此时a已经被catch语句赋值为1输出 <code>1 inner function fn</code></li>\n</ul>\n<p>fn执行结束继续执行全局上下文环境中的代码，上面说了fn内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局, 所以全局上下文中a依旧是10，输出 10<br>运行结束</p>\n<h1 id=\"深入理解“连等赋值”问题\"><a href=\"#深入理解“连等赋值”问题\" class=\"headerlink\" title=\"深入理解“连等赋值”问题\"></a>深入理解“连等赋值”问题</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a</span><br><span class=\"line\">a.x = a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">alert(a.x) <span class=\"comment\">// --&gt; undefined</span></span><br><span class=\"line\">alert(b.x) <span class=\"comment\">// --&gt; &#123; n: 2 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>理解该问题需要知道以下两点：</p>\n<ul>\n<li>JS引擎对赋值表达式的处理过程</li>\n<li>赋值运算的右结合性</li>\n</ul>\n<h4 id=\"JS引擎对赋值表达式的处理过程\"><a href=\"#JS引擎对赋值表达式的处理过程\" class=\"headerlink\" title=\"JS引擎对赋值表达式的处理过程\"></a>JS引擎对赋值表达式的处理过程</h4><p>如赋值表达式 <code>A = B</code></p>\n<ol>\n<li>计算表达式左表达式A，得到一个引用refA</li>\n<li>计算表达式B，得到一个引用refB</li>\n<li>通过 <code>GetValue(refB)</code> 得到valueB</li>\n<li>进行判断，当如下情况全部符合则抛出语法异常<ol>\n<li>refA是一个引用</li>\n<li>refA是一个严格引用</li>\n<li>refA是一个 <code>environment records</code>(<strong>这里理解是refA是一个声明的变量或者是对象的某个属性</strong>)</li>\n<li>refA的引用名是’eval‘或’arguments‘</li>\n</ol>\n</li>\n<li>将valueB赋给refA指向的名称绑定</li>\n<li>返回valueB</li>\n</ol>\n<p><em><code>GetValue(refB)</code> 是通过一系列判断得出value值，具体步骤参考<a href=\"http://es5.github.io/#x8.7.1\" target=\"_blank\" rel=\"noopener\">GetValue(refB)</a></em></p>\n<p>具体参考：</p>\n<blockquote>\n<p><a href=\"http://es5.github.io/#x11.13.1\" target=\"_blank\" rel=\"noopener\">http://es5.github.io/#x11.13.1</a></p>\n</blockquote>\n<h4 id=\"结合性\"><a href=\"#结合性\" class=\"headerlink\" title=\"结合性\"></a>结合性</h4><p>所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。<br>赋值表达式是右结合的。这意味着：<code>A1 = A2 = A3 = A4</code> 等价于 <code>A1 = (A2 = (A3 = A4))</code></p>\n<p>总的简单s来说就是：<strong><em>先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用</em></strong></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.x = a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">2</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>首先得到 a.x 和 a 的两个引用<br>得到右表达式是一个对象 <code>{ n: 2 }</code><br>a.x 和 a 的两个引用并且判断属于 <code>environment records</code>（a.x 属于对象的某个属性，a属于当前上下文的变量a）<br>将 <code>{ n: 2 }</code> 赋值给 当前上下文变量 a 的 refA，a已被重新赋值为 <code>{ n: 2 }</code><br>将 <code>{ n: 2 }</code> 赋值给 当前上下文变量 a.x 的 ref（a.x）<em>ref（a.x）与ref（b.x）是同一个</em>, refA已经与 <code>{ n: 2 }</code> 重新绑定，所以此时 b 为 <code>{ n: 1, x: { n: 2 } }</code></p>\n<p>所以最终结果：a为 <code>{ n：2 }</code>，b为 <code>{ n: 1, x: { n: 2 } }</code>, 并且由于是同一个对象 <code>{ n: 2 }</code> 赋值给b.x以及a获得的引用相同，所以 <code>b.x === a</code></p>\n<p>所以 <code>a.x</code> 为 <code>undefined</code>, <code>b.x</code> 为 <code>{ n: 2 }</code></p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000004224719\" target=\"_blank\" rel=\"noopener\">由ES规范学JavaScript(二)：深入理解“连等赋值”问题</a></p>\n</blockquote>\n<h1 id=\"立即执行的函数-Immediately-invoked-function-的具名函数表达式-Named-function-expression-NFE\"><a href=\"#立即执行的函数-Immediately-invoked-function-的具名函数表达式-Named-function-expression-NFE\" class=\"headerlink\" title=\"立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)\"></a>立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A) <span class=\"comment\">// [Function A]</span></span><br><span class=\"line\">    A = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.A) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A) <span class=\"comment\">// [Function A]</span></span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure>\n<p>上面立即执行函数中直接将1赋值给一个未声明的变量，正常逻辑下我们知道会将他绑定的全局作为全局变量，但是上面的输出显然不是如此，原因在于匿名执行函数有了名字且和赋值的变量A同名</p>\n<p>有了名字的函数（NFE）有两个特性：</p>\n<ul>\n<li>作为函数名的标识符（在这里是 A ）只能从函数体内部访问，在函数外部访问不到 (IE9+)</li>\n<li>绑定为函数名的标识符（在这里是A）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），所以在 NFE 函数体内对 A 重新赋值是无效的</li>\n</ul>\n<p>创建 NFE 的机制：</p>\n<blockquote>\n<p>The production FunctionExpression : function Identifier (<br>FormalParameterListopt ) { FunctionBody }<br>is evaluated as follows:</p>\n<ul>\n<li>Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument</li>\n<li>Let envRec be funcEnv’s environment record.</li>\n<li>Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.</li>\n<li>Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.</li>\n<li>Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.</li>\n<li>Return closure.</li>\n</ul>\n</blockquote>\n<p>注意步骤 3 和 5，分别调用了 createImmutableBinding 和 InitializeImmutableBinding 内部方法，<strong>创建的是不可更改的绑定</strong></p>\n<p>要理解这两个特性，最重要的是搞清楚标识符 A的绑定记录保存在哪里。让我们问自己几个问题：</p>\n<ol>\n<li><p>标识符 A 与 该 NFE 是什么关系？ 两层关系：首先，该 NFE 的 name 属性是 字符串 ‘A’；更重要的是，A是该 NFE 的一个自由变量。在函数体内部，我们引用了 A，但 A 既不是该 NFE 的形参，又不是它的局部变量，那它不是自由变量是什么！解析自由变量，要从函数的 [[scope]] 内部属性所保存的词法环境 (Lexical Environment) 中查找变量的绑定记录。</p>\n</li>\n<li><p>标识符 A 保存在全局执行环境（Global Execution Context）的词法环境(Lexical Environment)中吗？ 答案是否。如果你仔细看过 ES5 Section 13 这一节，会发现创建 NFE 比创建 匿名函数表达式 （Anonymous Function Expression, AFE） 和 函数声明 (Function Declaration) 的过程要复杂得多</p>\n</li>\n</ol>\n<p>那么为何创建 NFE 要搞得那么复杂呢？就是为了实现 NFE 的只能从函数内部访问A，而不能从外部访问这一特性！咋实现的？ 创建 NFE 时，创建了一个专门的词法环境用于保存 A 的绑定记录(见上面步骤 1~3)！对于 NFE, 有如下关系：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A.[[scope]]</span><br><span class=\"line\">  ---&gt;  Lexical Environment &#123;<span class=\"string\">'environment record'</span>: &#123;<span class=\"attr\">A</span>: <span class=\"function\"><span class=\"keyword\">function</span> ...&#125;, <span class=\"title\">outer</span>: --&#125;</span></span><br><span class=\"line\"><span class=\"function\">  ---&gt; <span class=\"title\">Lexical</span> <span class=\"title\">Environment</span> <span class=\"title\">of</span> <span class=\"title\">Global</span> <span class=\"title\">Context</span> </span>&#123;<span class=\"string\">'environment record'</span>: &#123;...&#125;, outer --&#125;</span><br><span class=\"line\">  ---&gt; <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure></p>\n<p>可见，A 的绑定记录不在全局执行上下文的词法环境中，故不能从外部访问</p>\n<p>但是有个疑问：如果内部输出的时候进行赋值呢？<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A = <span class=\"number\">100</span>) <span class=\"comment\">// 100</span></span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure></p>\n<p>却可以打印出100，<a href=\"#JS引擎对赋值表达式的处理过程\">JS引擎对赋值表达式的处理过程</a>中我们知道赋值表达式最终结果是返回这个值，如果NFE内部没有成功赋值为何可以打印出100呢？</p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/q/1010000002810093\" target=\"_blank\" rel=\"noopener\">在JavaScript的立即执行的具名函数A内修改A的值时到底发生了什么</a></p>\n</blockquote>"},{"title":"JS常用的设计模式","date":"2019-02-24T14:52:00.000Z","_content":"持续更新\nJS常用的设计模式以及应用场景\n<!-- more -->\n*以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝*\n\n# 何谓设计模式\n\n没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多\n\n抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位\n\n定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案\n\n补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题\n\n软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍\n\n# 设计原则\n在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：\n- 单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度\n\n- 最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理\n\n- 开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定\n\n\n\n# 从最简单的单体/单例模式开始\n\n### 定义：\n\n单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象\n\n单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例\n*在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供*\n\n### 优点:\n- 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例\n- 因为类控制了实例化过程，所以类可以灵活更改实例化过程\n- 单体可以控制局部变量污染\n\n### 应用场景：\n- 可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存\n- 借助单例模式，可以把代码组织的更为一致\n\n#### 最基本的单体模式\n直接导出一个方法属性集合的对象\n```js\n// commonjs 导出\nmodule.exports = {\n  getSingleton() {\n    return this \n  }\n}\n```\n#### 用闭包来实现单例\n```js\nconst Ins1 = (function() {\n  let instance = null\n  // 利用闭包特性保证实例私有化\n  return function(opt) {\n    if (instance === null) {\n      instance = this\n    }\n\n    for(let k in opt) {\n      instance[k] = opt[k]\n    }\n\n    return instance\n  }\n})()\n```\n测试：\n```js\nconst i1 = new Ins1({ name: 'i1' })\n\nconst i2 = new Ins1({ name: 'i2' })\n\nconsole.log(i1 === i2) // true\n\nconsole.log(i1.name) // i2\n```\n补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： `class T {} export default new T` 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化\n\n# 策略模式\n\n### 定义：\n就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则\n\n### 优点：\n- 减少`command c & command v`, 提高复用性\n- 遵循开闭原则，算法独立易于切换、理解、拓展\n\n### 应用场景：\n针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试\n\n#### 最简单的执行\n```js\nfunction closure() {\n  // 定义\n  const strategies = {\n      plus10: function(arg) {\n        return arg + 10\n      },\n      plus100: function(arg) {\n        return arg + 100\n      }\n  }\n  // 执行\n  return function(plus, base){\n    return strategies[plus](base);\n  }\n}\nconst strategy = closure()\n\nconsole.log(strategy('plus10', 1)) // 11\nconsole.log(strategy('plus100', 1)) // 101\n```\n#### 对比分析\neg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额\n\n意大利逻辑:\n\n```js\nfunction context (name, type, price) {\n  if (type === 'vip') {\n    return price * 0.5\n  } else if (type === 'vip') {\n    return price * 0.8\n  } else {\n    return price\n  }\n}\n```\n如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:\n``` js\nclass Vip {\n  constructor () {\n    this.discount = 0.5\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Old {\n  constructor () {\n    this.discount = 0.8\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Others {\n  constructor () {\n  }\n  getPrice (price) {\n    return price\n  }\n}\n\nclass Context {\n  constructor () {\n    this.name = ''\n    this.strategy = null\n    this.price = 0\n  }\n  setPrice (name, strategy, price) {\n    this.name = name\n    this.strategy = strategy\n    this.price = price\n  }\n  getPrice () {\n    console.log(this.name, this.strategy.getPrice(this.price), '元')\n    return this.strategy.getPrice(this.price)\n  }\n}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Vip\nconst old = new Old\nconst other = new Others\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本\n\n补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：\n```js\n// 定义父类\nclass Handler {\n  constructor(discount) {\n    // 不传为原价\n    this.discount = discount || 1\n  }\n\n  getPrice(price) {\n    return this.discount === 1\n      ? price\n      : this.discount * price\n  }\n}\n\n// 声明子类\nclass Sub extends Handler {}\n\n// 可以自定义更多不同级别顾客不同需求\n// class Test extend Handler {\n//   getGifts() {\n//     if (this.discount < 1) {\n//       // 赠送赠品\n//     }\n//   }\n// }\n// const master = new Test(0.1)\n// master.getGifts()\n\n// Context类同上方便统一接口输出\nclass Context {}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Sub(0.5)\nconst old = new Sub(0.8)\nconst other = new Sub\n\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n测试结果一致\n\n# 代理模式\n\n### 定义：\n为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用\n著名的代理模式例子为引用计数（reference counting）指针对象\n另外代理模式还可分为：\n- 虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象\n- 保护代理：用于控制不同权限的对象对目标对象的访问\n- 缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果\n\n### 优点：\n独立职责归属，便于维护测试\n\n### 应用场景：\n比如图片的懒加载，数据缓存等\n\n#### 虚拟代理实现图片懒加载\n```js\nconst imgSet = (() => {\n  let node = new Image\n  document.body.append(node)\n\n  return function(src) {\n    node.src = src\n  }\n})()\n\nconst proxyImg = (() => {\n  let _img = new Image\n\n  _img.onload = function() {\n    setTimeout(imgSet, 2000, this.src)\n  }\n\n  return function(src) {\n    imgSet('https://yphoto.eryufm.cn/upload/assets/jump.gif')\n    _img.src = src\n  }\n})()\n// call\nproxyImg(`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1551174639&di=90b4757f68c9480f78c132c930c1df10&src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`)\n```\n\n#### 保护代理\n对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发\n```js\n// filter some no use or unneed requestions or data\n// A  ---> B(proxy) ----> C\nconst a = {\n  name: 'a',\n  send (target, info) {\n    target.receive(info)\n  }\n}\nconst c = {\n  name: 'c',\n  receive (target, info) {\n    console.log('c receive ', info, ' from ', target.name)\n  }\n}\nconst b = {\n  name: 'b',\n  receive (info) {\n    if (info) {\n      c.receive(this, info)\n    }\n  }\n}\na.send(b, 'good morning')\na.send(b, '')\na.send(b, 'send again')\n\n// output:\n// c receive good morning from b\n// c receive send again from b\n```\n上面表示一个最简单的保护代理\n\n#### 缓存代理\n顾名思义就是缓存相关的代理\n\n有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存\n```js\n// 存储所有标签\nlet tags\n\nconst sendApiGetTags = index => {\n  // ajax.get('/api', { index })\n}\nlet proxyCache = (async () => {\n  const allTagsCache = {}\n  const number = 5\n  const all = []\n  const params = {}\n\n  for (let index = 0; index < number; index++) {\n    all.push(sendApiGetTags({\n      ...params,\n      index\n    }))\n  }\n  const list = await Promise.all(all)\n\n  list.forEach((res, i) => allTagsCache[i] = res)\n\n  return allTagsCache\n})()\n\nlet setTags = async index => {\n  // 缓存中有直接拿\n  if (proxyCache[index]) {\n    tags = proxyCache[index]\n  } else {\n  // 缓存中没有则重发请求\n    tags = await sendApiGetTags(index)\n  }\n}\n```\n\n\n\n# 发布订阅模式\n\n### 定义：\n一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。\n至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法\n\n### 优点：\n订阅者可以根据自己需求当某种Action被触发时完成自己的调度\n\n### 应用场景：\nAngularJs的广播、vue的eventbus等\n\n#### 根据主体构建发布订阅的基类\n构造发布者基类\n```js\nclass Publisher {\n  constructor () {\n    // 订阅发布者的队列 存储每个订阅者\n    this.subscribers = []\n  }\n  deliver (data) {\n    // 发布消息 调用订阅者的回调 告知订阅者\n    this.subscribers.forEach(fn => fn.shot(data))\n\n    return this\n  }\n}\n```\n构造订阅者基类\n```js\nclass Observer {\n  constructor (call) {\n    // 传入订阅回调\n    this.shot = call\n  }\n  subscribe (publisher) {\n    if (!publisher.subscribers.some(v => v.shot === this.shot)) {\n      console.log('订阅该消息')\n      // 判断当前订阅者是否订阅\n      publisher.subscribers.push(this)\n    }\n    return this\n  }\n  unsubscribe (publisher) {\n    // 移除当前订阅者\n    console.log('取消订阅')\n\n    publisher.subscribers = publisher.subscribers.filter(v => v.shot !== this.shot)\n\n    return this\n  }\n}\n```\n测试：\n```js\nconst pub = new Publisher\nconst pub2 = new Publisher\nconst obs = new Observer(deliver => console.log(deliver))\n\nobs.subscribe(pub) // 订阅该消息\nobs.subscribe(pub2) // 订阅该消息\n\npub.deliver('pub deliver first message') // pub deliver first message\npub2.deliver('pub2 deliver first message') // pub2 deliver first message\n\nobs.unsubscribe(pub) // 取消订阅\npub.deliver('pub deliver second message') //\n```\n\n# 装饰者模式\n\n### 定义：\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能\n\n### 优点：\n- 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互\n- 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展\n\n### 应用场景：\n- 需要扩展一个类的功能，或给一个类添加附加职责\n- 需要动态的给一个对象添加功能，这些功能可以再动态的撤销\n- 不必改动原本的逻辑造成不可知问题\n\n#### 给所有的函数调用添加调用前和调用后的钩子\n\n普通函数：\n```js\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nfn('let go') // lets go right now\n```\n我们知道JS中所有的函数都是基于父类 `Function` 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：\n```js\n// 执行前\nFunction.prototype.before = function (call) {\n  const fn = this\n  \n  // 返回体本身也是函数所以支持继续调用钩子\n  return function () {\n    // 调用钩子，同时参数传递到钩子内\n    call.apply(this, arguments)\n    // 调用自身\n    return fn.apply(this, arguments)\n  }\n}\n// 执行后\n// 和 before 同理\nFunction.prototype.after = function (call) {\n  const fn = this\n\n  return function () {\n    const res = fn.apply(this, arguments)\n\n    call.apply(this, arguments)\n\n    // 返回自身的返回值\n    return res\n  }\n}\n```\n测试：\n```js\n// 重新包装 fn\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nconst decoratorFn = fn.before(function (msg) {\n  console.log('when we go,', msg)\n}).after(function (msg){\n  console.log('had to go', msg)\n})\n\ndecoratorFn('lets go')\n\n// out put:\n// when we go, right now\n// lets go, right now\n// had to go, right now\n```\n# 职责链（责任链）模式\n\n### 定义：\n它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求\n\n### 优点：\n职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了\n\n### 应用场景：\nJS 中的事件冒泡（事件委托）就是经典案例\n\n#### 实例分析\n\n部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购\n下面分别抽象处理者构造基类\n\n责任链调度中心：\n```js\nclass Handler {\n  constructor() {\n    this.next = null\n  }\n  setNext(_handler) {\n    this.next = _handler\n  }\n  handleRequest(money) {}\n}\n\n\n```\n\n采购部经理：\n```js\nclass CGBHandler extends Handler {\n  handleRequest(money) {\n    // 1w\n    if (money < 10000){\n      console.log('1w以内，同意')\n    } else {\n      console.log('金额太大，只能处理1w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n总经理：\n```js\nclass ZJLHandler extends Handler {\n  handleRequest(money) {\n    // 10w\n    if (money < 100000){\n      console.log('10w以内，同意')\n    } else {\n      console.log('金额太大，只能处理10w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n董事长：\n```js\nclass DSZHandler extends Handler {\n  handleRequest(money) {\n    // 100w\n    if (money >= 100000){\n      console.log('10万以上的我来处理')\n      //处理其他逻辑\n    } \n  }\n}\n```\n\n封装客户端接口：\n```js\nconst dispatch = (function client() {\n  const cgb = new CGBHandler()\n  const zjl = new ZJLHandler()\n  const dsz = new DSZHandler()\n\n  cgb.setNext(zjl)\n  zjl.setNext(dsz)\n\n  return cgb.handleRequest.bind(cgb)\n})()\n```\n测试：\n```js\n\ndispath(800000)\n// output:\n// 金额太大，只能处理1w以内的采购\n// 金额太大，只能处理10w以内的采购\n// 10万以上的我来处理\n\ndispath(7000)\n// output:\n// 1w以内，同意\n\n```\n补充：\n- 纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理\n\n- 不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理\n\n.\n.\n.\n.\n.\n.\n未完待续...👏\n","source":"_posts/writeSomething/jsDesignPattern.md","raw":"---\ntitle: JS常用的设计模式\ntags:\n  - 设计模式\n  - 算法\ndate: 2019-02-24 22:52:00\ncategories: 算法\n---\n持续更新\nJS常用的设计模式以及应用场景\n<!-- more -->\n*以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝*\n\n# 何谓设计模式\n\n没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多\n\n抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位\n\n定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案\n\n补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题\n\n软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍\n\n# 设计原则\n在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：\n- 单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度\n\n- 最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理\n\n- 开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定\n\n\n\n# 从最简单的单体/单例模式开始\n\n### 定义：\n\n单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象\n\n单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例\n*在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供*\n\n### 优点:\n- 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例\n- 因为类控制了实例化过程，所以类可以灵活更改实例化过程\n- 单体可以控制局部变量污染\n\n### 应用场景：\n- 可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存\n- 借助单例模式，可以把代码组织的更为一致\n\n#### 最基本的单体模式\n直接导出一个方法属性集合的对象\n```js\n// commonjs 导出\nmodule.exports = {\n  getSingleton() {\n    return this \n  }\n}\n```\n#### 用闭包来实现单例\n```js\nconst Ins1 = (function() {\n  let instance = null\n  // 利用闭包特性保证实例私有化\n  return function(opt) {\n    if (instance === null) {\n      instance = this\n    }\n\n    for(let k in opt) {\n      instance[k] = opt[k]\n    }\n\n    return instance\n  }\n})()\n```\n测试：\n```js\nconst i1 = new Ins1({ name: 'i1' })\n\nconst i2 = new Ins1({ name: 'i2' })\n\nconsole.log(i1 === i2) // true\n\nconsole.log(i1.name) // i2\n```\n补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： `class T {} export default new T` 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化\n\n# 策略模式\n\n### 定义：\n就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则\n\n### 优点：\n- 减少`command c & command v`, 提高复用性\n- 遵循开闭原则，算法独立易于切换、理解、拓展\n\n### 应用场景：\n针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试\n\n#### 最简单的执行\n```js\nfunction closure() {\n  // 定义\n  const strategies = {\n      plus10: function(arg) {\n        return arg + 10\n      },\n      plus100: function(arg) {\n        return arg + 100\n      }\n  }\n  // 执行\n  return function(plus, base){\n    return strategies[plus](base);\n  }\n}\nconst strategy = closure()\n\nconsole.log(strategy('plus10', 1)) // 11\nconsole.log(strategy('plus100', 1)) // 101\n```\n#### 对比分析\neg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额\n\n意大利逻辑:\n\n```js\nfunction context (name, type, price) {\n  if (type === 'vip') {\n    return price * 0.5\n  } else if (type === 'vip') {\n    return price * 0.8\n  } else {\n    return price\n  }\n}\n```\n如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:\n``` js\nclass Vip {\n  constructor () {\n    this.discount = 0.5\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Old {\n  constructor () {\n    this.discount = 0.8\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Others {\n  constructor () {\n  }\n  getPrice (price) {\n    return price\n  }\n}\n\nclass Context {\n  constructor () {\n    this.name = ''\n    this.strategy = null\n    this.price = 0\n  }\n  setPrice (name, strategy, price) {\n    this.name = name\n    this.strategy = strategy\n    this.price = price\n  }\n  getPrice () {\n    console.log(this.name, this.strategy.getPrice(this.price), '元')\n    return this.strategy.getPrice(this.price)\n  }\n}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Vip\nconst old = new Old\nconst other = new Others\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本\n\n补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：\n```js\n// 定义父类\nclass Handler {\n  constructor(discount) {\n    // 不传为原价\n    this.discount = discount || 1\n  }\n\n  getPrice(price) {\n    return this.discount === 1\n      ? price\n      : this.discount * price\n  }\n}\n\n// 声明子类\nclass Sub extends Handler {}\n\n// 可以自定义更多不同级别顾客不同需求\n// class Test extend Handler {\n//   getGifts() {\n//     if (this.discount < 1) {\n//       // 赠送赠品\n//     }\n//   }\n// }\n// const master = new Test(0.1)\n// master.getGifts()\n\n// Context类同上方便统一接口输出\nclass Context {}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Sub(0.5)\nconst old = new Sub(0.8)\nconst other = new Sub\n\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n测试结果一致\n\n# 代理模式\n\n### 定义：\n为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用\n著名的代理模式例子为引用计数（reference counting）指针对象\n另外代理模式还可分为：\n- 虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象\n- 保护代理：用于控制不同权限的对象对目标对象的访问\n- 缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果\n\n### 优点：\n独立职责归属，便于维护测试\n\n### 应用场景：\n比如图片的懒加载，数据缓存等\n\n#### 虚拟代理实现图片懒加载\n```js\nconst imgSet = (() => {\n  let node = new Image\n  document.body.append(node)\n\n  return function(src) {\n    node.src = src\n  }\n})()\n\nconst proxyImg = (() => {\n  let _img = new Image\n\n  _img.onload = function() {\n    setTimeout(imgSet, 2000, this.src)\n  }\n\n  return function(src) {\n    imgSet('https://yphoto.eryufm.cn/upload/assets/jump.gif')\n    _img.src = src\n  }\n})()\n// call\nproxyImg(`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1551174639&di=90b4757f68c9480f78c132c930c1df10&src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`)\n```\n\n#### 保护代理\n对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发\n```js\n// filter some no use or unneed requestions or data\n// A  ---> B(proxy) ----> C\nconst a = {\n  name: 'a',\n  send (target, info) {\n    target.receive(info)\n  }\n}\nconst c = {\n  name: 'c',\n  receive (target, info) {\n    console.log('c receive ', info, ' from ', target.name)\n  }\n}\nconst b = {\n  name: 'b',\n  receive (info) {\n    if (info) {\n      c.receive(this, info)\n    }\n  }\n}\na.send(b, 'good morning')\na.send(b, '')\na.send(b, 'send again')\n\n// output:\n// c receive good morning from b\n// c receive send again from b\n```\n上面表示一个最简单的保护代理\n\n#### 缓存代理\n顾名思义就是缓存相关的代理\n\n有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存\n```js\n// 存储所有标签\nlet tags\n\nconst sendApiGetTags = index => {\n  // ajax.get('/api', { index })\n}\nlet proxyCache = (async () => {\n  const allTagsCache = {}\n  const number = 5\n  const all = []\n  const params = {}\n\n  for (let index = 0; index < number; index++) {\n    all.push(sendApiGetTags({\n      ...params,\n      index\n    }))\n  }\n  const list = await Promise.all(all)\n\n  list.forEach((res, i) => allTagsCache[i] = res)\n\n  return allTagsCache\n})()\n\nlet setTags = async index => {\n  // 缓存中有直接拿\n  if (proxyCache[index]) {\n    tags = proxyCache[index]\n  } else {\n  // 缓存中没有则重发请求\n    tags = await sendApiGetTags(index)\n  }\n}\n```\n\n\n\n# 发布订阅模式\n\n### 定义：\n一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。\n至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法\n\n### 优点：\n订阅者可以根据自己需求当某种Action被触发时完成自己的调度\n\n### 应用场景：\nAngularJs的广播、vue的eventbus等\n\n#### 根据主体构建发布订阅的基类\n构造发布者基类\n```js\nclass Publisher {\n  constructor () {\n    // 订阅发布者的队列 存储每个订阅者\n    this.subscribers = []\n  }\n  deliver (data) {\n    // 发布消息 调用订阅者的回调 告知订阅者\n    this.subscribers.forEach(fn => fn.shot(data))\n\n    return this\n  }\n}\n```\n构造订阅者基类\n```js\nclass Observer {\n  constructor (call) {\n    // 传入订阅回调\n    this.shot = call\n  }\n  subscribe (publisher) {\n    if (!publisher.subscribers.some(v => v.shot === this.shot)) {\n      console.log('订阅该消息')\n      // 判断当前订阅者是否订阅\n      publisher.subscribers.push(this)\n    }\n    return this\n  }\n  unsubscribe (publisher) {\n    // 移除当前订阅者\n    console.log('取消订阅')\n\n    publisher.subscribers = publisher.subscribers.filter(v => v.shot !== this.shot)\n\n    return this\n  }\n}\n```\n测试：\n```js\nconst pub = new Publisher\nconst pub2 = new Publisher\nconst obs = new Observer(deliver => console.log(deliver))\n\nobs.subscribe(pub) // 订阅该消息\nobs.subscribe(pub2) // 订阅该消息\n\npub.deliver('pub deliver first message') // pub deliver first message\npub2.deliver('pub2 deliver first message') // pub2 deliver first message\n\nobs.unsubscribe(pub) // 取消订阅\npub.deliver('pub deliver second message') //\n```\n\n# 装饰者模式\n\n### 定义：\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能\n\n### 优点：\n- 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互\n- 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展\n\n### 应用场景：\n- 需要扩展一个类的功能，或给一个类添加附加职责\n- 需要动态的给一个对象添加功能，这些功能可以再动态的撤销\n- 不必改动原本的逻辑造成不可知问题\n\n#### 给所有的函数调用添加调用前和调用后的钩子\n\n普通函数：\n```js\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nfn('let go') // lets go right now\n```\n我们知道JS中所有的函数都是基于父类 `Function` 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：\n```js\n// 执行前\nFunction.prototype.before = function (call) {\n  const fn = this\n  \n  // 返回体本身也是函数所以支持继续调用钩子\n  return function () {\n    // 调用钩子，同时参数传递到钩子内\n    call.apply(this, arguments)\n    // 调用自身\n    return fn.apply(this, arguments)\n  }\n}\n// 执行后\n// 和 before 同理\nFunction.prototype.after = function (call) {\n  const fn = this\n\n  return function () {\n    const res = fn.apply(this, arguments)\n\n    call.apply(this, arguments)\n\n    // 返回自身的返回值\n    return res\n  }\n}\n```\n测试：\n```js\n// 重新包装 fn\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nconst decoratorFn = fn.before(function (msg) {\n  console.log('when we go,', msg)\n}).after(function (msg){\n  console.log('had to go', msg)\n})\n\ndecoratorFn('lets go')\n\n// out put:\n// when we go, right now\n// lets go, right now\n// had to go, right now\n```\n# 职责链（责任链）模式\n\n### 定义：\n它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求\n\n### 优点：\n职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了\n\n### 应用场景：\nJS 中的事件冒泡（事件委托）就是经典案例\n\n#### 实例分析\n\n部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购\n下面分别抽象处理者构造基类\n\n责任链调度中心：\n```js\nclass Handler {\n  constructor() {\n    this.next = null\n  }\n  setNext(_handler) {\n    this.next = _handler\n  }\n  handleRequest(money) {}\n}\n\n\n```\n\n采购部经理：\n```js\nclass CGBHandler extends Handler {\n  handleRequest(money) {\n    // 1w\n    if (money < 10000){\n      console.log('1w以内，同意')\n    } else {\n      console.log('金额太大，只能处理1w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n总经理：\n```js\nclass ZJLHandler extends Handler {\n  handleRequest(money) {\n    // 10w\n    if (money < 100000){\n      console.log('10w以内，同意')\n    } else {\n      console.log('金额太大，只能处理10w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n董事长：\n```js\nclass DSZHandler extends Handler {\n  handleRequest(money) {\n    // 100w\n    if (money >= 100000){\n      console.log('10万以上的我来处理')\n      //处理其他逻辑\n    } \n  }\n}\n```\n\n封装客户端接口：\n```js\nconst dispatch = (function client() {\n  const cgb = new CGBHandler()\n  const zjl = new ZJLHandler()\n  const dsz = new DSZHandler()\n\n  cgb.setNext(zjl)\n  zjl.setNext(dsz)\n\n  return cgb.handleRequest.bind(cgb)\n})()\n```\n测试：\n```js\n\ndispath(800000)\n// output:\n// 金额太大，只能处理1w以内的采购\n// 金额太大，只能处理10w以内的采购\n// 10万以上的我来处理\n\ndispath(7000)\n// output:\n// 1w以内，同意\n\n```\n补充：\n- 纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理\n\n- 不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理\n\n.\n.\n.\n.\n.\n.\n未完待续...👏\n","slug":"writeSomething/jsDesignPattern","published":1,"updated":"2019-03-05T08:28:36.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03jyxyn0041ax48y34elqr7","content":"<p>持续更新<br>JS常用的设计模式以及应用场景<br><a id=\"more\"></a><br><em>以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝</em></p>\n<h1 id=\"何谓设计模式\"><a href=\"#何谓设计模式\" class=\"headerlink\" title=\"何谓设计模式\"></a>何谓设计模式</h1><p>没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多</p>\n<p>抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位</p>\n<p>定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案</p>\n<p>补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题</p>\n<p>软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍</p>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><p>在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：</p>\n<ul>\n<li><p>单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度</p>\n</li>\n<li><p>最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理</p>\n</li>\n<li><p>开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定</p>\n</li>\n</ul>\n<h1 id=\"从最简单的单体-单例模式开始\"><a href=\"#从最简单的单体-单例模式开始\" class=\"headerlink\" title=\"从最简单的单体/单例模式开始\"></a>从最简单的单体/单例模式开始</h1><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象</p>\n<p>单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例<br><em>在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供</em></p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例</li>\n<li>因为类控制了实例化过程，所以类可以灵活更改实例化过程</li>\n<li>单体可以控制局部变量污染</li>\n</ul>\n<h3 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存</li>\n<li>借助单例模式，可以把代码组织的更为一致</li>\n</ul>\n<h4 id=\"最基本的单体模式\"><a href=\"#最基本的单体模式\" class=\"headerlink\" title=\"最基本的单体模式\"></a>最基本的单体模式</h4><p>直接导出一个方法属性集合的对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// commonjs 导出</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  getSingleton() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"用闭包来实现单例\"><a href=\"#用闭包来实现单例\" class=\"headerlink\" title=\"用闭包来实现单例\"></a>用闭包来实现单例</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Ins1 = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> instance = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"comment\">// 利用闭包特性保证实例私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opt</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> opt) &#123;</span><br><span class=\"line\">      instance[k] = opt[k]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> i1 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i1'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> i2 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i2'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1 === i2) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1.name) <span class=\"comment\">// i2</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： <code>class T {} export default new T</code> 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化</p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><h3 id=\"定义：-1\"><a href=\"#定义：-1\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>减少<code>command c &amp; command v</code>, 提高复用性</li>\n<li>遵循开闭原则，算法独立易于切换、理解、拓展</li>\n</ul>\n<h3 id=\"应用场景：-1\"><a href=\"#应用场景：-1\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试</p>\n<h4 id=\"最简单的执行\"><a href=\"#最简单的执行\" class=\"headerlink\" title=\"最简单的执行\"></a>最简单的执行</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> strategies = &#123;</span><br><span class=\"line\">      plus10: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">10</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      plus100: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">100</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plus, base</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strategies[plus](base);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> strategy = closure()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus10'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus100'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 101</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对比分析\"><a href=\"#对比分析\" class=\"headerlink\" title=\"对比分析\"></a>对比分析</h4><p>eg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额</p>\n<p>意大利逻辑:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">context</span> (<span class=\"params\">name, type, price</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vip</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Old</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Others</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setPrice (name, strategy, price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name, <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price), <span class=\"string\">'元'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Vip</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Old</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Others</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本</p>\n<p>补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义父类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(discount) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不传为原价</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = discount || <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice(price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount === <span class=\"number\">1</span></span><br><span class=\"line\">      ? price</span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以自定义更多不同级别顾客不同需求</span></span><br><span class=\"line\"><span class=\"comment\">// class Test extend Handler &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   getGifts() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     if (this.discount &lt; 1) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       // 赠送赠品</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// const master = new Test(0.1)</span></span><br><span class=\"line\"><span class=\"comment\">// master.getGifts()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Context类同上方便统一接口输出</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.5</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.8</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Sub</span><br><span class=\"line\"></span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>测试结果一致</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"定义：-2\"><a href=\"#定义：-2\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用<br>著名的代理模式例子为引用计数（reference counting）指针对象<br>另外代理模式还可分为：</p>\n<ul>\n<li>虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象</li>\n<li>保护代理：用于控制不同权限的对象对目标对象的访问</li>\n<li>缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</li>\n</ul>\n<h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>独立职责归属，便于维护测试</p>\n<h3 id=\"应用场景：-2\"><a href=\"#应用场景：-2\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>比如图片的懒加载，数据缓存等</p>\n<h4 id=\"虚拟代理实现图片懒加载\"><a href=\"#虚拟代理实现图片懒加载\" class=\"headerlink\" title=\"虚拟代理实现图片懒加载\"></a>虚拟代理实现图片懒加载</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> imgSet = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.append(node)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    node.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxyImg = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _img = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\"></span><br><span class=\"line\">  _img.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(imgSet, <span class=\"number\">2000</span>, <span class=\"keyword\">this</span>.src)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    imgSet(<span class=\"string\">'https://yphoto.eryufm.cn/upload/assets/jump.gif'</span>)</span><br><span class=\"line\">    _img.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">// call</span></span><br><span class=\"line\">proxyImg(<span class=\"string\">`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1551174639&amp;di=90b4757f68c9480f78c132c930c1df10&amp;src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h4><p>对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filter some no use or unneed requestions or data</span></span><br><span class=\"line\"><span class=\"comment\">// A  ---&gt; B(proxy) ----&gt; C</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  send (target, info) &#123;</span><br><span class=\"line\">    target.receive(info)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  receive (target, info) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c receive '</span>, info, <span class=\"string\">' from '</span>, target.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  receive (info) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (info) &#123;</span><br><span class=\"line\">      c.receive(<span class=\"keyword\">this</span>, info)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.send(b, <span class=\"string\">'good morning'</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">''</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">'send again'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// c receive good morning from b</span></span><br><span class=\"line\"><span class=\"comment\">// c receive send again from b</span></span><br></pre></td></tr></table></figure></p>\n<p>上面表示一个最简单的保护代理</p>\n<h4 id=\"缓存代理\"><a href=\"#缓存代理\" class=\"headerlink\" title=\"缓存代理\"></a>缓存代理</h4><p>顾名思义就是缓存相关的代理</p>\n<p>有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储所有标签</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sendApiGetTags = <span class=\"function\"><span class=\"params\">index</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ajax.get('/api', &#123; index &#125;)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyCache = <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">async</span> (</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allTagsCache = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> number = <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> all = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index = <span class=\"number\">0</span>; index &lt; number; index++) &#123;</span><br><span class=\"line\">    all.push(sendApiGetTags(&#123;</span><br><span class=\"line\">      ...params,</span><br><span class=\"line\">      index</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> list = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(all)</span><br><span class=\"line\"></span><br><span class=\"line\">  list.forEach(<span class=\"function\">(<span class=\"params\">res, i</span>) =&gt;</span> allTagsCache[i] = res)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> allTagsCache</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> setTags = <span class=\"keyword\">async</span> index =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中有直接拿</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (proxyCache[index]) &#123;</span><br><span class=\"line\">    tags = proxyCache[index]</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中没有则重发请求</span></span><br><span class=\"line\">    tags = <span class=\"keyword\">await</span> sendApiGetTags(index)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h1><h3 id=\"定义：-3\"><a href=\"#定义：-3\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。<br>至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法</p>\n<h3 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>订阅者可以根据自己需求当某种Action被触发时完成自己的调度</p>\n<h3 id=\"应用场景：-3\"><a href=\"#应用场景：-3\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>AngularJs的广播、vue的eventbus等</p>\n<h4 id=\"根据主体构建发布订阅的基类\"><a href=\"#根据主体构建发布订阅的基类\" class=\"headerlink\" title=\"根据主体构建发布订阅的基类\"></a>根据主体构建发布订阅的基类</h4><p>构造发布者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Publisher</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 订阅发布者的队列 存储每个订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  deliver (data) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布消息 调用订阅者的回调 告知订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn.shot(data))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造订阅者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (call) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入订阅回调</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.shot = call</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  subscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!publisher.subscribers.some(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot === <span class=\"keyword\">this</span>.shot)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'订阅该消息'</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 判断当前订阅者是否订阅</span></span><br><span class=\"line\">      publisher.subscribers.push(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  unsubscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 移除当前订阅者</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'取消订阅'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    publisher.subscribers = publisher.subscribers.filter(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot !== <span class=\"keyword\">this</span>.shot)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pub = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> pub2 = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> obs = <span class=\"keyword\">new</span> Observer(<span class=\"function\"><span class=\"params\">deliver</span> =&gt;</span> <span class=\"built_in\">console</span>.log(deliver))</span><br><span class=\"line\"></span><br><span class=\"line\">obs.subscribe(pub) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\">obs.subscribe(pub2) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\"></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver first message'</span>) <span class=\"comment\">// pub deliver first message</span></span><br><span class=\"line\">pub2.deliver(<span class=\"string\">'pub2 deliver first message'</span>) <span class=\"comment\">// pub2 deliver first message</span></span><br><span class=\"line\"></span><br><span class=\"line\">obs.unsubscribe(pub) <span class=\"comment\">// 取消订阅</span></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver second message'</span>) <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><h3 id=\"定义：-4\"><a href=\"#定义：-4\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能</p>\n<h3 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展</li>\n</ul>\n<h3 id=\"应用场景：-4\"><a href=\"#应用场景：-4\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>需要扩展一个类的功能，或给一个类添加附加职责</li>\n<li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销</li>\n<li>不必改动原本的逻辑造成不可知问题</li>\n</ul>\n<h4 id=\"给所有的函数调用添加调用前和调用后的钩子\"><a href=\"#给所有的函数调用添加调用前和调用后的钩子\" class=\"headerlink\" title=\"给所有的函数调用添加调用前和调用后的钩子\"></a>给所有的函数调用添加调用前和调用后的钩子</h4><p>普通函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"string\">'let go'</span>) <span class=\"comment\">// lets go right now</span></span><br></pre></td></tr></table></figure></p>\n<p>我们知道JS中所有的函数都是基于父类 <code>Function</code> 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行前</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.before = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 返回体本身也是函数所以支持继续调用钩子</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用钩子，同时参数传递到钩子内</span></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 调用自身</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 执行后</span></span><br><span class=\"line\"><span class=\"comment\">// 和 before 同理</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.after = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回自身的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重新包装 fn</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decoratorFn = fn.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'when we go,'</span>, msg)</span><br><span class=\"line\">&#125;).after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'had to go'</span>, msg)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">decoratorFn(<span class=\"string\">'lets go'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// out put:</span></span><br><span class=\"line\"><span class=\"comment\">// when we go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// lets go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// had to go, right now</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"职责链（责任链）模式\"><a href=\"#职责链（责任链）模式\" class=\"headerlink\" title=\"职责链（责任链）模式\"></a>职责链（责任链）模式</h1><h3 id=\"定义：-5\"><a href=\"#定义：-5\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求</p>\n<h3 id=\"优点：-4\"><a href=\"#优点：-4\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了</p>\n<h3 id=\"应用场景：-5\"><a href=\"#应用场景：-5\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>JS 中的事件冒泡（事件委托）就是经典案例</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购<br>下面分别抽象处理者构造基类</p>\n<p>责任链调度中心：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setNext(_handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = _handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleRequest(money) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采购部经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CGBHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'1w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理1w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZJLHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 10w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理10w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>董事长：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DSZHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 100w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &gt;= <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10万以上的我来处理'</span>)</span><br><span class=\"line\">      <span class=\"comment\">//处理其他逻辑</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>封装客户端接口：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dispatch = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">client</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cgb = <span class=\"keyword\">new</span> CGBHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> zjl = <span class=\"keyword\">new</span> ZJLHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dsz = <span class=\"keyword\">new</span> DSZHandler()</span><br><span class=\"line\"></span><br><span class=\"line\">  cgb.setNext(zjl)</span><br><span class=\"line\">  zjl.setNext(dsz)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cgb.handleRequest.bind(cgb)</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">800000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理1w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理10w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 10万以上的我来处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">7000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 1w以内，同意</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：</p>\n<ul>\n<li><p>纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理</p>\n</li>\n<li><p>不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理</p>\n</li>\n</ul>\n<p>.<br>.<br>.<br>.<br>.<br>.<br>未完待续…👏</p>\n","site":{"data":{}},"excerpt":"<p>持续更新<br>JS常用的设计模式以及应用场景<br></p>","more":"<br><em>以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝</em><p></p>\n<h1 id=\"何谓设计模式\"><a href=\"#何谓设计模式\" class=\"headerlink\" title=\"何谓设计模式\"></a>何谓设计模式</h1><p>没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多</p>\n<p>抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位</p>\n<p>定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案</p>\n<p>补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题</p>\n<p>软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍</p>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><p>在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：</p>\n<ul>\n<li><p>单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度</p>\n</li>\n<li><p>最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理</p>\n</li>\n<li><p>开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定</p>\n</li>\n</ul>\n<h1 id=\"从最简单的单体-单例模式开始\"><a href=\"#从最简单的单体-单例模式开始\" class=\"headerlink\" title=\"从最简单的单体/单例模式开始\"></a>从最简单的单体/单例模式开始</h1><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象</p>\n<p>单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例<br><em>在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供</em></p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例</li>\n<li>因为类控制了实例化过程，所以类可以灵活更改实例化过程</li>\n<li>单体可以控制局部变量污染</li>\n</ul>\n<h3 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存</li>\n<li>借助单例模式，可以把代码组织的更为一致</li>\n</ul>\n<h4 id=\"最基本的单体模式\"><a href=\"#最基本的单体模式\" class=\"headerlink\" title=\"最基本的单体模式\"></a>最基本的单体模式</h4><p>直接导出一个方法属性集合的对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// commonjs 导出</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  getSingleton() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"用闭包来实现单例\"><a href=\"#用闭包来实现单例\" class=\"headerlink\" title=\"用闭包来实现单例\"></a>用闭包来实现单例</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Ins1 = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> instance = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"comment\">// 利用闭包特性保证实例私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opt</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> opt) &#123;</span><br><span class=\"line\">      instance[k] = opt[k]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> i1 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i1'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> i2 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i2'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1 === i2) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1.name) <span class=\"comment\">// i2</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： <code>class T {} export default new T</code> 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化</p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><h3 id=\"定义：-1\"><a href=\"#定义：-1\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>减少<code>command c &amp; command v</code>, 提高复用性</li>\n<li>遵循开闭原则，算法独立易于切换、理解、拓展</li>\n</ul>\n<h3 id=\"应用场景：-1\"><a href=\"#应用场景：-1\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试</p>\n<h4 id=\"最简单的执行\"><a href=\"#最简单的执行\" class=\"headerlink\" title=\"最简单的执行\"></a>最简单的执行</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> strategies = &#123;</span><br><span class=\"line\">      plus10: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">10</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      plus100: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">100</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plus, base</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strategies[plus](base);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> strategy = closure()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus10'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus100'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 101</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对比分析\"><a href=\"#对比分析\" class=\"headerlink\" title=\"对比分析\"></a>对比分析</h4><p>eg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额</p>\n<p>意大利逻辑:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">context</span> (<span class=\"params\">name, type, price</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vip</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Old</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Others</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setPrice (name, strategy, price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name, <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price), <span class=\"string\">'元'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Vip</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Old</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Others</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本</p>\n<p>补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义父类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(discount) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不传为原价</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = discount || <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice(price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount === <span class=\"number\">1</span></span><br><span class=\"line\">      ? price</span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以自定义更多不同级别顾客不同需求</span></span><br><span class=\"line\"><span class=\"comment\">// class Test extend Handler &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   getGifts() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     if (this.discount &lt; 1) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       // 赠送赠品</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// const master = new Test(0.1)</span></span><br><span class=\"line\"><span class=\"comment\">// master.getGifts()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Context类同上方便统一接口输出</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.5</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.8</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Sub</span><br><span class=\"line\"></span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>测试结果一致</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"定义：-2\"><a href=\"#定义：-2\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用<br>著名的代理模式例子为引用计数（reference counting）指针对象<br>另外代理模式还可分为：</p>\n<ul>\n<li>虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象</li>\n<li>保护代理：用于控制不同权限的对象对目标对象的访问</li>\n<li>缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</li>\n</ul>\n<h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>独立职责归属，便于维护测试</p>\n<h3 id=\"应用场景：-2\"><a href=\"#应用场景：-2\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>比如图片的懒加载，数据缓存等</p>\n<h4 id=\"虚拟代理实现图片懒加载\"><a href=\"#虚拟代理实现图片懒加载\" class=\"headerlink\" title=\"虚拟代理实现图片懒加载\"></a>虚拟代理实现图片懒加载</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> imgSet = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.append(node)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    node.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxyImg = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _img = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\"></span><br><span class=\"line\">  _img.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(imgSet, <span class=\"number\">2000</span>, <span class=\"keyword\">this</span>.src)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    imgSet(<span class=\"string\">'https://yphoto.eryufm.cn/upload/assets/jump.gif'</span>)</span><br><span class=\"line\">    _img.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">// call</span></span><br><span class=\"line\">proxyImg(<span class=\"string\">`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1551174639&amp;di=90b4757f68c9480f78c132c930c1df10&amp;src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h4><p>对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filter some no use or unneed requestions or data</span></span><br><span class=\"line\"><span class=\"comment\">// A  ---&gt; B(proxy) ----&gt; C</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  send (target, info) &#123;</span><br><span class=\"line\">    target.receive(info)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  receive (target, info) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c receive '</span>, info, <span class=\"string\">' from '</span>, target.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  receive (info) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (info) &#123;</span><br><span class=\"line\">      c.receive(<span class=\"keyword\">this</span>, info)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.send(b, <span class=\"string\">'good morning'</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">''</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">'send again'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// c receive good morning from b</span></span><br><span class=\"line\"><span class=\"comment\">// c receive send again from b</span></span><br></pre></td></tr></table></figure></p>\n<p>上面表示一个最简单的保护代理</p>\n<h4 id=\"缓存代理\"><a href=\"#缓存代理\" class=\"headerlink\" title=\"缓存代理\"></a>缓存代理</h4><p>顾名思义就是缓存相关的代理</p>\n<p>有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储所有标签</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sendApiGetTags = <span class=\"function\"><span class=\"params\">index</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ajax.get('/api', &#123; index &#125;)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyCache = <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">async</span> (</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allTagsCache = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> number = <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> all = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index = <span class=\"number\">0</span>; index &lt; number; index++) &#123;</span><br><span class=\"line\">    all.push(sendApiGetTags(&#123;</span><br><span class=\"line\">      ...params,</span><br><span class=\"line\">      index</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> list = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(all)</span><br><span class=\"line\"></span><br><span class=\"line\">  list.forEach(<span class=\"function\">(<span class=\"params\">res, i</span>) =&gt;</span> allTagsCache[i] = res)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> allTagsCache</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> setTags = <span class=\"keyword\">async</span> index =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中有直接拿</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (proxyCache[index]) &#123;</span><br><span class=\"line\">    tags = proxyCache[index]</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中没有则重发请求</span></span><br><span class=\"line\">    tags = <span class=\"keyword\">await</span> sendApiGetTags(index)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h1><h3 id=\"定义：-3\"><a href=\"#定义：-3\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。<br>至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法</p>\n<h3 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>订阅者可以根据自己需求当某种Action被触发时完成自己的调度</p>\n<h3 id=\"应用场景：-3\"><a href=\"#应用场景：-3\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>AngularJs的广播、vue的eventbus等</p>\n<h4 id=\"根据主体构建发布订阅的基类\"><a href=\"#根据主体构建发布订阅的基类\" class=\"headerlink\" title=\"根据主体构建发布订阅的基类\"></a>根据主体构建发布订阅的基类</h4><p>构造发布者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Publisher</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 订阅发布者的队列 存储每个订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  deliver (data) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布消息 调用订阅者的回调 告知订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn.shot(data))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造订阅者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (call) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入订阅回调</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.shot = call</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  subscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!publisher.subscribers.some(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot === <span class=\"keyword\">this</span>.shot)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'订阅该消息'</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 判断当前订阅者是否订阅</span></span><br><span class=\"line\">      publisher.subscribers.push(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  unsubscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 移除当前订阅者</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'取消订阅'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    publisher.subscribers = publisher.subscribers.filter(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot !== <span class=\"keyword\">this</span>.shot)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pub = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> pub2 = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> obs = <span class=\"keyword\">new</span> Observer(<span class=\"function\"><span class=\"params\">deliver</span> =&gt;</span> <span class=\"built_in\">console</span>.log(deliver))</span><br><span class=\"line\"></span><br><span class=\"line\">obs.subscribe(pub) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\">obs.subscribe(pub2) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\"></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver first message'</span>) <span class=\"comment\">// pub deliver first message</span></span><br><span class=\"line\">pub2.deliver(<span class=\"string\">'pub2 deliver first message'</span>) <span class=\"comment\">// pub2 deliver first message</span></span><br><span class=\"line\"></span><br><span class=\"line\">obs.unsubscribe(pub) <span class=\"comment\">// 取消订阅</span></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver second message'</span>) <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><h3 id=\"定义：-4\"><a href=\"#定义：-4\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能</p>\n<h3 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展</li>\n</ul>\n<h3 id=\"应用场景：-4\"><a href=\"#应用场景：-4\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>需要扩展一个类的功能，或给一个类添加附加职责</li>\n<li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销</li>\n<li>不必改动原本的逻辑造成不可知问题</li>\n</ul>\n<h4 id=\"给所有的函数调用添加调用前和调用后的钩子\"><a href=\"#给所有的函数调用添加调用前和调用后的钩子\" class=\"headerlink\" title=\"给所有的函数调用添加调用前和调用后的钩子\"></a>给所有的函数调用添加调用前和调用后的钩子</h4><p>普通函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"string\">'let go'</span>) <span class=\"comment\">// lets go right now</span></span><br></pre></td></tr></table></figure></p>\n<p>我们知道JS中所有的函数都是基于父类 <code>Function</code> 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行前</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.before = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 返回体本身也是函数所以支持继续调用钩子</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用钩子，同时参数传递到钩子内</span></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 调用自身</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 执行后</span></span><br><span class=\"line\"><span class=\"comment\">// 和 before 同理</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.after = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回自身的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重新包装 fn</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decoratorFn = fn.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'when we go,'</span>, msg)</span><br><span class=\"line\">&#125;).after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'had to go'</span>, msg)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">decoratorFn(<span class=\"string\">'lets go'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// out put:</span></span><br><span class=\"line\"><span class=\"comment\">// when we go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// lets go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// had to go, right now</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"职责链（责任链）模式\"><a href=\"#职责链（责任链）模式\" class=\"headerlink\" title=\"职责链（责任链）模式\"></a>职责链（责任链）模式</h1><h3 id=\"定义：-5\"><a href=\"#定义：-5\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求</p>\n<h3 id=\"优点：-4\"><a href=\"#优点：-4\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了</p>\n<h3 id=\"应用场景：-5\"><a href=\"#应用场景：-5\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>JS 中的事件冒泡（事件委托）就是经典案例</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购<br>下面分别抽象处理者构造基类</p>\n<p>责任链调度中心：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setNext(_handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = _handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleRequest(money) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采购部经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CGBHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'1w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理1w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZJLHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 10w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理10w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>董事长：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DSZHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 100w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &gt;= <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10万以上的我来处理'</span>)</span><br><span class=\"line\">      <span class=\"comment\">//处理其他逻辑</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>封装客户端接口：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dispatch = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">client</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cgb = <span class=\"keyword\">new</span> CGBHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> zjl = <span class=\"keyword\">new</span> ZJLHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dsz = <span class=\"keyword\">new</span> DSZHandler()</span><br><span class=\"line\"></span><br><span class=\"line\">  cgb.setNext(zjl)</span><br><span class=\"line\">  zjl.setNext(dsz)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cgb.handleRequest.bind(cgb)</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">800000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理1w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理10w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 10万以上的我来处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">7000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 1w以内，同意</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：</p>\n<ul>\n<li><p>纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理</p>\n</li>\n<li><p>不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理</p>\n</li>\n</ul>\n<p>.<br>.<br>.<br>.<br>.<br>.<br>未完待续…👏</p>"}],"PostAsset":[{"_id":"source/_posts/writeSomething/koa2OnionModel/onion.png","slug":"onion.png","post":"ck03jyxx1001qax48uz0fitg5","modified":1,"renderable":0},{"_id":"source/_posts/about/HowAnEconomyGrowsAndWhyItCrashes/economy_1.png","slug":"economy_1.png","post":"ck03jyxw30003ax48k36c4omv","modified":1,"renderable":0},{"_id":"source/_posts/writeSomething/http_tcp/http2.jpg","post":"ck03jyxx0001max48h70lfvci","slug":"http2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/writeSomething/http_tcp/ssl_1.jpg","post":"ck03jyxx0001max48h70lfvci","slug":"ssl_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/writeSomething/http_tcp/ssl_2.jpg","post":"ck03jyxx0001max48h70lfvci","slug":"ssl_2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/writeSomething/PayAttentionToThoseJs/virturedom.png","post":"ck03jyxy1003eax48zwgnh4dc","slug":"virturedom.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck03jyxw30003ax48k36c4omv","category_id":"ck03jyxw70005ax4884t5lz1v","_id":"ck03jyxwh000fax48z2mbtyjm"},{"post_id":"ck03jyxwe000dax48wzt0ifte","category_id":"ck03jyxwd000aax48d0nhhe6r","_id":"ck03jyxwl000max482gkv38ho"},{"post_id":"ck03jyxw60004ax48rta5s0hi","category_id":"ck03jyxwd000aax48d0nhhe6r","_id":"ck03jyxwn000rax48jb17ck6h"},{"post_id":"ck03jyxwg000eax48t8k4iwln","category_id":"ck03jyxwd000aax48d0nhhe6r","_id":"ck03jyxwo000uax486nzkg0an"},{"post_id":"ck03jyxw90007ax484ka53e7d","category_id":"ck03jyxwd000aax48d0nhhe6r","_id":"ck03jyxwp000zax48gd9qr52f"},{"post_id":"ck03jyxwm000qax48yt9ah98u","category_id":"ck03jyxwd000aax48d0nhhe6r","_id":"ck03jyxwr0012ax48ydwt22i9"},{"post_id":"ck03jyxwb0008ax48sqphnnww","category_id":"ck03jyxwd000aax48d0nhhe6r","_id":"ck03jyxwt0016ax48hma0nsht"},{"post_id":"ck03jyxwc0009ax48wrv0rdtf","category_id":"ck03jyxwd000aax48d0nhhe6r","_id":"ck03jyxwv0019ax48mcaztu12"},{"post_id":"ck03jyxwj000jax48jiuxypcc","category_id":"ck03jyxws0013ax48wqbqt245","_id":"ck03jyxwy001fax48guu11qra"},{"post_id":"ck03jyxwk000lax48huu85tsk","category_id":"ck03jyxwv001aax484jhdmwr0","_id":"ck03jyxx0001lax48jg3hv50f"},{"post_id":"ck03jyxwn000tax48sq1okg0c","category_id":"ck03jyxwy001gax48a4ej8uja","_id":"ck03jyxx2001rax48ibv7jyzj"},{"post_id":"ck03jyxwp000yax481xvxfmqs","category_id":"ck03jyxx0001nax487hfxwavp","_id":"ck03jyxx3001uax48odlb62nh"},{"post_id":"ck03jyxwq0011ax48gv9566o9","category_id":"ck03jyxx2001sax48b716nwze","_id":"ck03jyxx40020ax48kxrdsik0"},{"post_id":"ck03jyxws0015ax481ou2sejy","category_id":"ck03jyxx0001nax487hfxwavp","_id":"ck03jyxx40022ax480eojmoli"},{"post_id":"ck03jyxwu0018ax48z28kai0t","category_id":"ck03jyxx4001zax488b628kz1","_id":"ck03jyxx80027ax488nm9ikyt"},{"post_id":"ck03jyxwv001cax48vsrygfwf","category_id":"ck03jyxx2001sax48b716nwze","_id":"ck03jyxxc002aax481hlqf2a1"},{"post_id":"ck03jyxww001eax48ulkvm0wk","category_id":"ck03jyxx80026ax489fr68s3p","_id":"ck03jyxxf002eax48ql5o9qgc"},{"post_id":"ck03jyxwy001iax488jfqiki6","category_id":"ck03jyxxc002bax482md115wv","_id":"ck03jyxxg002kax48gqduvqnv"},{"post_id":"ck03jyxwz001kax48yk5yyuyd","category_id":"ck03jyxx0001nax487hfxwavp","_id":"ck03jyxxh002max48u1y57ead"},{"post_id":"ck03jyxx0001max48h70lfvci","category_id":"ck03jyxxg002jax48j2gm6vfy","_id":"ck03jyxxi002qax481gnpxrkx"},{"post_id":"ck03jyxx1001qax48uz0fitg5","category_id":"ck03jyxx2001sax48b716nwze","_id":"ck03jyxxj002uax48w6vrdawg"},{"post_id":"ck03jyxxz003bax48srd4qt4d","category_id":"ck03jyxx2001sax48b716nwze","_id":"ck03jyxy5003iax48r18pkxlf"},{"post_id":"ck03jyxy2003gax48vkjilh7a","category_id":"ck03jyxx2001sax48b716nwze","_id":"ck03jyxy7003lax482gmkex4s"},{"post_id":"ck03jyxxx003aax48uv8a1jv1","category_id":"ck03jyxy1003cax48y9xpwuoe","_id":"ck03jyxya003nax480534gx5x"},{"post_id":"ck03jyxy4003hax4858fjy1gw","category_id":"ck03jyxy1003cax48y9xpwuoe","_id":"ck03jyxyb003pax48synxi0bu"},{"post_id":"ck03jyxy1003eax48zwgnh4dc","category_id":"ck03jyxy1003cax48y9xpwuoe","_id":"ck03jyxyb003sax48c586wkfa"},{"post_id":"ck03jyxyn0041ax48y34elqr7","category_id":"ck03jyxx0001nax487hfxwavp","_id":"ck03jyxyt0043ax488gfsosk8"}],"PostTag":[{"post_id":"ck03jyxw30003ax48k36c4omv","tag_id":"ck03jyxw90006ax48r164li1v","_id":"ck03jyxwe000cax48nt0vsfzk"},{"post_id":"ck03jyxwe000dax48wzt0ifte","tag_id":"ck03jyxwe000bax48scyjosu6","_id":"ck03jyxwj000iax48j6ysetea"},{"post_id":"ck03jyxw60004ax48rta5s0hi","tag_id":"ck03jyxwe000bax48scyjosu6","_id":"ck03jyxwk000kax48r6eahcxi"},{"post_id":"ck03jyxwg000eax48t8k4iwln","tag_id":"ck03jyxwe000bax48scyjosu6","_id":"ck03jyxwm000pax48fg8cm58w"},{"post_id":"ck03jyxw90007ax484ka53e7d","tag_id":"ck03jyxwe000bax48scyjosu6","_id":"ck03jyxwn000sax48toffxcc6"},{"post_id":"ck03jyxwm000qax48yt9ah98u","tag_id":"ck03jyxwe000bax48scyjosu6","_id":"ck03jyxwp000xax4872pbsacu"},{"post_id":"ck03jyxwb0008ax48sqphnnww","tag_id":"ck03jyxwe000bax48scyjosu6","_id":"ck03jyxwq0010ax487hrvl7ds"},{"post_id":"ck03jyxwc0009ax48wrv0rdtf","tag_id":"ck03jyxwe000bax48scyjosu6","_id":"ck03jyxwt0017ax48ftqewnbd"},{"post_id":"ck03jyxwj000jax48jiuxypcc","tag_id":"ck03jyxws0014ax481ruykzo9","_id":"ck03jyxww001dax48qln8ah8l"},{"post_id":"ck03jyxwk000lax48huu85tsk","tag_id":"ck03jyxwv001bax48i78gojxl","_id":"ck03jyxwz001jax484tq728tk"},{"post_id":"ck03jyxwn000tax48sq1okg0c","tag_id":"ck03jyxwy001hax48cdtzll5d","_id":"ck03jyxx1001pax48qxgw0mz2"},{"post_id":"ck03jyxwp000yax481xvxfmqs","tag_id":"ck03jyxx1001oax48f6z15xlt","_id":"ck03jyxx4001xax4843v060k3"},{"post_id":"ck03jyxwp000yax481xvxfmqs","tag_id":"ck03jyxx3001tax48b2irosbc","_id":"ck03jyxx4001yax48vr553sp9"},{"post_id":"ck03jyxwq0011ax48gv9566o9","tag_id":"ck03jyxx3001wax48g0ako7yg","_id":"ck03jyxx70025ax48pb2zwv0i"},{"post_id":"ck03jyxwq0011ax48gv9566o9","tag_id":"ck03jyxx40021ax48ftf81no6","_id":"ck03jyxx90028ax48rkypd8xq"},{"post_id":"ck03jyxws0015ax481ou2sejy","tag_id":"ck03jyxx60024ax4825wht7kr","_id":"ck03jyxxf002dax48981av89m"},{"post_id":"ck03jyxws0015ax481ou2sejy","tag_id":"ck03jyxx90029ax48q1ifk5ty","_id":"ck03jyxxf002gax487uobtyg5"},{"post_id":"ck03jyxwu0018ax48z28kai0t","tag_id":"ck03jyxxd002cax48gytyl3dr","_id":"ck03jyxxg002iax48hzyuuhs4"},{"post_id":"ck03jyxwv001cax48vsrygfwf","tag_id":"ck03jyxx3001wax48g0ako7yg","_id":"ck03jyxxi002pax48dfwh1s1t"},{"post_id":"ck03jyxwv001cax48vsrygfwf","tag_id":"ck03jyxxg002lax482rmiyxbw","_id":"ck03jyxxi002rax48b9kf9xvx"},{"post_id":"ck03jyxww001eax48ulkvm0wk","tag_id":"ck03jyxxh002oax48ckp4k3nu","_id":"ck03jyxxj002tax48yev8pm97"},{"post_id":"ck03jyxwy001iax488jfqiki6","tag_id":"ck03jyxxi002sax489t2ty019","_id":"ck03jyxxj002wax48xzvykx9h"},{"post_id":"ck03jyxwz001kax48yk5yyuyd","tag_id":"ck03jyxx1001oax48f6z15xlt","_id":"ck03jyxxk0030ax48h8ah8cnt"},{"post_id":"ck03jyxwz001kax48yk5yyuyd","tag_id":"ck03jyxxj002xax48zkida0xz","_id":"ck03jyxxk0031ax48g4qr8qgw"},{"post_id":"ck03jyxwz001kax48yk5yyuyd","tag_id":"ck03jyxxk002yax48ytbs3m9w","_id":"ck03jyxxk0033ax48iohtv2qe"},{"post_id":"ck03jyxx0001max48h70lfvci","tag_id":"ck03jyxxk002zax48nornxfmd","_id":"ck03jyxxl0034ax48dg7nm9rh"},{"post_id":"ck03jyxx1001qax48uz0fitg5","tag_id":"ck03jyxxk0032ax48g54efa5x","_id":"ck03jyxxl0037ax48dwlxymzt"},{"post_id":"ck03jyxx1001qax48uz0fitg5","tag_id":"ck03jyxxl0035ax48uwurhsfv","_id":"ck03jyxxl0038ax48ih2yp7ml"},{"post_id":"ck03jyxx1001qax48uz0fitg5","tag_id":"ck03jyxxl0036ax488pg8v6q2","_id":"ck03jyxxm0039ax48saibi1a1"},{"post_id":"ck03jyxxz003bax48srd4qt4d","tag_id":"ck03jyxx3001wax48g0ako7yg","_id":"ck03jyxy2003fax4852stx1t7"},{"post_id":"ck03jyxxx003aax48uv8a1jv1","tag_id":"ck03jyxy1003dax48zcwnxbq0","_id":"ck03jyxya003oax481jaz6vdz"},{"post_id":"ck03jyxxx003aax48uv8a1jv1","tag_id":"ck03jyxy5003kax48gpy7fp7j","_id":"ck03jyxyb003qax48ibleu0p7"},{"post_id":"ck03jyxy1003eax48zwgnh4dc","tag_id":"ck03jyxy7003max48s9lnmq2q","_id":"ck03jyxyb003tax48d2qvabp6"},{"post_id":"ck03jyxy2003gax48vkjilh7a","tag_id":"ck03jyxyb003rax48h427plbk","_id":"ck03jyxyj003xax48d4s8ljlc"},{"post_id":"ck03jyxy2003gax48vkjilh7a","tag_id":"ck03jyxyb003uax48yg7vhd2v","_id":"ck03jyxyk003yax488d3pd2t9"},{"post_id":"ck03jyxy2003gax48vkjilh7a","tag_id":"ck03jyxyc003vax48jvfajrtb","_id":"ck03jyxyk003zax48ndfxkvn0"},{"post_id":"ck03jyxy4003hax4858fjy1gw","tag_id":"ck03jyxyj003wax48dyd54fwd","_id":"ck03jyxyk0040ax48sop8tc8f"},{"post_id":"ck03jyxyn0041ax48y34elqr7","tag_id":"ck03jyxyo0042ax48lc41flcq","_id":"ck03jyxyu0044ax48olqm1jwg"},{"post_id":"ck03jyxyn0041ax48y34elqr7","tag_id":"ck03jyxx1001oax48f6z15xlt","_id":"ck03jyxyu0045ax48am5q6n0q"}],"Tag":[{"name":"经济学","_id":"ck03jyxw90006ax48r164li1v"},{"name":"当我在扯淡","_id":"ck03jyxwe000bax48scyjosu6"},{"name":"思维","_id":"ck03jyxws0014ax481ruykzo9"},{"name":"to do list","_id":"ck03jyxwv001bax48i78gojxl"},{"name":"ajax","_id":"ck03jyxwy001hax48cdtzll5d"},{"name":"算法","_id":"ck03jyxx1001oax48f6z15xlt"},{"name":"算法复杂度","_id":"ck03jyxx3001tax48b2irosbc"},{"name":"fetch","_id":"ck03jyxx3001wax48g0ako7yg"},{"name":"interceptor","_id":"ck03jyxx40021ax48ftf81no6"},{"name":"函数式编程","_id":"ck03jyxx60024ax4825wht7kr"},{"name":"event emitter","_id":"ck03jyxx90029ax48q1ifk5ty"},{"name":"webpack","_id":"ck03jyxxd002cax48gytyl3dr"},{"name":"concurrency","_id":"ck03jyxxg002lax482rmiyxbw"},{"name":"技术分享","_id":"ck03jyxxh002oax48ckp4k3nu"},{"name":"开发环境搭建","_id":"ck03jyxxi002sax489t2ty019"},{"name":"动态规划","_id":"ck03jyxxj002xax48zkida0xz"},{"name":"递归","_id":"ck03jyxxk002yax48ytbs3m9w"},{"name":"tcp","_id":"ck03jyxxk002zax48nornxfmd"},{"name":"封装","_id":"ck03jyxxk0032ax48g54efa5x"},{"name":"koa","_id":"ck03jyxxl0035ax48uwurhsfv"},{"name":"洋葱模型","_id":"ck03jyxxl0036ax488pg8v6q2"},{"name":"事件循环","_id":"ck03jyxy1003dax48zcwnxbq0"},{"name":"任务队列","_id":"ck03jyxy5003kax48gpy7fp7j"},{"name":"你应该知道的","_id":"ck03jyxy7003max48s9lnmq2q"},{"name":"微信小程序","_id":"ck03jyxyb003rax48h427plbk"},{"name":"mpvue","_id":"ck03jyxyb003uax48yg7vhd2v"},{"name":"路由","_id":"ck03jyxyc003vax48jvfajrtb"},{"name":"interview","_id":"ck03jyxyj003wax48dyd54fwd"},{"name":"设计模式","_id":"ck03jyxyo0042ax48lc41flcq"}]}}