{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/archer/source/CNAME","path":"CNAME","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/logo-36.png","path":"assets/logo-36.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/logo-48.png","path":"assets/logo-48.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/logo-64.png","path":"assets/logo-64.png","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/images/wechat.jpg","path":"images/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/images/avatar1.png","path":"images/avatar1.png","modified":0,"renderable":1},{"_id":"themes/archer/source/images/site.JPG","path":"images/site.JPG","modified":0,"renderable":1},{"_id":"themes/archer/source/images/post.JPG","path":"images/post.JPG","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550808959469},{"_id":"source/404.md","hash":"17657585e818d245e2000306cb66d0ce8dedb022","modified":1550904528938},{"_id":"source/.DS_Store","hash":"7a8f97280a3f1166befbf8e8d2d3f50d4a962af4","modified":1551000245177},{"_id":"source/manifest.json","hash":"f0344d8a9b213aa7b54f893f77e82e393cadfc4e","modified":1550904528947},{"_id":"themes/archer/LICENSE","hash":"35f4fb806270f8243459c870a2141e795dfab166","modified":1550904528949},{"_id":"themes/archer/.DS_Store","hash":"4e15ba49a799d94b130c2b5413f1289de3d41ca6","modified":1550812864070},{"_id":"themes/archer/README.md","hash":"8e41e0533361cba876297ee6a8fecdc514f21862","modified":1550904528951},{"_id":"themes/archer/_config.yml","hash":"d42d66b40f1a83609c25f5810be5fdc7c264a43f","modified":1553244373615},{"_id":"themes/archer/gulpfile.js","hash":"4425599995b6c818274f4a27067f484eaf357d05","modified":1550904528963},{"_id":"themes/archer/package.json","hash":"cec814615d1c62afaa7e9ecc8265f20ae313b434","modified":1550904529019},{"_id":"themes/archer/webpack.config.js","hash":"348da2932316c2789a3c0a3cf5efff0dd7cc4ffe","modified":1550904529109},{"_id":"themes/archer/webpack.prod.js","hash":"b6d35f7e9a9718b3e5e3e17c52fcc5e7c38330b0","modified":1550904529110},{"_id":"themes/archer/source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550809083470},{"_id":"source/_posts/.DS_Store","hash":"30c1819b0677463110854153e8ebd10f3a6a03ff","modified":1552281310332},{"_id":"source/about/index.md","hash":"1367635f4cbdaaec780654f5074bf32af0b15a05","modified":1550904528941},{"_id":"themes/archer/docs/README-en.md","hash":"67f8059a939fbe83db5d02b0b237353140077617","modified":1550904528955},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c10293eb8ccad5d02412a1369ec1c7e77516b929","modified":1550904528957},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"522434202e5e810b3c7f9591eb3a4451a4e485f0","modified":1550904528959},{"_id":"themes/archer/layout/404.ejs","hash":"a054b4ea1147846bed4252dd56182cb8e32d95eb","modified":1550904528965},{"_id":"themes/archer/layout/about.ejs","hash":"990df15653a99453617e72dfc195fa0a75b9a5d1","modified":1550904529008},{"_id":"themes/archer/layout/index.ejs","hash":"c9ae77cd8f7b862d23137a7b4eb5eb01b558ed33","modified":1550904529010},{"_id":"themes/archer/layout/layout.ejs","hash":"a55e3cf35d6156e638e4cb2318c9a759125e88c9","modified":1552544768026},{"_id":"themes/archer/layout/post.ejs","hash":"52da8cdba970c9a0d7b69652ad365d8853379a84","modified":1551977217009},{"_id":"themes/archer/layout/site-meta.ejs","hash":"d727c9e0cee2767b4596f9805622809a2ebb344b","modified":1550904529014},{"_id":"themes/archer/source/.DS_Store","hash":"bbef7070c1f1b3c72d8eba78dd8fa12181268346","modified":1552734206041},{"_id":"source/_posts/humanbeings/IsThisInternetWinter.md","hash":"6643a4c0cdc85278d43c8fe3b574772c6ec43a40","modified":1552544768012},{"_id":"source/_posts/humanbeings/alive.md","hash":"8d09f74f663809d5735b4ccbf39cf388bb524f70","modified":1553244373611},{"_id":"source/_posts/humanbeings/人生天地间 忽如远行客.md","hash":"a25db20662a7ff9c6913dafb82b335c181ab360e","modified":1551874692292},{"_id":"source/_posts/writeSomething/AlgorithmComplexity.md","hash":"e925133af5bca084018880f3609120f3473bb53e","modified":1551874692292},{"_id":"source/_posts/writeSomething/EventLoop.md","hash":"a6ae5beba89d718f443e790fb2ebbdb8a65c0bcc","modified":1551977217005},{"_id":"source/_posts/writeSomething/PayAttentionToThoseJs.md","hash":"5d2fcc215f199cbbf07e7615497407aa735338a3","modified":1552544768013},{"_id":"source/_posts/writeSomething/appletRouter.md","hash":"7ae182a7ae258b3774bb7fe7404a0b3455252a6c","modified":1552544768018},{"_id":"source/_posts/writeSomething/dynamicProgrammingAndRecursion.md","hash":"8b64859b5b0c85acdabe70b277bb454f47ccb602","modified":1552544768020},{"_id":"source/_posts/writeSomething/interestingCode.md","hash":"58bfc2a72d3905523f30db4205417de49d907a29","modified":1553244373614},{"_id":"source/_posts/writeSomething/jsDesignPattern.md","hash":"c6f8b232dcf725d8ff93b296eac8ffe12147189e","modified":1551874692292},{"_id":"source/_posts/writeSomething/koa2OnionModel.md","hash":"8c2c857faa6570441dddb4b10be2ce083ee84c57","modified":1552544768022},{"_id":"source/_posts/writeSomething/.DS_Store","hash":"108ea65da4a855e78040390aa38d5c8432a3a83d","modified":1552297226109},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"21765ec5abc9a65513e6bff57cb021d3b3852d35","modified":1550904528967},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"cf8a36a1a65089e5ca85c979d2c33e113d7be702","modified":1552544768026},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"142881aa536b82f4db9f45f27a01c23412fbd107","modified":1550904528970},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"3d6c7527bb156c4c3132d9813dcac3f99b5240cb","modified":1550904528972},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"af76b1a18a63934e83b078bf5f9f886e972a0ceb","modified":1550904528974},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"065f8d6c4aae6782e6819815911f7feb6402a4ec","modified":1550904528975},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"dcf88c81a85232f8298c5327673da7147214a677","modified":1550904528977},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"92ac580acc20bde7b3345bfe132671b9043bfbd6","modified":1550904528979},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"e1b4893af2b18f502bad1b552c3f3381ecc3021f","modified":1550904528980},{"_id":"themes/archer/layout/_partial/google-adsense.ejs","hash":"1e4f9055cf192501d0901296680a9600693c854b","modified":1550904528996},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"fc03729825ac7ffd4045f910bbd936bc5841c65e","modified":1550904528998},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1550904529022},{"_id":"themes/archer/source/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1550904529024},{"_id":"themes/archer/source/assets/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550809961832},{"_id":"themes/archer/source/assets/favicon.ico","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/assets/logo-36.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/assets/logo-48.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/assets/logo-64.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/css/mobile.css","hash":"2309aa0d6a7ef2502780788ae6727b7307b8033b","modified":1550904529026},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1549801924000},{"_id":"themes/archer/source/css/style.css","hash":"6679fb3b52fb94dc9c6d8f7fe15d25fcad683c4d","modified":1550904529028},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1549801924000},{"_id":"themes/archer/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1552297428863},{"_id":"themes/archer/source/scripts/main.js","hash":"258b08f308c2a78f6cc0a81cf353994da771966a","modified":1549801924000},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1549801924000},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1549801924000},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"6f18a92bbe8bed93113449ed6ff8d148c1e7565a","modified":1550904529042},{"_id":"themes/archer/src/js/browser.js","hash":"6e98eacb585fc24fe1f14e80dcb8d3b7d1b463fb","modified":1550904529050},{"_id":"themes/archer/src/js/fancybox.js","hash":"62a190b65d777057e86394d81869fbfa5051ca28","modified":1550904529052},{"_id":"themes/archer/src/js/init.js","hash":"fb1ea412d1306f07a62f95c56c732ad891036769","modified":1550904529054},{"_id":"themes/archer/src/js/initSidebar.js","hash":"d94a9da296c56e9b75def4386849df2b3b80e982","modified":1550904529056},{"_id":"themes/archer/src/js/main.js","hash":"9271c32fa8450d8c60bd605b9db578264afef90d","modified":1550904529058},{"_id":"themes/archer/src/js/mobile.js","hash":"27b974d628a94f5abd700ca7757bcd153d866442","modified":1550904529059},{"_id":"themes/archer/src/js/scroll.js","hash":"149f251f6ae1a319eecfc903ece61b9a6f4bede4","modified":1550904529061},{"_id":"themes/archer/src/js/search.js","hash":"238120e2832066948ce872c208680f4ef5c56900","modified":1550928190049},{"_id":"themes/archer/src/js/share.js","hash":"0c0ccd800e063bda901b99e5bfbe96c72723e5ba","modified":1550904529065},{"_id":"themes/archer/src/js/sidebar.js","hash":"50d354d84f05c927f29efd9a0ea52bcf46487cf6","modified":1551874692307},{"_id":"themes/archer/src/js/tag.js","hash":"18f58d928583ba84f2c53d069d57acd4d21677af","modified":1550904529068},{"_id":"themes/archer/src/js/toc.js","hash":"e6778bb114307cccdb5462b150fb4c79e0435f99","modified":1550904529070},{"_id":"themes/archer/src/js/util.js","hash":"da642e9e6b50ef56a6f85dab85d19b087e4ba373","modified":1550904529072},{"_id":"themes/archer/src/scss/_common.scss","hash":"95f061298cd824fe9f09dabe70dcb4fb44097557","modified":1550904529073},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"46d9e40be9000d23494a80cdd74fea61328ffdfa","modified":1550904529075},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"9123aa118cc636b4bfe718b87274d0b9732d8e89","modified":1550904529077},{"_id":"themes/archer/src/scss/_variables.scss","hash":"bfbd654e0637f21c29c6fb5613c6a4befe2952d8","modified":1550904529104},{"_id":"themes/archer/src/scss/mobile.scss","hash":"9e79e519443370f9ad9868db4ecfc9b00f18b1a7","modified":1550904529105},{"_id":"themes/archer/src/scss/style.scss","hash":"672e27e2e125f55499f65c4d572f1b94a1a8ed7d","modified":1550904529107},{"_id":"themes/archer/source/images/favicon.ico","hash":"6484806109ed1950f6700639a86b96c6681d6f9e","modified":1547608978327},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549801924000},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1549801924000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1549801924000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1549801924000},{"_id":"themes/archer/source/images/bg_post.png","hash":"dacb8dbf91978317e1fc0925137167f3f76285e2","modified":1507789973000},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0c3192b500a4fd550e483cf77a49806a5872185b","modified":1550904529040},{"_id":"themes/archer/package-lock.json","hash":"42f7658ed1726d9501c36c143c2b424b78a8708b","modified":1550904529017},{"_id":"themes/archer/source/images/wechat.jpg","hash":"ce8f4cf5b5b3c59349cca27a7617a7996d4c3f7a","modified":1552297398173},{"_id":"source/_posts/writeSomething/koa2OnionModel/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550838469096},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"244a4c71b862e6385a6de1e83a4975418a8c6fe7","modified":1550904528982},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"c043a98e33252b9a628bfd31c4a3b2883dce2b99","modified":1550904528987},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"a6acb5d7778ade98ba5b6932e38a585460513f49","modified":1550904528989},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cfdb15116abe89f4b54f7bb18a0b23a597c47a60","modified":1550904528986},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"745bb720cbbcc0a5281361f23814d1d8f97f8a02","modified":1550904528991},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"483c07212879b116b772f428547c9962be96d2ce","modified":1550904528992},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"c22a713d188bf15e5db02b69b2b3714eb431dc79","modified":1550904528994},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"4281841e5bbb5e1a83c3ebf6506dab057e1fe6b9","modified":1550904528999},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"c5ce643a06a2103aa4ac0d8279c024f90886d37f","modified":1550904529001},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"e710acbc85e1cc5ae0e7ab5b5899837b9f222b97","modified":1550904529003},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"e96750b1aa7113322696857882b1e1fde11c1fc4","modified":1550904529006},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"4feb7c3d17a3c8994eb095d43d75fbd0f1ed5b4f","modified":1550904529005},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"6631872bf75d10a0ccc5c03704e428d74d6835c5","modified":1550904529079},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"0570b1fd3007952ed0697c777f404b423e7a959c","modified":1550904529081},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"b4d8e76f3b5d06c19845f08eee17cb945c375107","modified":1550904529083},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"2cee47f28de27e8e6d0b5566135c117278e773d8","modified":1550904529094},{"_id":"source/_posts/writeSomething/PayAttentionToThoseJs/virturedom.png","hash":"8414992181ff755e9295fb4e1c84c2373968f5a9","modified":1552281270917},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1549801924000},{"_id":"themes/archer/source/images/avatar1.png","hash":"dbcbcd062a1113d7c656cad3c8d7642031a0146f","modified":1551671415557},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"1938574e03a8a272cf99ac5d0bdc1fad9e4da641","modified":1550904529084},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"f166c2ba859f2ce76e7ade441c83cbc81bdf184e","modified":1550904529086},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"690f6188fdf0113b0ce6d28a97b872ce0f52f792","modified":1550904529088},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"ad14edda32d4e3f05819eda783db321402d37356","modified":1550904529090},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"e88fa63587af0ee490591ff5e8953c8e875dcfd6","modified":1550904529091},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"eabe9fd56908ce595eedc90bb211412aba5d433c","modified":1550904529093},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"ed7b87d71b94cdb4e327fe1164a6c2df9ce1288c","modified":1550904529096},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"049f0eac5a71e69d2a09a04e5caf75c27e61aafd","modified":1550904529098},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"51b3d17bf4fc3f301be631c4ee750d1c8189bd2a","modified":1550904529100},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"90617295ae34d29d69b0b336454963ac0adb30db","modified":1550904529102},{"_id":"source/_posts/writeSomething/koa2OnionModel/onion.png","hash":"64ed5f85efbca9cda0ecb5737edf3430f044f733","modified":1550835653175},{"_id":"themes/archer/source/images/bg_site.jpg","hash":"958660a9659be7b1c58eb60c8abf6d4ff0dfc88c","modified":1546938271109},{"_id":"source/_posts/writeSomething/FunctionalEventEmitter.md","hash":"a0f5e56013b2237dc9304430d19274d6261f1229","modified":1553484204585},{"_id":"themes/archer/source/images/post.JPG","hash":"1337609fa1cab47f073af7869156486a0d0dec4f","modified":1552734070762},{"_id":"themes/archer/source/images/site.JPG","hash":"65f6a2eac40d59d549009161e68258d34a30f6c0","modified":1552734316839},{"_id":"source/_posts/about/HowAnEconomyGrowsAndWhyItCrashes.md","hash":"340d108a361b9eeba012651c0ae930cd2a24a66a","modified":1553677154180},{"_id":"source/_posts/about/HowAnEconomyGrowsAndWhyItCrashes/economy_1.png","hash":"82de229d9cc94528dbeca4e9819822847950ef92","modified":1553677097507}],"Category":[{"name":"当我在扯淡","_id":"cjtbdahhh0005zk48u4099627"},{"name":"算法","_id":"cjtbdahhu000lzk48toq7ffpy"},{"name":"你应该知道的","_id":"cjtbdahhw000szk48j5wpp191"},{"name":"封装","_id":"cjtbdahhx0010zk48pi6u0x35"},{"name":"经济学","_id":"cjtqz9mf80001lovap7zd6jp5"}],"Data":[],"Page":[{"layout":"404","title":"[404]","description":"May the Force be with you :&#41;","_content":"","source":"404.md","raw":"---\nlayout: 404\ntitle: \"[404]\"\ndescription: \"May the Force be with you :&#41;\"\n---","date":"2019-02-23T06:48:48.938Z","updated":"2019-02-23T06:48:48.938Z","path":"404.html","_id":"cjtbdahfl0000zk48uyc9eysi","comments":1,"content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"{\n    \"dir\": \"auto\",\n    \"lang\": \"zh\",\n    \"name\": \"kwok io\",\n    \"scope\": \"/\",\n    \"display\": \"standalone\",\n    \"start_url\": \"/\",\n    \"short_name\": \"kwok io\",\n    \"theme_color\": \"transparent\",\n    \"description\": \"- kwok io\",\n    \"orientation\": \"any\",\n    \"background_color\": \"transparent\",\n    \"related_applications\": [],\n    \"prefer_related_applications\": false,\n    \"gcm_sender_id\": \"482941778795\",\n    \"gcm_sender_id_comment\": \"Do not change the GCM Sender ID\",\n    \"icons\": [{\n      \"src\": \"/assets/logo-32.png\",\n      \"sizes\": \"32x32\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"/assets/logo-48.png\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/png\"\n    },\n    {\n        \"src\": \"/assets/logo-64.png\",\n        \"sizes\": \"64x64\",\n        \"type\": \"image/png\"\n      }\n    ]\n  }","source":"manifest.json","raw":"{\n    \"dir\": \"auto\",\n    \"lang\": \"zh\",\n    \"name\": \"kwok io\",\n    \"scope\": \"/\",\n    \"display\": \"standalone\",\n    \"start_url\": \"/\",\n    \"short_name\": \"kwok io\",\n    \"theme_color\": \"transparent\",\n    \"description\": \"- kwok io\",\n    \"orientation\": \"any\",\n    \"background_color\": \"transparent\",\n    \"related_applications\": [],\n    \"prefer_related_applications\": false,\n    \"gcm_sender_id\": \"482941778795\",\n    \"gcm_sender_id_comment\": \"Do not change the GCM Sender ID\",\n    \"icons\": [{\n      \"src\": \"/assets/logo-32.png\",\n      \"sizes\": \"32x32\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"/assets/logo-48.png\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/png\"\n    },\n    {\n        \"src\": \"/assets/logo-64.png\",\n        \"sizes\": \"64x64\",\n        \"type\": \"image/png\"\n      }\n    ]\n  }","date":"2019-02-23T06:48:48.947Z","updated":"2019-02-23T06:48:48.947Z","path":"manifest.json","layout":"false","_id":"cjtbdahfw0001zk48xcva5tsl","title":"","comments":1,"content":"{\"dir\":\"auto\",\"lang\":\"zh\",\"name\":\"kwok io\",\"scope\":\"/\",\"display\":\"standalone\",\"start_url\":\"/\",\"short_name\":\"kwok io\",\"theme_color\":\"transparent\",\"description\":\"- kwok io\",\"orientation\":\"any\",\"background_color\":\"transparent\",\"related_applications\":[],\"prefer_related_applications\":false,\"gcm_sender_id\":\"482941778795\",\"gcm_sender_id_comment\":\"Do not change the GCM Sender ID\",\"icons\":[{\"src\":\"/assets/logo-32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-64.png\",\"sizes\":\"64x64\",\"type\":\"image/png\"}]}","site":{"data":{}},"excerpt":"","more":"{\"dir\":\"auto\",\"lang\":\"zh\",\"name\":\"kwok io\",\"scope\":\"/\",\"display\":\"standalone\",\"start_url\":\"/\",\"short_name\":\"kwok io\",\"theme_color\":\"transparent\",\"description\":\"- kwok io\",\"orientation\":\"any\",\"background_color\":\"transparent\",\"related_applications\":[],\"prefer_related_applications\":false,\"gcm_sender_id\":\"482941778795\",\"gcm_sender_id_comment\":\"Do not change the GCM Sender ID\",\"icons\":[{\"src\":\"/assets/logo-32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-64.png\",\"sizes\":\"64x64\",\"type\":\"image/png\"}]}"},{"title":"chris kwok","layout":"about","_content":"hi\n\nhere is chris kwok\n\nas a front-end coder\n\nin shanghai\n\n","source":"about/index.md","raw":"---\ntitle: chris kwok\nlayout: about\n---\nhi\n\nhere is chris kwok\n\nas a front-end coder\n\nin shanghai\n\n","date":"2019-02-23T06:48:48.941Z","updated":"2019-02-23T06:48:48.941Z","path":"about/index.html","_id":"cjtbdahgw0002zk48o7irrl5w","comments":1,"content":"<p>hi</p>\n<p>here is chris kwok</p>\n<p>as a front-end coder</p>\n<p>in shanghai</p>\n","site":{"data":{}},"excerpt":"","more":"<p>hi</p>\n<p>here is chris kwok</p>\n<p>as a front-end coder</p>\n<p>in shanghai</p>\n"}],"Post":[{"title":"关于互联网寒冬","date":"2019-02-28T11:14:00.000Z","_content":"\n当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽\n<!-- more -->\n\n“面了好多家没拿到一个offer”\n“唉，一直接不到面试邀请”\n“外面行情是真的差啊，大厂都在裁员”\n.\n.\n.\n# winter of internet\n\n互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说\n\n有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧\n\n没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比\n\n然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？\n\n京东执行末尾淘汰机制。如何执行？裁员35%\n\n年后回到上海，朋友告诉我沪江教育裁了整两层楼\n\n前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人\n\n我肯定是麻木了\n\n# added fuel to the fire\n\n裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？\n\n老板：“996是一个好计划，just do it”\n\n大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢\n\n要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’\n白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”\n\n还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？\n\n# I'm such a pain in the neck\n\n当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中\n\n从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立...但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：无知带来的是自信不是知识，一个名词：*达克效应*\n\n这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）\n\n以前认识的一个老大私聊我：有想法吗\n\n且行且看容我想一想\n\n我是人间惆怅客\n\n# last\n\n下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”\n\nend\n","source":"_posts/humanbeings/IsThisInternetWinter.md","raw":"---\ntitle: 关于互联网寒冬\ntags:\n  - 当我在扯淡\ndate: 2019-02-28 19:14:00\ncategories: 当我在扯淡\n---\n\n当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽\n<!-- more -->\n\n“面了好多家没拿到一个offer”\n“唉，一直接不到面试邀请”\n“外面行情是真的差啊，大厂都在裁员”\n.\n.\n.\n# winter of internet\n\n互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说\n\n有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧\n\n没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比\n\n然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？\n\n京东执行末尾淘汰机制。如何执行？裁员35%\n\n年后回到上海，朋友告诉我沪江教育裁了整两层楼\n\n前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人\n\n我肯定是麻木了\n\n# added fuel to the fire\n\n裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？\n\n老板：“996是一个好计划，just do it”\n\n大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢\n\n要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’\n白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”\n\n还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？\n\n# I'm such a pain in the neck\n\n当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中\n\n从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立...但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：无知带来的是自信不是知识，一个名词：*达克效应*\n\n这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）\n\n以前认识的一个老大私聊我：有想法吗\n\n且行且看容我想一想\n\n我是人间惆怅客\n\n# last\n\n下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”\n\nend\n","slug":"humanbeings/IsThisInternetWinter","published":1,"updated":"2019-03-14T06:26:08.012Z","_id":"cjtbdahhd0003zk48n1cqrsck","comments":1,"layout":"post","photos":[],"link":"","content":"<p>当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽<br><a id=\"more\"></a></p>\n<p>“面了好多家没拿到一个offer”<br>“唉，一直接不到面试邀请”<br>“外面行情是真的差啊，大厂都在裁员”<br>.<br>.<br>.</p>\n<h1 id=\"winter-of-internet\"><a href=\"#winter-of-internet\" class=\"headerlink\" title=\"winter of internet\"></a>winter of internet</h1><p>互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说</p>\n<p>有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧</p>\n<p>没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比</p>\n<p>然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？</p>\n<p>京东执行末尾淘汰机制。如何执行？裁员35%</p>\n<p>年后回到上海，朋友告诉我沪江教育裁了整两层楼</p>\n<p>前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人</p>\n<p>我肯定是麻木了</p>\n<h1 id=\"added-fuel-to-the-fire\"><a href=\"#added-fuel-to-the-fire\" class=\"headerlink\" title=\"added fuel to the fire\"></a>added fuel to the fire</h1><p>裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？</p>\n<p>老板：“996是一个好计划，just do it”</p>\n<p>大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢</p>\n<p>要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’<br>白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”</p>\n<p>还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？</p>\n<h1 id=\"I’m-such-a-pain-in-the-neck\"><a href=\"#I’m-such-a-pain-in-the-neck\" class=\"headerlink\" title=\"I’m such a pain in the neck\"></a>I’m such a pain in the neck</h1><p>当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中</p>\n<p>从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立…但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：无知带来的是自信不是知识，一个名词：<em>达克效应</em></p>\n<p>这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）</p>\n<p>以前认识的一个老大私聊我：有想法吗</p>\n<p>且行且看容我想一想</p>\n<p>我是人间惆怅客</p>\n<h1 id=\"last\"><a href=\"#last\" class=\"headerlink\" title=\"last\"></a>last</h1><p>下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”</p>\n<p>end</p>\n","site":{"data":{}},"excerpt":"<p>当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽<br></p>","more":"<p></p>\n<p>“面了好多家没拿到一个offer”<br>“唉，一直接不到面试邀请”<br>“外面行情是真的差啊，大厂都在裁员”<br>.<br>.<br>.</p>\n<h1 id=\"winter-of-internet\"><a href=\"#winter-of-internet\" class=\"headerlink\" title=\"winter of internet\"></a>winter of internet</h1><p>互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说</p>\n<p>有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧</p>\n<p>没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比</p>\n<p>然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？</p>\n<p>京东执行末尾淘汰机制。如何执行？裁员35%</p>\n<p>年后回到上海，朋友告诉我沪江教育裁了整两层楼</p>\n<p>前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人</p>\n<p>我肯定是麻木了</p>\n<h1 id=\"added-fuel-to-the-fire\"><a href=\"#added-fuel-to-the-fire\" class=\"headerlink\" title=\"added fuel to the fire\"></a>added fuel to the fire</h1><p>裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？</p>\n<p>老板：“996是一个好计划，just do it”</p>\n<p>大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢</p>\n<p>要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’<br>白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”</p>\n<p>还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？</p>\n<h1 id=\"I’m-such-a-pain-in-the-neck\"><a href=\"#I’m-such-a-pain-in-the-neck\" class=\"headerlink\" title=\"I’m such a pain in the neck\"></a>I’m such a pain in the neck</h1><p>当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中</p>\n<p>从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立…但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：无知带来的是自信不是知识，一个名词：<em>达克效应</em></p>\n<p>这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）</p>\n<p>以前认识的一个老大私聊我：有想法吗</p>\n<p>且行且看容我想一想</p>\n<p>我是人间惆怅客</p>\n<h1 id=\"last\"><a href=\"#last\" class=\"headerlink\" title=\"last\"></a>last</h1><p>下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”</p>\n<p>end</p>"},{"title":"Alive","date":"2018-12-07T06:36:00.000Z","_content":"你选择了生活还是被生活选择\n<!-- more -->\n\n昨晚下班\n淅淅沥沥的雨\n走出泗泾站到金地三期4#楼下需要1110步\n\n我究竟是活了365天还是活了一天却重复了365次","source":"_posts/humanbeings/alive.md","raw":"---\ntitle: Alive\ntags:\n  - 当我在扯淡\ndate: 2018-12-07 14:36:00\ncategories: 当我在扯淡\n---\n你选择了生活还是被生活选择\n<!-- more -->\n\n昨晚下班\n淅淅沥沥的雨\n走出泗泾站到金地三期4#楼下需要1110步\n\n我究竟是活了365天还是活了一天却重复了365次","slug":"humanbeings/alive","published":1,"updated":"2019-03-22T08:46:13.611Z","_id":"cjtbdahhf0004zk48v4ekxchs","comments":1,"layout":"post","photos":[],"link":"","content":"<p>你选择了生活还是被生活选择<br><a id=\"more\"></a></p>\n<p>昨晚下班<br>淅淅沥沥的雨<br>走出泗泾站到金地三期4#楼下需要1110步</p>\n<p>我究竟是活了365天还是活了一天却重复了365次</p>\n","site":{"data":{}},"excerpt":"<p>你选择了生活还是被生活选择<br></p>","more":"<p></p>\n<p>昨晚下班<br>淅淅沥沥的雨<br>走出泗泾站到金地三期4#楼下需要1110步</p>\n<p>我究竟是活了365天还是活了一天却重复了365次</p>"},{"title":"人生天地间 忽如远行客","date":"2019-01-03T16:00:00.000Z","_content":"\n我是人间惆怅客\n知君何事泪纵横\n\n<!--more-->\n\n## 原来18年已经结束了\n\n已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧\n\n从途虎到鱼泡泡\n\n结识不少新朋友\n\n和 [曹少](https://github.com/kailcc) 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍\n\n感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住\n\n心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事\n\n\n依然单身，这城市太空\n\n依旧经常胡思乱想，上至宇宙下至微尘，人事物景情\n\n之后再补上吧\n\n最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛\n","source":"_posts/humanbeings/人生天地间 忽如远行客.md","raw":"---\ntitle: 人生天地间 忽如远行客\ntags:\n  - 当我在扯淡\ndate: 2019-01-04 00:00:00\ncategories: 当我在扯淡\n---\n\n我是人间惆怅客\n知君何事泪纵横\n\n<!--more-->\n\n## 原来18年已经结束了\n\n已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧\n\n从途虎到鱼泡泡\n\n结识不少新朋友\n\n和 [曹少](https://github.com/kailcc) 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍\n\n感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住\n\n心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事\n\n\n依然单身，这城市太空\n\n依旧经常胡思乱想，上至宇宙下至微尘，人事物景情\n\n之后再补上吧\n\n最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛\n","slug":"humanbeings/人生天地间 忽如远行客","published":1,"updated":"2019-03-06T12:18:12.292Z","_id":"cjtbdahhj0007zk48mprsie1g","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我是人间惆怅客<br>知君何事泪纵横</p>\n<a id=\"more\"></a>\n<h2 id=\"原来18年已经结束了\"><a href=\"#原来18年已经结束了\" class=\"headerlink\" title=\"原来18年已经结束了\"></a>原来18年已经结束了</h2><p>已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧</p>\n<p>从途虎到鱼泡泡</p>\n<p>结识不少新朋友</p>\n<p>和 <a href=\"https://github.com/kailcc\" target=\"_blank\" rel=\"noopener\">曹少</a> 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍</p>\n<p>感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住</p>\n<p>心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事</p>\n<p>依然单身，这城市太空</p>\n<p>依旧经常胡思乱想，上至宇宙下至微尘，人事物景情</p>\n<p>之后再补上吧</p>\n<p>最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛</p>\n","site":{"data":{}},"excerpt":"<p>我是人间惆怅客<br>知君何事泪纵横</p>","more":"<h2 id=\"原来18年已经结束了\"><a href=\"#原来18年已经结束了\" class=\"headerlink\" title=\"原来18年已经结束了\"></a>原来18年已经结束了</h2><p>已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧</p>\n<p>从途虎到鱼泡泡</p>\n<p>结识不少新朋友</p>\n<p>和 <a href=\"https://github.com/kailcc\" target=\"_blank\" rel=\"noopener\">曹少</a> 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍</p>\n<p>感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住</p>\n<p>心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事</p>\n<p>依然单身，这城市太空</p>\n<p>依旧经常胡思乱想，上至宇宙下至微尘，人事物景情</p>\n<p>之后再补上吧</p>\n<p>最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛</p>"},{"title":"算法复杂度","date":"2019-03-06T03:15:00.000Z","_content":"算法运行的时间复杂度和空间复杂度简单理解\n<!-- more -->\n*和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师*\n\n# 算法\n**算法**（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数\n\n说个粗浅的观点：在JS中定义的函数都是算法\n\n# 算法复杂度\n针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示\n\n- 时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)\n- 空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度\n\n*算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度*\n\n***所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度***\n\n# 时间复杂度\n一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用\"O\"来表示数量级，给出算法的时间复杂度\n\nT(n)=O(f(n))\n\n它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界\n- 时间复杂度就是函数中基本操作所执行的次数\n- 一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数\n- 忽略掉常数项\n- 关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数\n- 计算时间复杂度是估算随着n的增长函数执行次数的增长趋势\n- 递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数\n\n# 空间复杂度\n算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级\n\nS(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)\n\n递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)\n\n# 基础算法\n基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主\n\n## 冒泡排序\n核心代码：\n```js\n// arr\nfor (let i = 0; i < arr.length; i++) {\n  for (let j = 0; j < arr.length; j++) {\n    if (arr[j] > arr[j+1]) {\n      let temp = arr[j+1]\n      arr[j+1] = arr[j]\n      arr[j] = temp\n    }\n  }\n}\n```\n*此处只表述最基本的情况，不优化任何代码*\n\n该冒泡算法的时间复杂度：\n从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2\n所以该冒泡排序的时间复杂度为O(n^2)\n\n该冒泡算法的空间复杂度：\n从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)\n\n## 递归\n递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢\n\n*只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了*\n\n递归demo：\n```js\nlet n = 10\n\nfunction recursion() {\n  if (n > 1)\n    n-- && recursion()\n  else\n    return 'end of the recursive'\n}\n```\n上述是一个会循环执行10次就终止的简单递归\n该递归的时间复杂度：\n设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)\n该递归的空间复杂度：\n设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)\n\n## 二分法\n二分法本质依然是使用递归不断等分，代码如下：\n\n```js\n/**\n * @description: dichotomy\n * @param {Array} arr 入参数组\n * @param {any} val match\n * @param {Number} l 索引开始\n * @param {Number} r 索引结束\n*/\nfunction dichotomy(arr, val, l, r ){\n    let mid = Math.floor((l + r) / 2);\n    let midval = arr[mid]\n\n    if (l > r) return console.log('no match')\n\n    if (midval === val) return console.log('has match, index is ', mid)\n\n    midval > val\n      ? dichotomy(arr, val, l, mid - 1)\n      : dichotomy(arr, val, mid + 1, r)\n}\n\n// 测试\nconst arr = [1, 2, 3, 4, 5]\ndichotomy(arr, 3, 0, arr.length - 1)\n\n// optput:\n// has match, index is  2\n```\n算法的执行是不断等分数组，直到无法匹配要查找的数据\n设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4...\n.\n.\n.\n第 x 等分后长度为 n/2^x\n而算法执行的最差的情况就是每个等分的长度为1，1就是临界值\n所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数\n\n所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）\n每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数\n\n\n以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌\n\n\n**end**","source":"_posts/writeSomething/AlgorithmComplexity.md","raw":"---\ntitle: 算法复杂度\ntags:\n  - 算法\n  - 算法复杂度\ndate: 2019-03-06 11:15:00\ncategories: 算法\n---\n算法运行的时间复杂度和空间复杂度简单理解\n<!-- more -->\n*和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师*\n\n# 算法\n**算法**（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数\n\n说个粗浅的观点：在JS中定义的函数都是算法\n\n# 算法复杂度\n针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示\n\n- 时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)\n- 空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度\n\n*算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度*\n\n***所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度***\n\n# 时间复杂度\n一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用\"O\"来表示数量级，给出算法的时间复杂度\n\nT(n)=O(f(n))\n\n它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界\n- 时间复杂度就是函数中基本操作所执行的次数\n- 一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数\n- 忽略掉常数项\n- 关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数\n- 计算时间复杂度是估算随着n的增长函数执行次数的增长趋势\n- 递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数\n\n# 空间复杂度\n算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级\n\nS(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)\n\n递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)\n\n# 基础算法\n基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主\n\n## 冒泡排序\n核心代码：\n```js\n// arr\nfor (let i = 0; i < arr.length; i++) {\n  for (let j = 0; j < arr.length; j++) {\n    if (arr[j] > arr[j+1]) {\n      let temp = arr[j+1]\n      arr[j+1] = arr[j]\n      arr[j] = temp\n    }\n  }\n}\n```\n*此处只表述最基本的情况，不优化任何代码*\n\n该冒泡算法的时间复杂度：\n从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2\n所以该冒泡排序的时间复杂度为O(n^2)\n\n该冒泡算法的空间复杂度：\n从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)\n\n## 递归\n递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢\n\n*只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了*\n\n递归demo：\n```js\nlet n = 10\n\nfunction recursion() {\n  if (n > 1)\n    n-- && recursion()\n  else\n    return 'end of the recursive'\n}\n```\n上述是一个会循环执行10次就终止的简单递归\n该递归的时间复杂度：\n设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)\n该递归的空间复杂度：\n设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)\n\n## 二分法\n二分法本质依然是使用递归不断等分，代码如下：\n\n```js\n/**\n * @description: dichotomy\n * @param {Array} arr 入参数组\n * @param {any} val match\n * @param {Number} l 索引开始\n * @param {Number} r 索引结束\n*/\nfunction dichotomy(arr, val, l, r ){\n    let mid = Math.floor((l + r) / 2);\n    let midval = arr[mid]\n\n    if (l > r) return console.log('no match')\n\n    if (midval === val) return console.log('has match, index is ', mid)\n\n    midval > val\n      ? dichotomy(arr, val, l, mid - 1)\n      : dichotomy(arr, val, mid + 1, r)\n}\n\n// 测试\nconst arr = [1, 2, 3, 4, 5]\ndichotomy(arr, 3, 0, arr.length - 1)\n\n// optput:\n// has match, index is  2\n```\n算法的执行是不断等分数组，直到无法匹配要查找的数据\n设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4...\n.\n.\n.\n第 x 等分后长度为 n/2^x\n而算法执行的最差的情况就是每个等分的长度为1，1就是临界值\n所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数\n\n所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）\n每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数\n\n\n以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌\n\n\n**end**","slug":"writeSomething/AlgorithmComplexity","published":1,"updated":"2019-03-06T12:18:12.292Z","_id":"cjtbdahhk0008zk4868mkq012","comments":1,"layout":"post","photos":[],"link":"","content":"<p>算法运行的时间复杂度和空间复杂度简单理解<br><a id=\"more\"></a><br><em>和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师</em></p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p><strong>算法</strong>（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数</p>\n<p>说个粗浅的观点：在JS中定义的函数都是算法</p>\n<h1 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h1><p>针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示</p>\n<ul>\n<li>时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)</li>\n<li>空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度</li>\n</ul>\n<p><em>算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度</em></p>\n<p><strong><em>所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度</em></strong></p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用”O”来表示数量级，给出算法的时间复杂度</p>\n<p>T(n)=O(f(n))</p>\n<p>它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界</p>\n<ul>\n<li>时间复杂度就是函数中基本操作所执行的次数</li>\n<li>一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数</li>\n<li>忽略掉常数项</li>\n<li>关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数</li>\n<li>计算时间复杂度是估算随着n的增长函数执行次数的增长趋势</li>\n<li>递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数</li>\n</ul>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级</p>\n<p>S(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)</p>\n<p>递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)</p>\n<h1 id=\"基础算法\"><a href=\"#基础算法\" class=\"headerlink\" title=\"基础算法\"></a>基础算法</h1><p>基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>核心代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arr</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = arr[j+<span class=\"number\">1</span>]</span><br><span class=\"line\">      arr[j+<span class=\"number\">1</span>] = arr[j]</span><br><span class=\"line\">      arr[j] = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>此处只表述最基本的情况，不优化任何代码</em></p>\n<p>该冒泡算法的时间复杂度：<br>从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2<br>所以该冒泡排序的时间复杂度为O(n^2)</p>\n<p>该冒泡算法的空间复杂度：<br>从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)</p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢</p>\n<p><em>只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了</em></p>\n<p>递归demo：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursion</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    n-- &amp;&amp; recursion()</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'end of the recursive'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述是一个会循环执行10次就终止的简单递归<br>该递归的时间复杂度：<br>设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)<br>该递归的空间复杂度：<br>设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)</p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><p>二分法本质依然是使用递归不断等分，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @description: dichotomy</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; arr 入参数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; val match</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; l 索引开始</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; r 索引结束</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dichotomy</span>(<span class=\"params\">arr, val, l, r </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor((l + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> midval = arr[mid]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'no match'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (midval === val) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'has match, index is '</span>, mid)</span><br><span class=\"line\"></span><br><span class=\"line\">    midval &gt; val</span><br><span class=\"line\">      ? dichotomy(arr, val, l, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">      : dichotomy(arr, val, mid + <span class=\"number\">1</span>, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">dichotomy(arr, <span class=\"number\">3</span>, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// optput:</span></span><br><span class=\"line\"><span class=\"comment\">// has match, index is  2</span></span><br></pre></td></tr></table></figure>\n<p>算法的执行是不断等分数组，直到无法匹配要查找的数据<br>设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4…<br>.<br>.<br>.<br>第 x 等分后长度为 n/2^x<br>而算法执行的最差的情况就是每个等分的长度为1，1就是临界值<br>所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数</p>\n<p>所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）<br>每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数</p>\n<p>以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌</p>\n<p><strong>end</strong></p>\n","site":{"data":{}},"excerpt":"<p>算法运行的时间复杂度和空间复杂度简单理解<br></p>","more":"<br><em>和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师</em><p></p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p><strong>算法</strong>（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数</p>\n<p>说个粗浅的观点：在JS中定义的函数都是算法</p>\n<h1 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h1><p>针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示</p>\n<ul>\n<li>时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)</li>\n<li>空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度</li>\n</ul>\n<p><em>算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度</em></p>\n<p><strong><em>所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度</em></strong></p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用”O”来表示数量级，给出算法的时间复杂度</p>\n<p>T(n)=O(f(n))</p>\n<p>它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界</p>\n<ul>\n<li>时间复杂度就是函数中基本操作所执行的次数</li>\n<li>一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数</li>\n<li>忽略掉常数项</li>\n<li>关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数</li>\n<li>计算时间复杂度是估算随着n的增长函数执行次数的增长趋势</li>\n<li>递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数</li>\n</ul>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级</p>\n<p>S(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)</p>\n<p>递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)</p>\n<h1 id=\"基础算法\"><a href=\"#基础算法\" class=\"headerlink\" title=\"基础算法\"></a>基础算法</h1><p>基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>核心代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arr</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = arr[j+<span class=\"number\">1</span>]</span><br><span class=\"line\">      arr[j+<span class=\"number\">1</span>] = arr[j]</span><br><span class=\"line\">      arr[j] = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>此处只表述最基本的情况，不优化任何代码</em></p>\n<p>该冒泡算法的时间复杂度：<br>从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2<br>所以该冒泡排序的时间复杂度为O(n^2)</p>\n<p>该冒泡算法的空间复杂度：<br>从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)</p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢</p>\n<p><em>只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了</em></p>\n<p>递归demo：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursion</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    n-- &amp;&amp; recursion()</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'end of the recursive'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述是一个会循环执行10次就终止的简单递归<br>该递归的时间复杂度：<br>设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)<br>该递归的空间复杂度：<br>设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)</p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><p>二分法本质依然是使用递归不断等分，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @description: dichotomy</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; arr 入参数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; val match</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; l 索引开始</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; r 索引结束</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dichotomy</span>(<span class=\"params\">arr, val, l, r </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor((l + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> midval = arr[mid]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'no match'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (midval === val) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'has match, index is '</span>, mid)</span><br><span class=\"line\"></span><br><span class=\"line\">    midval &gt; val</span><br><span class=\"line\">      ? dichotomy(arr, val, l, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">      : dichotomy(arr, val, mid + <span class=\"number\">1</span>, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">dichotomy(arr, <span class=\"number\">3</span>, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// optput:</span></span><br><span class=\"line\"><span class=\"comment\">// has match, index is  2</span></span><br></pre></td></tr></table></figure>\n<p>算法的执行是不断等分数组，直到无法匹配要查找的数据<br>设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4…<br>.<br>.<br>.<br>第 x 等分后长度为 n/2^x<br>而算法执行的最差的情况就是每个等分的长度为1，1就是临界值<br>所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数</p>\n<p>所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）<br>每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数</p>\n<p>以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌</p>\n<p><strong>end</strong></p>"},{"title":"JS/Node的事件循环","date":"2019-03-07T03:21:00.000Z","_content":"\nJS特色之一是单线程，那所谓的基于事件的异步机制是什么？\n<!--more-->\n# JS是单线程\nAll we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8\n另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因\n\n另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步\n\n那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列\n\n# JS事件循环\n类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数\n\n一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行\n\n在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中\n\n每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环\n\n### 宏任务（Macrotask）\n- 整体代码(script)\n- setTimeout\n- setInterval\n- setImmediate（node）\n- I/O\n- UI rendering\n- requestAnimationFrame（浏览器）\n\n### 微任务（Microtask）\n- process.nextTick（node）\n- Promise.then catch finally\n- Object.observe（已废弃）\n- MutationObserver（浏览器）\n\n*括号内表示支持的环境*\n\n### 案例分析\n```js\n// 全局scripts macrotask\nconsole.log('macrotask scripts start')\n\n// macrotask\nsetTimeout(() => {\n  Promise.resolve().then(() => console.log('macrotask 1 inner: microtask'))\n\n  console.log('macrotask 1')\n}, 0)\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 1'))\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 2'))\n\nconsole.log('macrotask scripts end')\n\n// output:\n\n// VM322:1  macrotask scripts start\n// VM322:16 macrotask scripts end\n// VM322:11 microtask 1\n// VM322:14 microtask 2\n// VM322:7  macrotask 1\n// VM322:5  macrotask 1 inner: microtask\n```\n\n首先进入 **全局scripts macrotask**\n  - 执行当前 macrotask 中所有同步代码\n    - // VM322:1  macrotask scripts start\n    - // VM322:16 macrotask scripts end\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:11 microtask 1\n    - // VM322:14 microtask 2\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n  - 新一轮循环执行当前 macrotask 中所有同步代码\n    - // VM322:7  macrotask 1\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:5  macrotask 1 inner: microtask\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n    - 执行完毕结束循环\n\n### 误解\n面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”\n\n- 一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列\n- 键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列\n- setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队\n- ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队\n\n# Node的事件循环\nnode是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行\n\n当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环\n\n与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：\n- timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调\n  * 检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调\n  * 检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- idle, prepare：仅系统内部使用\n- Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒\n首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。\n  * 第一种情况：\n    - 如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调\n    - 检查是否有 process.nextTick 回调，如果有，全部执行\n    - 检查是否有 microtaks，如果有，全部执行\n    - 退出该阶段\n  * 第二种情况：\n    - 如果没有可用回调\n    - 检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知\n    - 如果不存在尚未完成的回调，退出poll阶段\n- Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 check 阶段\n- Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on('close', ...). 用于资源清理\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 closing 阶段\n一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序\n\n事件循环过程如下图示意*每个框内代表一个阶段*：\n\n```js\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n```\n每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段\n\n由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值\n\n在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净\n\n补充：\n1. setImmediate 对比 setTimeout\nsetImmediate 和 setTimeout 很类似，但何时调用行为完全不同\n  - setImmediate 设计为在当前 轮询 阶段完成后执行脚本\n  - setTimeout 计划在毫秒的最小阈值经过后运行的脚本\n执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）\n\n2. process.nextTick\nprocess.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码\n任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段\n\n以上简要介绍JS/Node的事件循环，存在相关错误请指出😄\n\nLink：\n  - [The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)\n  - [深入分析Node.js事件循环](https://blog.csdn.net/i10630226/article/details/81369841)\n\n**end**\n","source":"_posts/writeSomething/EventLoop.md","raw":"---\ntitle: JS/Node的事件循环\ntags:\n  - 事件循环\n  - 任务队列\ndate: 2019-03-07 11:21:00\ncategories: 你应该知道的\n---\n\nJS特色之一是单线程，那所谓的基于事件的异步机制是什么？\n<!--more-->\n# JS是单线程\nAll we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8\n另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因\n\n另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步\n\n那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列\n\n# JS事件循环\n类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数\n\n一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行\n\n在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中\n\n每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环\n\n### 宏任务（Macrotask）\n- 整体代码(script)\n- setTimeout\n- setInterval\n- setImmediate（node）\n- I/O\n- UI rendering\n- requestAnimationFrame（浏览器）\n\n### 微任务（Microtask）\n- process.nextTick（node）\n- Promise.then catch finally\n- Object.observe（已废弃）\n- MutationObserver（浏览器）\n\n*括号内表示支持的环境*\n\n### 案例分析\n```js\n// 全局scripts macrotask\nconsole.log('macrotask scripts start')\n\n// macrotask\nsetTimeout(() => {\n  Promise.resolve().then(() => console.log('macrotask 1 inner: microtask'))\n\n  console.log('macrotask 1')\n}, 0)\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 1'))\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 2'))\n\nconsole.log('macrotask scripts end')\n\n// output:\n\n// VM322:1  macrotask scripts start\n// VM322:16 macrotask scripts end\n// VM322:11 microtask 1\n// VM322:14 microtask 2\n// VM322:7  macrotask 1\n// VM322:5  macrotask 1 inner: microtask\n```\n\n首先进入 **全局scripts macrotask**\n  - 执行当前 macrotask 中所有同步代码\n    - // VM322:1  macrotask scripts start\n    - // VM322:16 macrotask scripts end\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:11 microtask 1\n    - // VM322:14 microtask 2\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n  - 新一轮循环执行当前 macrotask 中所有同步代码\n    - // VM322:7  macrotask 1\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:5  macrotask 1 inner: microtask\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n    - 执行完毕结束循环\n\n### 误解\n面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”\n\n- 一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列\n- 键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列\n- setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队\n- ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队\n\n# Node的事件循环\nnode是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行\n\n当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环\n\n与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：\n- timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调\n  * 检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调\n  * 检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- idle, prepare：仅系统内部使用\n- Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒\n首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。\n  * 第一种情况：\n    - 如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调\n    - 检查是否有 process.nextTick 回调，如果有，全部执行\n    - 检查是否有 microtaks，如果有，全部执行\n    - 退出该阶段\n  * 第二种情况：\n    - 如果没有可用回调\n    - 检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知\n    - 如果不存在尚未完成的回调，退出poll阶段\n- Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 check 阶段\n- Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on('close', ...). 用于资源清理\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 closing 阶段\n一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序\n\n事件循环过程如下图示意*每个框内代表一个阶段*：\n\n```js\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n```\n每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段\n\n由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值\n\n在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净\n\n补充：\n1. setImmediate 对比 setTimeout\nsetImmediate 和 setTimeout 很类似，但何时调用行为完全不同\n  - setImmediate 设计为在当前 轮询 阶段完成后执行脚本\n  - setTimeout 计划在毫秒的最小阈值经过后运行的脚本\n执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）\n\n2. process.nextTick\nprocess.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码\n任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段\n\n以上简要介绍JS/Node的事件循环，存在相关错误请指出😄\n\nLink：\n  - [The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)\n  - [深入分析Node.js事件循环](https://blog.csdn.net/i10630226/article/details/81369841)\n\n**end**\n","slug":"writeSomething/EventLoop","published":1,"updated":"2019-03-07T16:46:57.005Z","_id":"cjtbdahhk0009zk4849nguxy2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JS特色之一是单线程，那所谓的基于事件的异步机制是什么？<br><a id=\"more\"></a></p>\n<h1 id=\"JS是单线程\"><a href=\"#JS是单线程\" class=\"headerlink\" title=\"JS是单线程\"></a>JS是单线程</h1><p>All we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8<br>另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因</p>\n<p>另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步</p>\n<p>那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列</p>\n<h1 id=\"JS事件循环\"><a href=\"#JS事件循环\" class=\"headerlink\" title=\"JS事件循环\"></a>JS事件循环</h1><p>类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数</p>\n<p>一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行</p>\n<p>在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中</p>\n<p>每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环</p>\n<h3 id=\"宏任务（Macrotask）\"><a href=\"#宏任务（Macrotask）\" class=\"headerlink\" title=\"宏任务（Macrotask）\"></a>宏任务（Macrotask）</h3><ul>\n<li>整体代码(script)</li>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate（node）</li>\n<li>I/O</li>\n<li>UI rendering</li>\n<li>requestAnimationFrame（浏览器）</li>\n</ul>\n<h3 id=\"微任务（Microtask）\"><a href=\"#微任务（Microtask）\" class=\"headerlink\" title=\"微任务（Microtask）\"></a>微任务（Microtask）</h3><ul>\n<li>process.nextTick（node）</li>\n<li>Promise.then catch finally</li>\n<li>Object.observe（已废弃）</li>\n<li>MutationObserver（浏览器）</li>\n</ul>\n<p><em>括号内表示支持的环境</em></p>\n<h3 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局scripts macrotask</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts start'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// macrotask</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1 inner: microtask'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 1'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 2'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts end'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VM322:1  macrotask scripts start</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:16 macrotask scripts end</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:11 microtask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:14 microtask 2</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:7  macrotask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:5  macrotask 1 inner: microtask</span></span><br></pre></td></tr></table></figure>\n<p>首先进入 <strong>全局scripts macrotask</strong></p>\n<ul>\n<li>执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:1  macrotask scripts start</li>\n<li>// VM322:16 macrotask scripts end</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:11 microtask 1</li>\n<li>// VM322:14 microtask 2</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环</li>\n<li>新一轮循环执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:7  macrotask 1</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:5  macrotask 1 inner: microtask</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环<ul>\n<li>执行完毕结束循环</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"误解\"><a href=\"#误解\" class=\"headerlink\" title=\"误解\"></a>误解</h3><p>面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”</p>\n<ul>\n<li>一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列</li>\n<li>键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列</li>\n<li>setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队</li>\n<li>ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队</li>\n</ul>\n<h1 id=\"Node的事件循环\"><a href=\"#Node的事件循环\" class=\"headerlink\" title=\"Node的事件循环\"></a>Node的事件循环</h1><p>node是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行</p>\n<p>当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环</p>\n<p>与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：</p>\n<ul>\n<li>timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调<ul>\n<li>检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调<ul>\n<li>检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>idle, prepare：仅系统内部使用</li>\n<li>Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒<br>首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。<ul>\n<li>第一种情况：<ul>\n<li>如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>第二种情况：<ul>\n<li>如果没有可用回调</li>\n<li>检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知</li>\n<li>如果不存在尚未完成的回调，退出poll阶段</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 check 阶段</li>\n</ul>\n</li>\n<li>Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on(‘close’, …). 用于资源清理<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 closing 阶段<br>一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序</li>\n</ul>\n</li>\n</ul>\n<p>事件循环过程如下图示意<em>每个框内代表一个阶段</em>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   ┌───────────────────────────┐</span><br><span class=\"line\">┌─&gt;│           timers          │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │     pending callbacks     │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │       idle, prepare       │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class=\"line\">│  │           poll            │&lt;─────┤  connections, │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class=\"line\">│  │           check           │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">└──┤      close callbacks      │</span><br><span class=\"line\">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>\n<p>每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段</p>\n<p>由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值</p>\n<p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净</p>\n<p>补充：</p>\n<ol>\n<li><p>setImmediate 对比 setTimeout<br>setImmediate 和 setTimeout 很类似，但何时调用行为完全不同</p>\n<ul>\n<li>setImmediate 设计为在当前 轮询 阶段完成后执行脚本</li>\n<li>setTimeout 计划在毫秒的最小阈值经过后运行的脚本<br>执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）</li>\n</ul>\n</li>\n<li><p>process.nextTick<br>process.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码<br>任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段</p>\n</li>\n</ol>\n<p>以上简要介绍JS/Node的事件循环，存在相关错误请指出😄</p>\n<p>Link：</p>\n<ul>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"noopener\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n<li><a href=\"https://blog.csdn.net/i10630226/article/details/81369841\" target=\"_blank\" rel=\"noopener\">深入分析Node.js事件循环</a></li>\n</ul>\n<p><strong>end</strong></p>\n","site":{"data":{}},"excerpt":"<p>JS特色之一是单线程，那所谓的基于事件的异步机制是什么？<br></p>","more":"<p></p>\n<h1 id=\"JS是单线程\"><a href=\"#JS是单线程\" class=\"headerlink\" title=\"JS是单线程\"></a>JS是单线程</h1><p>All we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8<br>另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因</p>\n<p>另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步</p>\n<p>那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列</p>\n<h1 id=\"JS事件循环\"><a href=\"#JS事件循环\" class=\"headerlink\" title=\"JS事件循环\"></a>JS事件循环</h1><p>类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数</p>\n<p>一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行</p>\n<p>在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中</p>\n<p>每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环</p>\n<h3 id=\"宏任务（Macrotask）\"><a href=\"#宏任务（Macrotask）\" class=\"headerlink\" title=\"宏任务（Macrotask）\"></a>宏任务（Macrotask）</h3><ul>\n<li>整体代码(script)</li>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate（node）</li>\n<li>I/O</li>\n<li>UI rendering</li>\n<li>requestAnimationFrame（浏览器）</li>\n</ul>\n<h3 id=\"微任务（Microtask）\"><a href=\"#微任务（Microtask）\" class=\"headerlink\" title=\"微任务（Microtask）\"></a>微任务（Microtask）</h3><ul>\n<li>process.nextTick（node）</li>\n<li>Promise.then catch finally</li>\n<li>Object.observe（已废弃）</li>\n<li>MutationObserver（浏览器）</li>\n</ul>\n<p><em>括号内表示支持的环境</em></p>\n<h3 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局scripts macrotask</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts start'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// macrotask</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1 inner: microtask'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 1'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 2'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts end'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VM322:1  macrotask scripts start</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:16 macrotask scripts end</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:11 microtask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:14 microtask 2</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:7  macrotask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:5  macrotask 1 inner: microtask</span></span><br></pre></td></tr></table></figure>\n<p>首先进入 <strong>全局scripts macrotask</strong></p>\n<ul>\n<li>执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:1  macrotask scripts start</li>\n<li>// VM322:16 macrotask scripts end</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:11 microtask 1</li>\n<li>// VM322:14 microtask 2</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环</li>\n<li>新一轮循环执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:7  macrotask 1</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:5  macrotask 1 inner: microtask</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环<ul>\n<li>执行完毕结束循环</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"误解\"><a href=\"#误解\" class=\"headerlink\" title=\"误解\"></a>误解</h3><p>面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”</p>\n<ul>\n<li>一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列</li>\n<li>键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列</li>\n<li>setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队</li>\n<li>ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队</li>\n</ul>\n<h1 id=\"Node的事件循环\"><a href=\"#Node的事件循环\" class=\"headerlink\" title=\"Node的事件循环\"></a>Node的事件循环</h1><p>node是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行</p>\n<p>当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环</p>\n<p>与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：</p>\n<ul>\n<li>timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调<ul>\n<li>检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调<ul>\n<li>检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>idle, prepare：仅系统内部使用</li>\n<li>Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒<br>首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。<ul>\n<li>第一种情况：<ul>\n<li>如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>第二种情况：<ul>\n<li>如果没有可用回调</li>\n<li>检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知</li>\n<li>如果不存在尚未完成的回调，退出poll阶段</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 check 阶段</li>\n</ul>\n</li>\n<li>Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on(‘close’, …). 用于资源清理<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 closing 阶段<br>一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序</li>\n</ul>\n</li>\n</ul>\n<p>事件循环过程如下图示意<em>每个框内代表一个阶段</em>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   ┌───────────────────────────┐</span><br><span class=\"line\">┌─&gt;│           timers          │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │     pending callbacks     │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │       idle, prepare       │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class=\"line\">│  │           poll            │&lt;─────┤  connections, │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class=\"line\">│  │           check           │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">└──┤      close callbacks      │</span><br><span class=\"line\">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>\n<p>每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段</p>\n<p>由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值</p>\n<p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净</p>\n<p>补充：</p>\n<ol>\n<li><p>setImmediate 对比 setTimeout<br>setImmediate 和 setTimeout 很类似，但何时调用行为完全不同</p>\n<ul>\n<li>setImmediate 设计为在当前 轮询 阶段完成后执行脚本</li>\n<li>setTimeout 计划在毫秒的最小阈值经过后运行的脚本<br>执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）</li>\n</ul>\n</li>\n<li><p>process.nextTick<br>process.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码<br>任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段</p>\n</li>\n</ol>\n<p>以上简要介绍JS/Node的事件循环，存在相关错误请指出😄</p>\n<p>Link：</p>\n<ul>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"noopener\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n<li><a href=\"https://blog.csdn.net/i10630226/article/details/81369841\" target=\"_blank\" rel=\"noopener\">深入分析Node.js事件循环</a></li>\n</ul>\n<p><strong>end</strong></p>"},{"title":"你应该注意的那些JS（相关）","date":"2019-03-11T04:35:00.000Z","_content":"记录基本的JS相关的使用或者遇到的issues\n持续更新👏\n<!-- more -->\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=1340842066&auto=1&height=66\"></iframe>\n*没有分类顺序可能杂乱😝*\n\n# 小数部分进行数学运算可能会生成过多的小数位\n很多人应该都遇到过类似的问题：`0.1 + 0.2 === 0.3` 返回值是 false，顿为惊叹\n在浏览器输入后发现 `0.1 + 0.2` 返回值是 `0.30000000000000004`(小数17位，<a href=\"#JS（Java）浮点数的数字长度\">关于这个</a>)\n查了一下找到了个解释：\n> Computer in dealing with digital mathematical operations (such as the decimal), its first converted to binary again, the decimal Numbers to binary may occur in the process of precision loss, can be used by toFixed and round method comprehensive to solve this problem.\n\n计算机是只认识二进制的，数学运算中进制转换的过程可能会发现精度损失的情况\n\n*可以使用 `toFixed` 或者 `round` 方法兼容处理*\n\n# JS（Java）浮点数的数字长度\nECMAScript Number（Java： float | double） 是使用 IEEE754 格式来表示整数和浮点数，浮点数的最高精度为 17 位小数\n\n*`Number.EPSILON`(1 与大于 1 的最小浮点数之间的差, 换句话说其实就是JS支持的最小精度) 值为2^-52，约等于2.2e-16，浮点数运算的过程中，如果误差小于这个数值，可以认为误差是不存在的，所以说第17位上的小数，其实没有意义*\n\n# JS箭轴函数\n如下代码：\n```js\nfunction make () {\n  return () => console.log(this)\n}\nconst testFunc = make.call({ name:'foo' });\n\ntestFunc() // { name: \"foo\" } \ntestFunc.call({ name:'bar' }); // { name: \"foo\" }\n```\n可以看到箭头函数在定义之后，this 就不会发生改变了，无论用什么样的方式调用它，this 都不会改变\n\n原因：箭头函数不会自动绑定局部变量，如this，arguments，super(ES6)，new.target(ES6)等\n\n所以箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用\n\n箭轴函数有如下等特性：\n- 箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象\n- 箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误\n- 箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替\n- 不可以使用yield命令，因此箭头函数不能用作Generator函数\n\n# 关于创建vue中的vnode(virture dom)\n公司之前有个文件上传组件，由于每次都会创建一个实例dom导致一些不可预知的样式错误，于是同事改用vnode来处理这部分\n\n拿来主义：\n![virturedom](/virturedom.png)\n\n**Vue2.x版本中VNode属性：**\n- tag:当前节点标签名\n- data：当前节点数据对象\n- children：子节点数组\n- text：当前节点文本\n- elm：当前虚拟节点对应的真实dom节点\n- ns：节点的namespace( 名称空间)\n- content：编译作用域\n- functionalContext：函数化组件的作用域，即全局上下文\n- key：节点标识，有利于patch优化\n- componentOptions：创建组件实例时的options\n- child：当前节点对应的组件实例\n- parent：组件的占位节点\n- raw：原始html\n- isStatic：是否是静态节点\n- isRootInsert：是否作为跟节点插入，若被包裹的节点，该属性值为false\n- isComment：是否为注释节点\n- isCloned：是否为克隆节点\n- isOnce：是否只改变(渲染)一次，或是否有v-once指令\n其中这里面又有几种VNode类型\n- TextVNode：文本节点\n- ElementVNode：普通元素节点\n- ComponentVNode：组件节点\n- EmptyVNode：空节点，或者说是没有内容的注释节点\n- CloneVNode：克隆节点，可以是以上任意类型节\n\n什么时候用虚拟dom才比较好呢？其实我们使用的单文件组件就已经够好了。但是当某些代码冗余的时候如果写单文件组件的话会有好多重复的内容\n\n接下来介绍其核心函数createElement(h)：\ncreateElement接收3个参数：\n- 第一个参数可以是HTML标签名，组件或者函数都可以；此参数是必须的\n- 第二个为数据对象（可选）\n- 第三个为子节点（可选）\n\n**附上简单demo：**\n```js\nconst Instance = new Vue({\n  data: Object.assign({}, _props, {\n\n  }),\n  render(h) {\n    const vnode = h('input', {\n      attrs: {\n        type: 'file',\n        accept: 'image/*'\n      },\n      style: {\n        display: 'none'\n      },\n      ref: 'tuhu_upload_input'\n    })\n\n    return h('div', {\n      class: 'tuhu_upload_layout'\n    }, [vnode])\n  }\n})\n```\n\n# 使用instanceof判断构造函数的问题\n测试代码：\n```js\nfunction A() {}\n\nvar a = new A\nconsole.log(a instanceof A) // true\nconsole.log(a instanceof Object) // true\n\nvar obj = {}\nA.prototype = obj\n// a.__proto__ = obj // console.log(a instanceof A) // true\nvar a2 = new A\nconsole.log(a2 instanceof A) // true\nconsole.log(a instanceof A) // false\n\nconsole.log(a instanceof Object) // true\n```\n所以综上所述 instanceof 并不能从字面意思来判断谁是否是谁的实例对象\n鱼泡泡的面试题：instanceof 判断构造函数可能会出现不准确的情况吗？如 `const arr = []; arr instanceof Array === false`。大都说不出其中几何, 其实同样只需要更改 `arr.__proto__ = Object // Number etc.`\n\ninstanceof本意：\n> MDN: The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object.\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof](url)\n\n**就是说 instanceof 是用来判断 A.prototype 是否存在于参数 a 的原型链上**\n\n所以当A的prototype被指向任意一个其他对象的时候 A.prototype是不在a的原型链上的\n\na所在的原型链: a ==> a.__proto__ ==> Object.prototype ==> null\n\na2所在的原型链: a2 ==> obj ==> Object.prototype ==> null\n\n所以此时如果赋值a.__proto__ = obj，a instanceof A 同样会返回true\n\n*JS是一门基于原型的语言，而原型是动态的并非一定不变所以会有上述情况*\n\n# 将function声明的函数的函数式调用改为new 关键字调用\nes6的class声明类的方式是必须通过new关键字进行调用的\n\n而传统的利用function关键字声明的构造函数如何避免被函数式调用呢？或者说就算是函数式调用但是依然想要生成实例对象呢\n很简单 判断constructor即可\n\n```js\n// eg:\n\nfunction A() {\n  if (this.constructor !== arguments.callee) {\n    return new A\n  }\n  this.name = 'chris'\n  this.age = 23\n  this.job = function() {\n    console.log('A front-end engineer')\n  }\n  A.work = function() {\n    console.log('working hard')\n  }\n}\nA().job() // that's all\n\n```\n补充：\n*`Array()` 和 `new Array()` 是完全一致的*\n> The Array constructor is the %Array% intrinsic object and the initial value of the Array property of the global object. When called as a constructor it creates and initializes a new exotic Array object. When Array is called as a function rather than as a constructor, it also creates and initializes a new Array object. Thus the function call Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.\nhttps://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor\n\n关于 `Object()` 与 `new Object()` 之间的差异，ES规范中说Object()会进行类型转换\n> The Object constructor is the %Object% intrinsic object and the initial value of the Object property of the global object. When called as a constructor it creates a new ordinary object. When Object is called as a function rather than as a constructor, it performs a type conversion.\nThe Object constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition.\nhttps://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor\n\n# The play() request was interrupted by a call to pause()\n做桌面通知的一个需求，需要自定义桌面通知是否带有提示音，使用的是h5的Notification API，在api 的 silent配置项不work的时候自定义new Audio在有新消息的时候触发，然后在延时器中关闭的时候出现以下错误：\n*The play() request was interrupted by a call to pause()*\n\ngoogle后发现 *Moreover since Chrome 50, a play() call on an a or element returns a Promise*\n\nplay是一个异步函数， 返回一个promise\n**所以正确的方式应该先获取这个promise， 在then回调中安全的将其pause掉**\n\n```js\nconst playSound = () => {\n  let timer = null\n  const audio = new Audio(fileUrl)\n  const playPromise = audio.play()\n  if (playPromise !== undefined) {\n    playPromise.then(() => {\n      timer = setTimeout(() => {\n        audio.pause()\n        clearTimeout(timer)\n      }, 2000)\n    }).catch(err => {\n      console.log(err)\n    })\n  }\n}\n```\n> [https://developers.google.com/web/updates/2017/06/play-request-was-interrupted](https://developers.google.com/web/updates/2017/06/play-request-was-interrupted)\n\n# 实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行\n参考别人的实现看到里面有关resolve 和 reject 函数内部的代码异步执行 却没有解释原因\n> [剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类](https://github.com/xieranmaya/blog/issues/3)\n\n```js\nfunction resolve(value) {\n  setTimeout(function () {\n      if(self.status === 'pending') {\n          self.status = 'resolved';\n          self.data = value;\n          for(var i = 0; i < self.onResolvedCallback.length; i++) {\n              self.onResolvedCallback[i](value);\n          }\n      }\n  })\n}\n```\n以下为个人简单理解：\n\n举个例子：eventbus的实现\n在使用eventbus进行数据通信的时候，通常都是在一个地方emit事件名 在另外想要触发的地方on接收这个事件同时传入相应的回调，而这种使用方式很容易给小白造成一种误解：我使用emit派发，使用on来接收执行这个派发\n\n显然不是的\n自己封装一个简单的eventbus之后就会理解\nemit是静态的而on才是依赖收集的地方 这个顺序不能变----一定是先收集完依赖才可以派发\n\n所以对于promise的resolve和then之间是不是就可以理解为必须then收集依赖后才可以触发resolve这样resolve的参数才可以被then接收到（reject和catch同理）\n\n所以回到上面提出的resolve和reject函数内部为何一定要异步执行的问题\n\n首先涉及到一个初始化的机制\n\n假如是同步执行 resolve如果在new Promise时立即触发 此时是没有收集依赖函数的（then收集到的对应的微任务队列 `onResolvedCallback` 尚未执行）\n那么resolve中的数值无法被传递\n\n而如果加入异步（setTimeout）变为一次宏任务推入下次事件循环\n\n这样就确保了先收集了依赖再触发回调\n\n> [JS/Node事件循环](https://rollawaypoint.github.io/2019/03/07/writeSomething/EventLoop/)\n\n# 你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout\n#### setTimeout 定时器\n支持传递第三个以及之后参数作为第一个回调函数的参数\n```js\nconst delay = (fn, wait, ...args) => setTimeout(fn, wait, ...args)\n\ndelay(function(...args) { console.log(args)}, 1000, 1, 2, 3)\n```\n\n#### JSON.parse\n\nJSON.parse还可额外接受第二个处理函数 对原本生成的返回值进行修改\n\n#### JSON.stringify\n\nJSON.stringify可额外再接收两个参数\n* 第二个参数： 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化\n* 第三个参数：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格\n\n# Array.prototype.push.apply(obj, arr)\n_萌新日常问题_\n**今天看到之前写的一段代码大概为：**\n```js\nlet obj = {}\nlet arr = [1, 2, 3]\n\nArray.prototype.push.apply(obj, arr)\n```\n**最终的obj为：**\n```js\n{\n  0: 1,\n  1: 2,\n  2: 3\n}\n```\n那如果向一个map中push呢？\n```js\nlet map = new Map\nlet arr = [1, 2, 3]\n\nArray.prototype.push.apply(map, arr)\n```\n**最终的map为：**\n```js\nMap(0) {\n  0: 1,\n  1: 2,\n  2: 3,\n  length: 3,\n  size: 0,\n  [[Entries]]: Array(0),\n  length: 0\n}\n```\n依然是一放进对象方式放进了map，而map的entries是空的，length也为0，我知道map是通过实例化传入option或者通过set方法才可以设置键值对，那么为什么会有这样的输出呢？\n**Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢**\n----\n落后要挨打，不懂就要查？emmm，没google到...\n显然我对搜索引擎的应用远远不行\n落后要挨打，不懂就要问，菜鸡互啄之后：\n> 这个其实你可以看数组和对象的实现方式，map 和 obj 的实现是不一样的，而数组和 obj 的实现则是相似的\nobj 其实代表的应该是 record，而不是 dictionary，map 才是 dictionary，只要把 Object 当成 record 看，那它和数组就是一家人了\n所以可以试着在代码中做一点区分,map 对索引是有一些优化的，而 Object 对下标索引也有优化，唔，这种区分是指从代码编写者的角度来说的，record 和 dictionary 是两种很常见的数据结构，在不同语言中有不同的实现，比如 python 中的实现就是 tuple 和 map，这个其实可以结合着 v8 中对象模型的实现来理解，这就说来话长了\njs 就是动态类型，从类型角度来说没什么意义，更多的实现的角度来考虑，比如说：在 v8 中如果你的对象索引是数字，在访问的时候那就很快，这个就是 tuple 的特性，但是在 js 中就是 obj，当然 object 也能作为 dictionary 来用，但是这样访问的速度就很慢了，同理，js 数组中也可以存放不同类型的值，但是如果放同样类型的值，那利用偏移值访存就会很快\n\n所以 js 才专门出了一个 Map，也是希望规范这种使用，这种归纳是实现相关的\n\n*意思就是本质上其实数组与对象其实是同一个东西（实现方式一致），都是键值对组成的集合，只不过js中的数组将键以索引下标的形式展现而已*\n\n**什么是record类型?**\n> 记录(Record)类型类似于C语言中的结构数据类型，它把逻辑相关的、分离的、基本数据类型的变量组成一个整体存储起来，它必须包括至少一个标量型或RECORD数据类型的成员，称作PL/SQL RECORD的域(FIELD)，其作用是存放互不相同但逻辑相关的信息。在使用记录数据类型变量时，需要先在声明部分先定义记录的组成、记录的变量，然后在执行部分引用该记录变量本身或其中的成员\n\n\n\n.\n.\n.\n.\n.\n.\n未完待续...👏\n","source":"_posts/writeSomething/PayAttentionToThoseJs.md","raw":"---\ntitle: 你应该注意的那些JS（相关）\ntags:\n  - 你应该知道的\ndate: 2019-03-11 12:35:00\ncategories: 你应该知道的\n---\n记录基本的JS相关的使用或者遇到的issues\n持续更新👏\n<!-- more -->\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=1340842066&auto=1&height=66\"></iframe>\n*没有分类顺序可能杂乱😝*\n\n# 小数部分进行数学运算可能会生成过多的小数位\n很多人应该都遇到过类似的问题：`0.1 + 0.2 === 0.3` 返回值是 false，顿为惊叹\n在浏览器输入后发现 `0.1 + 0.2` 返回值是 `0.30000000000000004`(小数17位，<a href=\"#JS（Java）浮点数的数字长度\">关于这个</a>)\n查了一下找到了个解释：\n> Computer in dealing with digital mathematical operations (such as the decimal), its first converted to binary again, the decimal Numbers to binary may occur in the process of precision loss, can be used by toFixed and round method comprehensive to solve this problem.\n\n计算机是只认识二进制的，数学运算中进制转换的过程可能会发现精度损失的情况\n\n*可以使用 `toFixed` 或者 `round` 方法兼容处理*\n\n# JS（Java）浮点数的数字长度\nECMAScript Number（Java： float | double） 是使用 IEEE754 格式来表示整数和浮点数，浮点数的最高精度为 17 位小数\n\n*`Number.EPSILON`(1 与大于 1 的最小浮点数之间的差, 换句话说其实就是JS支持的最小精度) 值为2^-52，约等于2.2e-16，浮点数运算的过程中，如果误差小于这个数值，可以认为误差是不存在的，所以说第17位上的小数，其实没有意义*\n\n# JS箭轴函数\n如下代码：\n```js\nfunction make () {\n  return () => console.log(this)\n}\nconst testFunc = make.call({ name:'foo' });\n\ntestFunc() // { name: \"foo\" } \ntestFunc.call({ name:'bar' }); // { name: \"foo\" }\n```\n可以看到箭头函数在定义之后，this 就不会发生改变了，无论用什么样的方式调用它，this 都不会改变\n\n原因：箭头函数不会自动绑定局部变量，如this，arguments，super(ES6)，new.target(ES6)等\n\n所以箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用\n\n箭轴函数有如下等特性：\n- 箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象\n- 箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误\n- 箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替\n- 不可以使用yield命令，因此箭头函数不能用作Generator函数\n\n# 关于创建vue中的vnode(virture dom)\n公司之前有个文件上传组件，由于每次都会创建一个实例dom导致一些不可预知的样式错误，于是同事改用vnode来处理这部分\n\n拿来主义：\n![virturedom](/virturedom.png)\n\n**Vue2.x版本中VNode属性：**\n- tag:当前节点标签名\n- data：当前节点数据对象\n- children：子节点数组\n- text：当前节点文本\n- elm：当前虚拟节点对应的真实dom节点\n- ns：节点的namespace( 名称空间)\n- content：编译作用域\n- functionalContext：函数化组件的作用域，即全局上下文\n- key：节点标识，有利于patch优化\n- componentOptions：创建组件实例时的options\n- child：当前节点对应的组件实例\n- parent：组件的占位节点\n- raw：原始html\n- isStatic：是否是静态节点\n- isRootInsert：是否作为跟节点插入，若被包裹的节点，该属性值为false\n- isComment：是否为注释节点\n- isCloned：是否为克隆节点\n- isOnce：是否只改变(渲染)一次，或是否有v-once指令\n其中这里面又有几种VNode类型\n- TextVNode：文本节点\n- ElementVNode：普通元素节点\n- ComponentVNode：组件节点\n- EmptyVNode：空节点，或者说是没有内容的注释节点\n- CloneVNode：克隆节点，可以是以上任意类型节\n\n什么时候用虚拟dom才比较好呢？其实我们使用的单文件组件就已经够好了。但是当某些代码冗余的时候如果写单文件组件的话会有好多重复的内容\n\n接下来介绍其核心函数createElement(h)：\ncreateElement接收3个参数：\n- 第一个参数可以是HTML标签名，组件或者函数都可以；此参数是必须的\n- 第二个为数据对象（可选）\n- 第三个为子节点（可选）\n\n**附上简单demo：**\n```js\nconst Instance = new Vue({\n  data: Object.assign({}, _props, {\n\n  }),\n  render(h) {\n    const vnode = h('input', {\n      attrs: {\n        type: 'file',\n        accept: 'image/*'\n      },\n      style: {\n        display: 'none'\n      },\n      ref: 'tuhu_upload_input'\n    })\n\n    return h('div', {\n      class: 'tuhu_upload_layout'\n    }, [vnode])\n  }\n})\n```\n\n# 使用instanceof判断构造函数的问题\n测试代码：\n```js\nfunction A() {}\n\nvar a = new A\nconsole.log(a instanceof A) // true\nconsole.log(a instanceof Object) // true\n\nvar obj = {}\nA.prototype = obj\n// a.__proto__ = obj // console.log(a instanceof A) // true\nvar a2 = new A\nconsole.log(a2 instanceof A) // true\nconsole.log(a instanceof A) // false\n\nconsole.log(a instanceof Object) // true\n```\n所以综上所述 instanceof 并不能从字面意思来判断谁是否是谁的实例对象\n鱼泡泡的面试题：instanceof 判断构造函数可能会出现不准确的情况吗？如 `const arr = []; arr instanceof Array === false`。大都说不出其中几何, 其实同样只需要更改 `arr.__proto__ = Object // Number etc.`\n\ninstanceof本意：\n> MDN: The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object.\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof](url)\n\n**就是说 instanceof 是用来判断 A.prototype 是否存在于参数 a 的原型链上**\n\n所以当A的prototype被指向任意一个其他对象的时候 A.prototype是不在a的原型链上的\n\na所在的原型链: a ==> a.__proto__ ==> Object.prototype ==> null\n\na2所在的原型链: a2 ==> obj ==> Object.prototype ==> null\n\n所以此时如果赋值a.__proto__ = obj，a instanceof A 同样会返回true\n\n*JS是一门基于原型的语言，而原型是动态的并非一定不变所以会有上述情况*\n\n# 将function声明的函数的函数式调用改为new 关键字调用\nes6的class声明类的方式是必须通过new关键字进行调用的\n\n而传统的利用function关键字声明的构造函数如何避免被函数式调用呢？或者说就算是函数式调用但是依然想要生成实例对象呢\n很简单 判断constructor即可\n\n```js\n// eg:\n\nfunction A() {\n  if (this.constructor !== arguments.callee) {\n    return new A\n  }\n  this.name = 'chris'\n  this.age = 23\n  this.job = function() {\n    console.log('A front-end engineer')\n  }\n  A.work = function() {\n    console.log('working hard')\n  }\n}\nA().job() // that's all\n\n```\n补充：\n*`Array()` 和 `new Array()` 是完全一致的*\n> The Array constructor is the %Array% intrinsic object and the initial value of the Array property of the global object. When called as a constructor it creates and initializes a new exotic Array object. When Array is called as a function rather than as a constructor, it also creates and initializes a new Array object. Thus the function call Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.\nhttps://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor\n\n关于 `Object()` 与 `new Object()` 之间的差异，ES规范中说Object()会进行类型转换\n> The Object constructor is the %Object% intrinsic object and the initial value of the Object property of the global object. When called as a constructor it creates a new ordinary object. When Object is called as a function rather than as a constructor, it performs a type conversion.\nThe Object constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition.\nhttps://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor\n\n# The play() request was interrupted by a call to pause()\n做桌面通知的一个需求，需要自定义桌面通知是否带有提示音，使用的是h5的Notification API，在api 的 silent配置项不work的时候自定义new Audio在有新消息的时候触发，然后在延时器中关闭的时候出现以下错误：\n*The play() request was interrupted by a call to pause()*\n\ngoogle后发现 *Moreover since Chrome 50, a play() call on an a or element returns a Promise*\n\nplay是一个异步函数， 返回一个promise\n**所以正确的方式应该先获取这个promise， 在then回调中安全的将其pause掉**\n\n```js\nconst playSound = () => {\n  let timer = null\n  const audio = new Audio(fileUrl)\n  const playPromise = audio.play()\n  if (playPromise !== undefined) {\n    playPromise.then(() => {\n      timer = setTimeout(() => {\n        audio.pause()\n        clearTimeout(timer)\n      }, 2000)\n    }).catch(err => {\n      console.log(err)\n    })\n  }\n}\n```\n> [https://developers.google.com/web/updates/2017/06/play-request-was-interrupted](https://developers.google.com/web/updates/2017/06/play-request-was-interrupted)\n\n# 实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行\n参考别人的实现看到里面有关resolve 和 reject 函数内部的代码异步执行 却没有解释原因\n> [剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类](https://github.com/xieranmaya/blog/issues/3)\n\n```js\nfunction resolve(value) {\n  setTimeout(function () {\n      if(self.status === 'pending') {\n          self.status = 'resolved';\n          self.data = value;\n          for(var i = 0; i < self.onResolvedCallback.length; i++) {\n              self.onResolvedCallback[i](value);\n          }\n      }\n  })\n}\n```\n以下为个人简单理解：\n\n举个例子：eventbus的实现\n在使用eventbus进行数据通信的时候，通常都是在一个地方emit事件名 在另外想要触发的地方on接收这个事件同时传入相应的回调，而这种使用方式很容易给小白造成一种误解：我使用emit派发，使用on来接收执行这个派发\n\n显然不是的\n自己封装一个简单的eventbus之后就会理解\nemit是静态的而on才是依赖收集的地方 这个顺序不能变----一定是先收集完依赖才可以派发\n\n所以对于promise的resolve和then之间是不是就可以理解为必须then收集依赖后才可以触发resolve这样resolve的参数才可以被then接收到（reject和catch同理）\n\n所以回到上面提出的resolve和reject函数内部为何一定要异步执行的问题\n\n首先涉及到一个初始化的机制\n\n假如是同步执行 resolve如果在new Promise时立即触发 此时是没有收集依赖函数的（then收集到的对应的微任务队列 `onResolvedCallback` 尚未执行）\n那么resolve中的数值无法被传递\n\n而如果加入异步（setTimeout）变为一次宏任务推入下次事件循环\n\n这样就确保了先收集了依赖再触发回调\n\n> [JS/Node事件循环](https://rollawaypoint.github.io/2019/03/07/writeSomething/EventLoop/)\n\n# 你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout\n#### setTimeout 定时器\n支持传递第三个以及之后参数作为第一个回调函数的参数\n```js\nconst delay = (fn, wait, ...args) => setTimeout(fn, wait, ...args)\n\ndelay(function(...args) { console.log(args)}, 1000, 1, 2, 3)\n```\n\n#### JSON.parse\n\nJSON.parse还可额外接受第二个处理函数 对原本生成的返回值进行修改\n\n#### JSON.stringify\n\nJSON.stringify可额外再接收两个参数\n* 第二个参数： 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化\n* 第三个参数：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格\n\n# Array.prototype.push.apply(obj, arr)\n_萌新日常问题_\n**今天看到之前写的一段代码大概为：**\n```js\nlet obj = {}\nlet arr = [1, 2, 3]\n\nArray.prototype.push.apply(obj, arr)\n```\n**最终的obj为：**\n```js\n{\n  0: 1,\n  1: 2,\n  2: 3\n}\n```\n那如果向一个map中push呢？\n```js\nlet map = new Map\nlet arr = [1, 2, 3]\n\nArray.prototype.push.apply(map, arr)\n```\n**最终的map为：**\n```js\nMap(0) {\n  0: 1,\n  1: 2,\n  2: 3,\n  length: 3,\n  size: 0,\n  [[Entries]]: Array(0),\n  length: 0\n}\n```\n依然是一放进对象方式放进了map，而map的entries是空的，length也为0，我知道map是通过实例化传入option或者通过set方法才可以设置键值对，那么为什么会有这样的输出呢？\n**Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢**\n----\n落后要挨打，不懂就要查？emmm，没google到...\n显然我对搜索引擎的应用远远不行\n落后要挨打，不懂就要问，菜鸡互啄之后：\n> 这个其实你可以看数组和对象的实现方式，map 和 obj 的实现是不一样的，而数组和 obj 的实现则是相似的\nobj 其实代表的应该是 record，而不是 dictionary，map 才是 dictionary，只要把 Object 当成 record 看，那它和数组就是一家人了\n所以可以试着在代码中做一点区分,map 对索引是有一些优化的，而 Object 对下标索引也有优化，唔，这种区分是指从代码编写者的角度来说的，record 和 dictionary 是两种很常见的数据结构，在不同语言中有不同的实现，比如 python 中的实现就是 tuple 和 map，这个其实可以结合着 v8 中对象模型的实现来理解，这就说来话长了\njs 就是动态类型，从类型角度来说没什么意义，更多的实现的角度来考虑，比如说：在 v8 中如果你的对象索引是数字，在访问的时候那就很快，这个就是 tuple 的特性，但是在 js 中就是 obj，当然 object 也能作为 dictionary 来用，但是这样访问的速度就很慢了，同理，js 数组中也可以存放不同类型的值，但是如果放同样类型的值，那利用偏移值访存就会很快\n\n所以 js 才专门出了一个 Map，也是希望规范这种使用，这种归纳是实现相关的\n\n*意思就是本质上其实数组与对象其实是同一个东西（实现方式一致），都是键值对组成的集合，只不过js中的数组将键以索引下标的形式展现而已*\n\n**什么是record类型?**\n> 记录(Record)类型类似于C语言中的结构数据类型，它把逻辑相关的、分离的、基本数据类型的变量组成一个整体存储起来，它必须包括至少一个标量型或RECORD数据类型的成员，称作PL/SQL RECORD的域(FIELD)，其作用是存放互不相同但逻辑相关的信息。在使用记录数据类型变量时，需要先在声明部分先定义记录的组成、记录的变量，然后在执行部分引用该记录变量本身或其中的成员\n\n\n\n.\n.\n.\n.\n.\n.\n未完待续...👏\n","slug":"writeSomething/PayAttentionToThoseJs","published":1,"updated":"2019-03-14T06:26:08.013Z","_id":"cjtbdahhn000dzk48lmh3g8dq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>记录基本的JS相关的使用或者遇到的issues<br>持续更新👏<br><a id=\"more\"></a></p>\n<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=1340842066&auto=1&height=66\"></iframe><br><em>没有分类顺序可能杂乱😝</em></p>\n<h1 id=\"小数部分进行数学运算可能会生成过多的小数位\"><a href=\"#小数部分进行数学运算可能会生成过多的小数位\" class=\"headerlink\" title=\"小数部分进行数学运算可能会生成过多的小数位\"></a>小数部分进行数学运算可能会生成过多的小数位</h1><p>很多人应该都遇到过类似的问题：<code>0.1 + 0.2 === 0.3</code> 返回值是 false，顿为惊叹<br>在浏览器输入后发现 <code>0.1 + 0.2</code> 返回值是 <code>0.30000000000000004</code>(小数17位，<a href=\"#JS（Java）浮点数的数字长度\">关于这个</a>)<br>查了一下找到了个解释：</p>\n<blockquote>\n<p>Computer in dealing with digital mathematical operations (such as the decimal), its first converted to binary again, the decimal Numbers to binary may occur in the process of precision loss, can be used by toFixed and round method comprehensive to solve this problem.</p>\n</blockquote>\n<p>计算机是只认识二进制的，数学运算中进制转换的过程可能会发现精度损失的情况</p>\n<p><em>可以使用 <code>toFixed</code> 或者 <code>round</code> 方法兼容处理</em></p>\n<h1 id=\"JS（Java）浮点数的数字长度\"><a href=\"#JS（Java）浮点数的数字长度\" class=\"headerlink\" title=\"JS（Java）浮点数的数字长度\"></a>JS（Java）浮点数的数字长度</h1><p>ECMAScript Number（Java： float | double） 是使用 IEEE754 格式来表示整数和浮点数，浮点数的最高精度为 17 位小数</p>\n<p><em><code>Number.EPSILON</code>(1 与大于 1 的最小浮点数之间的差, 换句话说其实就是JS支持的最小精度) 值为2^-52，约等于2.2e-16，浮点数运算的过程中，如果误差小于这个数值，可以认为误差是不存在的，所以说第17位上的小数，其实没有意义</em></p>\n<h1 id=\"JS箭轴函数\"><a href=\"#JS箭轴函数\" class=\"headerlink\" title=\"JS箭轴函数\"></a>JS箭轴函数</h1><p>如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> testFunc = make.call(&#123; <span class=\"attr\">name</span>:<span class=\"string\">'foo'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">testFunc() <span class=\"comment\">// &#123; name: \"foo\" &#125; </span></span><br><span class=\"line\">testFunc.call(&#123; <span class=\"attr\">name</span>:<span class=\"string\">'bar'</span> &#125;); <span class=\"comment\">// &#123; name: \"foo\" &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到箭头函数在定义之后，this 就不会发生改变了，无论用什么样的方式调用它，this 都不会改变</p>\n<p>原因：箭头函数不会自动绑定局部变量，如this，arguments，super(ES6)，new.target(ES6)等</p>\n<p>所以箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用</p>\n<p>箭轴函数有如下等特性：</p>\n<ul>\n<li>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象</li>\n<li>箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误</li>\n<li>箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替</li>\n<li>不可以使用yield命令，因此箭头函数不能用作Generator函数</li>\n</ul>\n<h1 id=\"关于创建vue中的vnode-virture-dom\"><a href=\"#关于创建vue中的vnode-virture-dom\" class=\"headerlink\" title=\"关于创建vue中的vnode(virture dom)\"></a>关于创建vue中的vnode(virture dom)</h1><p>公司之前有个文件上传组件，由于每次都会创建一个实例dom导致一些不可预知的样式错误，于是同事改用vnode来处理这部分</p>\n<p>拿来主义：<br><img src=\"/2019/03/11/writeSomething/PayAttentionToThoseJs/virturedom.png\" alt=\"virturedom\"></p>\n<p><strong>Vue2.x版本中VNode属性：</strong></p>\n<ul>\n<li>tag:当前节点标签名</li>\n<li>data：当前节点数据对象</li>\n<li>children：子节点数组</li>\n<li>text：当前节点文本</li>\n<li>elm：当前虚拟节点对应的真实dom节点</li>\n<li>ns：节点的namespace( 名称空间)</li>\n<li>content：编译作用域</li>\n<li>functionalContext：函数化组件的作用域，即全局上下文</li>\n<li>key：节点标识，有利于patch优化</li>\n<li>componentOptions：创建组件实例时的options</li>\n<li>child：当前节点对应的组件实例</li>\n<li>parent：组件的占位节点</li>\n<li>raw：原始html</li>\n<li>isStatic：是否是静态节点</li>\n<li>isRootInsert：是否作为跟节点插入，若被包裹的节点，该属性值为false</li>\n<li>isComment：是否为注释节点</li>\n<li>isCloned：是否为克隆节点</li>\n<li>isOnce：是否只改变(渲染)一次，或是否有v-once指令<br>其中这里面又有几种VNode类型</li>\n<li>TextVNode：文本节点</li>\n<li>ElementVNode：普通元素节点</li>\n<li>ComponentVNode：组件节点</li>\n<li>EmptyVNode：空节点，或者说是没有内容的注释节点</li>\n<li>CloneVNode：克隆节点，可以是以上任意类型节</li>\n</ul>\n<p>什么时候用虚拟dom才比较好呢？其实我们使用的单文件组件就已经够好了。但是当某些代码冗余的时候如果写单文件组件的话会有好多重复的内容</p>\n<p>接下来介绍其核心函数createElement(h)：<br>createElement接收3个参数：</p>\n<ul>\n<li>第一个参数可以是HTML标签名，组件或者函数都可以；此参数是必须的</li>\n<li>第二个为数据对象（可选）</li>\n<li>第三个为子节点（可选）</li>\n</ul>\n<p><strong>附上简单demo：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Instance = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: <span class=\"built_in\">Object</span>.assign(&#123;&#125;, _props, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  render(h) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> vnode = h(<span class=\"string\">'input'</span>, &#123;</span><br><span class=\"line\">      attrs: &#123;</span><br><span class=\"line\">        type: <span class=\"string\">'file'</span>,</span><br><span class=\"line\">        accept: <span class=\"string\">'image/*'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      style: &#123;</span><br><span class=\"line\">        display: <span class=\"string\">'none'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      ref: <span class=\"string\">'tuhu_upload_input'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> h(<span class=\"string\">'div'</span>, &#123;</span><br><span class=\"line\">      class: 'tuhu_upload_layout'</span><br><span class=\"line\">    &#125;, [vnode])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"使用instanceof判断构造函数的问题\"><a href=\"#使用instanceof判断构造函数的问题\" class=\"headerlink\" title=\"使用instanceof判断构造函数的问题\"></a>使用instanceof判断构造函数的问题</h1><p>测试代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;</span><br><span class=\"line\">A.prototype = obj</span><br><span class=\"line\"><span class=\"comment\">// a.__proto__ = obj // console.log(a instanceof A) // true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a2 = <span class=\"keyword\">new</span> A</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a2 <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>所以综上所述 instanceof 并不能从字面意思来判断谁是否是谁的实例对象<br>鱼泡泡的面试题：instanceof 判断构造函数可能会出现不准确的情况吗？如 <code>const arr = []; arr instanceof Array === false</code>。大都说不出其中几何, 其实同样只需要更改 <code>arr.__proto__ = Object // Number etc.</code></p>\n<p>instanceof本意：</p>\n<blockquote>\n<p>MDN: The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object.<br><a href=\"url\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof</a></p>\n</blockquote>\n<p><strong>就是说 instanceof 是用来判断 A.prototype 是否存在于参数 a 的原型链上</strong></p>\n<p>所以当A的prototype被指向任意一个其他对象的时候 A.prototype是不在a的原型链上的</p>\n<p>a所在的原型链: a ==&gt; a.<strong>proto</strong> ==&gt; Object.prototype ==&gt; null</p>\n<p>a2所在的原型链: a2 ==&gt; obj ==&gt; Object.prototype ==&gt; null</p>\n<p>所以此时如果赋值a.<strong>proto</strong> = obj，a instanceof A 同样会返回true</p>\n<p><em>JS是一门基于原型的语言，而原型是动态的并非一定不变所以会有上述情况</em></p>\n<h1 id=\"将function声明的函数的函数式调用改为new-关键字调用\"><a href=\"#将function声明的函数的函数式调用改为new-关键字调用\" class=\"headerlink\" title=\"将function声明的函数的函数式调用改为new 关键字调用\"></a>将function声明的函数的函数式调用改为new 关键字调用</h1><p>es6的class声明类的方式是必须通过new关键字进行调用的</p>\n<p>而传统的利用function关键字声明的构造函数如何避免被函数式调用呢？或者说就算是函数式调用但是依然想要生成实例对象呢<br>很简单 判断constructor即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eg:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.constructor !== <span class=\"built_in\">arguments</span>.callee) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'chris'</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">23</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'A front-end engineer'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  A.work = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'working hard'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A().job() <span class=\"comment\">// that's all</span></span><br></pre></td></tr></table></figure>\n<p>补充：<br><em><code>Array()</code> 和 <code>new Array()</code> 是完全一致的</em></p>\n<blockquote>\n<p>The Array constructor is the %Array% intrinsic object and the initial value of the Array property of the global object. When called as a constructor it creates and initializes a new exotic Array object. When Array is called as a function rather than as a constructor, it also creates and initializes a new Array object. Thus the function call Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.<br><a href=\"https://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor\" target=\"_blank\" rel=\"noopener\">https://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor</a></p>\n</blockquote>\n<p>关于 <code>Object()</code> 与 <code>new Object()</code> 之间的差异，ES规范中说Object()会进行类型转换</p>\n<blockquote>\n<p>The Object constructor is the %Object% intrinsic object and the initial value of the Object property of the global object. When called as a constructor it creates a new ordinary object. When Object is called as a function rather than as a constructor, it performs a type conversion.<br>The Object constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition.<br><a href=\"https://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor\" target=\"_blank\" rel=\"noopener\">https://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor</a></p>\n</blockquote>\n<h1 id=\"The-play-request-was-interrupted-by-a-call-to-pause\"><a href=\"#The-play-request-was-interrupted-by-a-call-to-pause\" class=\"headerlink\" title=\"The play() request was interrupted by a call to pause()\"></a>The play() request was interrupted by a call to pause()</h1><p>做桌面通知的一个需求，需要自定义桌面通知是否带有提示音，使用的是h5的Notification API，在api 的 silent配置项不work的时候自定义new Audio在有新消息的时候触发，然后在延时器中关闭的时候出现以下错误：<br><em>The play() request was interrupted by a call to pause()</em></p>\n<p>google后发现 <em>Moreover since Chrome 50, a play() call on an a or element returns a Promise</em></p>\n<p>play是一个异步函数， 返回一个promise<br><strong>所以正确的方式应该先获取这个promise， 在then回调中安全的将其pause掉</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> playSound = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> audio = <span class=\"keyword\">new</span> Audio(fileUrl)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> playPromise = audio.play()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (playPromise !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    playPromise.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        audio.pause()</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">      &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">    &#125;).catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://developers.google.com/web/updates/2017/06/play-request-was-interrupted\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/updates/2017/06/play-request-was-interrupted</a></p>\n</blockquote>\n<h1 id=\"实现-Promise-的-resolve-和-reject-函数时内部为何要异步执行\"><a href=\"#实现-Promise-的-resolve-和-reject-函数时内部为何要异步执行\" class=\"headerlink\" title=\"实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行\"></a>实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行</h1><p>参考别人的实现看到里面有关resolve 和 reject 函数内部的代码异步执行 却没有解释原因</p>\n<blockquote>\n<p><a href=\"https://github.com/xieranmaya/blog/issues/3\" target=\"_blank\" rel=\"noopener\">剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类</a></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">          self.status = <span class=\"string\">'resolved'</span>;</span><br><span class=\"line\">          self.data = value;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class=\"line\">              self.onResolvedCallback[i](value);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下为个人简单理解：</p>\n<p>举个例子：eventbus的实现<br>在使用eventbus进行数据通信的时候，通常都是在一个地方emit事件名 在另外想要触发的地方on接收这个事件同时传入相应的回调，而这种使用方式很容易给小白造成一种误解：我使用emit派发，使用on来接收执行这个派发</p>\n<p>显然不是的<br>自己封装一个简单的eventbus之后就会理解<br>emit是静态的而on才是依赖收集的地方 这个顺序不能变—-一定是先收集完依赖才可以派发</p>\n<p>所以对于promise的resolve和then之间是不是就可以理解为必须then收集依赖后才可以触发resolve这样resolve的参数才可以被then接收到（reject和catch同理）</p>\n<p>所以回到上面提出的resolve和reject函数内部为何一定要异步执行的问题</p>\n<p>首先涉及到一个初始化的机制</p>\n<p>假如是同步执行 resolve如果在new Promise时立即触发 此时是没有收集依赖函数的（then收集到的对应的微任务队列 <code>onResolvedCallback</code> 尚未执行）<br>那么resolve中的数值无法被传递</p>\n<p>而如果加入异步（setTimeout）变为一次宏任务推入下次事件循环</p>\n<p>这样就确保了先收集了依赖再触发回调</p>\n<blockquote>\n<p><a href=\"https://rollawaypoint.github.io/2019/03/07/writeSomething/EventLoop/\">JS/Node事件循环</a></p>\n</blockquote>\n<h1 id=\"你不知道的原生方法更多使用方式-JSON-parse、JSON-stringify、setTimeout\"><a href=\"#你不知道的原生方法更多使用方式-JSON-parse、JSON-stringify、setTimeout\" class=\"headerlink\" title=\"你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout\"></a>你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout</h1><h4 id=\"setTimeout-定时器\"><a href=\"#setTimeout-定时器\" class=\"headerlink\" title=\"setTimeout 定时器\"></a>setTimeout 定时器</h4><p>支持传递第三个以及之后参数作为第一个回调函数的参数<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\">(<span class=\"params\">fn, wait, ...args</span>) =&gt;</span> setTimeout(fn, wait, ...args)</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123; <span class=\"built_in\">console</span>.log(args)&#125;, <span class=\"number\">1000</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JSON-parse\"><a href=\"#JSON-parse\" class=\"headerlink\" title=\"JSON.parse\"></a>JSON.parse</h4><p>JSON.parse还可额外接受第二个处理函数 对原本生成的返回值进行修改</p>\n<h4 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify\"></a>JSON.stringify</h4><p>JSON.stringify可额外再接收两个参数</p>\n<ul>\n<li>第二个参数： 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化</li>\n<li>第三个参数：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格</li>\n</ul>\n<h1 id=\"Array-prototype-push-apply-obj-arr\"><a href=\"#Array-prototype-push-apply-obj-arr\" class=\"headerlink\" title=\"Array.prototype.push.apply(obj, arr)\"></a>Array.prototype.push.apply(obj, arr)</h1><p><em>萌新日常问题</em><br><strong>今天看到之前写的一段代码大概为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(obj, arr)</span><br></pre></td></tr></table></figure></p>\n<p><strong>最终的obj为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那如果向一个map中push呢？<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(map, arr)</span><br></pre></td></tr></table></figure></p>\n<p><strong>最终的map为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span>(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span>,</span><br><span class=\"line\">  size: <span class=\"number\">0</span>,</span><br><span class=\"line\">  [[Entries]]: <span class=\"built_in\">Array</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">  length: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>依然是一放进对象方式放进了map，而map的entries是空的，length也为0，我知道map是通过实例化传入option或者通过set方法才可以设置键值对，那么为什么会有这样的输出呢？</p>\n<h2 id=\"Q-为什么会以数组下标和值组成键值对的方式放进这个对象呢\"><a href=\"#Q-为什么会以数组下标和值组成键值对的方式放进这个对象呢\" class=\"headerlink\" title=\"Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢\"></a><strong>Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢</strong></h2><p>落后要挨打，不懂就要查？emmm，没google到…<br>显然我对搜索引擎的应用远远不行<br>落后要挨打，不懂就要问，菜鸡互啄之后：</p>\n<blockquote>\n<p>这个其实你可以看数组和对象的实现方式，map 和 obj 的实现是不一样的，而数组和 obj 的实现则是相似的<br>obj 其实代表的应该是 record，而不是 dictionary，map 才是 dictionary，只要把 Object 当成 record 看，那它和数组就是一家人了<br>所以可以试着在代码中做一点区分,map 对索引是有一些优化的，而 Object 对下标索引也有优化，唔，这种区分是指从代码编写者的角度来说的，record 和 dictionary 是两种很常见的数据结构，在不同语言中有不同的实现，比如 python 中的实现就是 tuple 和 map，这个其实可以结合着 v8 中对象模型的实现来理解，这就说来话长了<br>js 就是动态类型，从类型角度来说没什么意义，更多的实现的角度来考虑，比如说：在 v8 中如果你的对象索引是数字，在访问的时候那就很快，这个就是 tuple 的特性，但是在 js 中就是 obj，当然 object 也能作为 dictionary 来用，但是这样访问的速度就很慢了，同理，js 数组中也可以存放不同类型的值，但是如果放同样类型的值，那利用偏移值访存就会很快</p>\n</blockquote>\n<p>所以 js 才专门出了一个 Map，也是希望规范这种使用，这种归纳是实现相关的</p>\n<p><em>意思就是本质上其实数组与对象其实是同一个东西（实现方式一致），都是键值对组成的集合，只不过js中的数组将键以索引下标的形式展现而已</em></p>\n<p><strong>什么是record类型?</strong></p>\n<blockquote>\n<p>记录(Record)类型类似于C语言中的结构数据类型，它把逻辑相关的、分离的、基本数据类型的变量组成一个整体存储起来，它必须包括至少一个标量型或RECORD数据类型的成员，称作PL/SQL RECORD的域(FIELD)，其作用是存放互不相同但逻辑相关的信息。在使用记录数据类型变量时，需要先在声明部分先定义记录的组成、记录的变量，然后在执行部分引用该记录变量本身或其中的成员</p>\n</blockquote>\n<p>.<br>.<br>.<br>.<br>.<br>.<br>未完待续…👏</p>\n","site":{"data":{}},"excerpt":"<p>记录基本的JS相关的使用或者遇到的issues<br>持续更新👏<br></p>","more":"<p></p>\n<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=1340842066&auto=1&height=66\"></iframe><br><em>没有分类顺序可能杂乱😝</em></p>\n<h1 id=\"小数部分进行数学运算可能会生成过多的小数位\"><a href=\"#小数部分进行数学运算可能会生成过多的小数位\" class=\"headerlink\" title=\"小数部分进行数学运算可能会生成过多的小数位\"></a>小数部分进行数学运算可能会生成过多的小数位</h1><p>很多人应该都遇到过类似的问题：<code>0.1 + 0.2 === 0.3</code> 返回值是 false，顿为惊叹<br>在浏览器输入后发现 <code>0.1 + 0.2</code> 返回值是 <code>0.30000000000000004</code>(小数17位，<a href=\"#JS（Java）浮点数的数字长度\">关于这个</a>)<br>查了一下找到了个解释：</p>\n<blockquote>\n<p>Computer in dealing with digital mathematical operations (such as the decimal), its first converted to binary again, the decimal Numbers to binary may occur in the process of precision loss, can be used by toFixed and round method comprehensive to solve this problem.</p>\n</blockquote>\n<p>计算机是只认识二进制的，数学运算中进制转换的过程可能会发现精度损失的情况</p>\n<p><em>可以使用 <code>toFixed</code> 或者 <code>round</code> 方法兼容处理</em></p>\n<h1 id=\"JS（Java）浮点数的数字长度\"><a href=\"#JS（Java）浮点数的数字长度\" class=\"headerlink\" title=\"JS（Java）浮点数的数字长度\"></a>JS（Java）浮点数的数字长度</h1><p>ECMAScript Number（Java： float | double） 是使用 IEEE754 格式来表示整数和浮点数，浮点数的最高精度为 17 位小数</p>\n<p><em><code>Number.EPSILON</code>(1 与大于 1 的最小浮点数之间的差, 换句话说其实就是JS支持的最小精度) 值为2^-52，约等于2.2e-16，浮点数运算的过程中，如果误差小于这个数值，可以认为误差是不存在的，所以说第17位上的小数，其实没有意义</em></p>\n<h1 id=\"JS箭轴函数\"><a href=\"#JS箭轴函数\" class=\"headerlink\" title=\"JS箭轴函数\"></a>JS箭轴函数</h1><p>如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> testFunc = make.call(&#123; <span class=\"attr\">name</span>:<span class=\"string\">'foo'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">testFunc() <span class=\"comment\">// &#123; name: \"foo\" &#125; </span></span><br><span class=\"line\">testFunc.call(&#123; <span class=\"attr\">name</span>:<span class=\"string\">'bar'</span> &#125;); <span class=\"comment\">// &#123; name: \"foo\" &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到箭头函数在定义之后，this 就不会发生改变了，无论用什么样的方式调用它，this 都不会改变</p>\n<p>原因：箭头函数不会自动绑定局部变量，如this，arguments，super(ES6)，new.target(ES6)等</p>\n<p>所以箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用</p>\n<p>箭轴函数有如下等特性：</p>\n<ul>\n<li>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象</li>\n<li>箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误</li>\n<li>箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替</li>\n<li>不可以使用yield命令，因此箭头函数不能用作Generator函数</li>\n</ul>\n<h1 id=\"关于创建vue中的vnode-virture-dom\"><a href=\"#关于创建vue中的vnode-virture-dom\" class=\"headerlink\" title=\"关于创建vue中的vnode(virture dom)\"></a>关于创建vue中的vnode(virture dom)</h1><p>公司之前有个文件上传组件，由于每次都会创建一个实例dom导致一些不可预知的样式错误，于是同事改用vnode来处理这部分</p>\n<p>拿来主义：<br><img src=\"/2019/03/11/writeSomething/PayAttentionToThoseJs/virturedom.png\" alt=\"virturedom\"></p>\n<p><strong>Vue2.x版本中VNode属性：</strong></p>\n<ul>\n<li>tag:当前节点标签名</li>\n<li>data：当前节点数据对象</li>\n<li>children：子节点数组</li>\n<li>text：当前节点文本</li>\n<li>elm：当前虚拟节点对应的真实dom节点</li>\n<li>ns：节点的namespace( 名称空间)</li>\n<li>content：编译作用域</li>\n<li>functionalContext：函数化组件的作用域，即全局上下文</li>\n<li>key：节点标识，有利于patch优化</li>\n<li>componentOptions：创建组件实例时的options</li>\n<li>child：当前节点对应的组件实例</li>\n<li>parent：组件的占位节点</li>\n<li>raw：原始html</li>\n<li>isStatic：是否是静态节点</li>\n<li>isRootInsert：是否作为跟节点插入，若被包裹的节点，该属性值为false</li>\n<li>isComment：是否为注释节点</li>\n<li>isCloned：是否为克隆节点</li>\n<li>isOnce：是否只改变(渲染)一次，或是否有v-once指令<br>其中这里面又有几种VNode类型</li>\n<li>TextVNode：文本节点</li>\n<li>ElementVNode：普通元素节点</li>\n<li>ComponentVNode：组件节点</li>\n<li>EmptyVNode：空节点，或者说是没有内容的注释节点</li>\n<li>CloneVNode：克隆节点，可以是以上任意类型节</li>\n</ul>\n<p>什么时候用虚拟dom才比较好呢？其实我们使用的单文件组件就已经够好了。但是当某些代码冗余的时候如果写单文件组件的话会有好多重复的内容</p>\n<p>接下来介绍其核心函数createElement(h)：<br>createElement接收3个参数：</p>\n<ul>\n<li>第一个参数可以是HTML标签名，组件或者函数都可以；此参数是必须的</li>\n<li>第二个为数据对象（可选）</li>\n<li>第三个为子节点（可选）</li>\n</ul>\n<p><strong>附上简单demo：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Instance = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: <span class=\"built_in\">Object</span>.assign(&#123;&#125;, _props, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  render(h) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> vnode = h(<span class=\"string\">'input'</span>, &#123;</span><br><span class=\"line\">      attrs: &#123;</span><br><span class=\"line\">        type: <span class=\"string\">'file'</span>,</span><br><span class=\"line\">        accept: <span class=\"string\">'image/*'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      style: &#123;</span><br><span class=\"line\">        display: <span class=\"string\">'none'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      ref: <span class=\"string\">'tuhu_upload_input'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> h(<span class=\"string\">'div'</span>, &#123;</span><br><span class=\"line\">      class: 'tuhu_upload_layout'</span><br><span class=\"line\">    &#125;, [vnode])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"使用instanceof判断构造函数的问题\"><a href=\"#使用instanceof判断构造函数的问题\" class=\"headerlink\" title=\"使用instanceof判断构造函数的问题\"></a>使用instanceof判断构造函数的问题</h1><p>测试代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;</span><br><span class=\"line\">A.prototype = obj</span><br><span class=\"line\"><span class=\"comment\">// a.__proto__ = obj // console.log(a instanceof A) // true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a2 = <span class=\"keyword\">new</span> A</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a2 <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> A) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>所以综上所述 instanceof 并不能从字面意思来判断谁是否是谁的实例对象<br>鱼泡泡的面试题：instanceof 判断构造函数可能会出现不准确的情况吗？如 <code>const arr = []; arr instanceof Array === false</code>。大都说不出其中几何, 其实同样只需要更改 <code>arr.__proto__ = Object // Number etc.</code></p>\n<p>instanceof本意：</p>\n<blockquote>\n<p>MDN: The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object.<br><a href=\"url\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof</a></p>\n</blockquote>\n<p><strong>就是说 instanceof 是用来判断 A.prototype 是否存在于参数 a 的原型链上</strong></p>\n<p>所以当A的prototype被指向任意一个其他对象的时候 A.prototype是不在a的原型链上的</p>\n<p>a所在的原型链: a ==&gt; a.<strong>proto</strong> ==&gt; Object.prototype ==&gt; null</p>\n<p>a2所在的原型链: a2 ==&gt; obj ==&gt; Object.prototype ==&gt; null</p>\n<p>所以此时如果赋值a.<strong>proto</strong> = obj，a instanceof A 同样会返回true</p>\n<p><em>JS是一门基于原型的语言，而原型是动态的并非一定不变所以会有上述情况</em></p>\n<h1 id=\"将function声明的函数的函数式调用改为new-关键字调用\"><a href=\"#将function声明的函数的函数式调用改为new-关键字调用\" class=\"headerlink\" title=\"将function声明的函数的函数式调用改为new 关键字调用\"></a>将function声明的函数的函数式调用改为new 关键字调用</h1><p>es6的class声明类的方式是必须通过new关键字进行调用的</p>\n<p>而传统的利用function关键字声明的构造函数如何避免被函数式调用呢？或者说就算是函数式调用但是依然想要生成实例对象呢<br>很简单 判断constructor即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eg:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.constructor !== <span class=\"built_in\">arguments</span>.callee) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'chris'</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">23</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'A front-end engineer'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  A.work = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'working hard'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A().job() <span class=\"comment\">// that's all</span></span><br></pre></td></tr></table></figure>\n<p>补充：<br><em><code>Array()</code> 和 <code>new Array()</code> 是完全一致的</em></p>\n<blockquote>\n<p>The Array constructor is the %Array% intrinsic object and the initial value of the Array property of the global object. When called as a constructor it creates and initializes a new exotic Array object. When Array is called as a function rather than as a constructor, it also creates and initializes a new Array object. Thus the function call Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.<br><a href=\"https://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor\" target=\"_blank\" rel=\"noopener\">https://www.ecma-international.org/ecma-262/7.0/index.html#sec-array-constructor</a></p>\n</blockquote>\n<p>关于 <code>Object()</code> 与 <code>new Object()</code> 之间的差异，ES规范中说Object()会进行类型转换</p>\n<blockquote>\n<p>The Object constructor is the %Object% intrinsic object and the initial value of the Object property of the global object. When called as a constructor it creates a new ordinary object. When Object is called as a function rather than as a constructor, it performs a type conversion.<br>The Object constructor is designed to be subclassable. It may be used as the value of an extends clause of a class definition.<br><a href=\"https://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor\" target=\"_blank\" rel=\"noopener\">https://www.ecma-international.org/ecma-262/7.0/index.html#sec-object-constructor</a></p>\n</blockquote>\n<h1 id=\"The-play-request-was-interrupted-by-a-call-to-pause\"><a href=\"#The-play-request-was-interrupted-by-a-call-to-pause\" class=\"headerlink\" title=\"The play() request was interrupted by a call to pause()\"></a>The play() request was interrupted by a call to pause()</h1><p>做桌面通知的一个需求，需要自定义桌面通知是否带有提示音，使用的是h5的Notification API，在api 的 silent配置项不work的时候自定义new Audio在有新消息的时候触发，然后在延时器中关闭的时候出现以下错误：<br><em>The play() request was interrupted by a call to pause()</em></p>\n<p>google后发现 <em>Moreover since Chrome 50, a play() call on an a or element returns a Promise</em></p>\n<p>play是一个异步函数， 返回一个promise<br><strong>所以正确的方式应该先获取这个promise， 在then回调中安全的将其pause掉</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> playSound = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> audio = <span class=\"keyword\">new</span> Audio(fileUrl)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> playPromise = audio.play()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (playPromise !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    playPromise.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        audio.pause()</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">      &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">    &#125;).catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://developers.google.com/web/updates/2017/06/play-request-was-interrupted\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/updates/2017/06/play-request-was-interrupted</a></p>\n</blockquote>\n<h1 id=\"实现-Promise-的-resolve-和-reject-函数时内部为何要异步执行\"><a href=\"#实现-Promise-的-resolve-和-reject-函数时内部为何要异步执行\" class=\"headerlink\" title=\"实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行\"></a>实现 Promise 的 resolve 和 reject 函数时内部为何要异步执行</h1><p>参考别人的实现看到里面有关resolve 和 reject 函数内部的代码异步执行 却没有解释原因</p>\n<blockquote>\n<p><a href=\"https://github.com/xieranmaya/blog/issues/3\" target=\"_blank\" rel=\"noopener\">剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类</a></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">          self.status = <span class=\"string\">'resolved'</span>;</span><br><span class=\"line\">          self.data = value;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class=\"line\">              self.onResolvedCallback[i](value);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下为个人简单理解：</p>\n<p>举个例子：eventbus的实现<br>在使用eventbus进行数据通信的时候，通常都是在一个地方emit事件名 在另外想要触发的地方on接收这个事件同时传入相应的回调，而这种使用方式很容易给小白造成一种误解：我使用emit派发，使用on来接收执行这个派发</p>\n<p>显然不是的<br>自己封装一个简单的eventbus之后就会理解<br>emit是静态的而on才是依赖收集的地方 这个顺序不能变—-一定是先收集完依赖才可以派发</p>\n<p>所以对于promise的resolve和then之间是不是就可以理解为必须then收集依赖后才可以触发resolve这样resolve的参数才可以被then接收到（reject和catch同理）</p>\n<p>所以回到上面提出的resolve和reject函数内部为何一定要异步执行的问题</p>\n<p>首先涉及到一个初始化的机制</p>\n<p>假如是同步执行 resolve如果在new Promise时立即触发 此时是没有收集依赖函数的（then收集到的对应的微任务队列 <code>onResolvedCallback</code> 尚未执行）<br>那么resolve中的数值无法被传递</p>\n<p>而如果加入异步（setTimeout）变为一次宏任务推入下次事件循环</p>\n<p>这样就确保了先收集了依赖再触发回调</p>\n<blockquote>\n<p><a href=\"https://rollawaypoint.github.io/2019/03/07/writeSomething/EventLoop/\">JS/Node事件循环</a></p>\n</blockquote>\n<h1 id=\"你不知道的原生方法更多使用方式-JSON-parse、JSON-stringify、setTimeout\"><a href=\"#你不知道的原生方法更多使用方式-JSON-parse、JSON-stringify、setTimeout\" class=\"headerlink\" title=\"你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout\"></a>你不知道的原生方法更多使用方式 JSON.parse、JSON.stringify、setTimeout</h1><h4 id=\"setTimeout-定时器\"><a href=\"#setTimeout-定时器\" class=\"headerlink\" title=\"setTimeout 定时器\"></a>setTimeout 定时器</h4><p>支持传递第三个以及之后参数作为第一个回调函数的参数<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\">(<span class=\"params\">fn, wait, ...args</span>) =&gt;</span> setTimeout(fn, wait, ...args)</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123; <span class=\"built_in\">console</span>.log(args)&#125;, <span class=\"number\">1000</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JSON-parse\"><a href=\"#JSON-parse\" class=\"headerlink\" title=\"JSON.parse\"></a>JSON.parse</h4><p>JSON.parse还可额外接受第二个处理函数 对原本生成的返回值进行修改</p>\n<h4 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify\"></a>JSON.stringify</h4><p>JSON.stringify可额外再接收两个参数</p>\n<ul>\n<li>第二个参数： 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化</li>\n<li>第三个参数：指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格</li>\n</ul>\n<h1 id=\"Array-prototype-push-apply-obj-arr\"><a href=\"#Array-prototype-push-apply-obj-arr\" class=\"headerlink\" title=\"Array.prototype.push.apply(obj, arr)\"></a>Array.prototype.push.apply(obj, arr)</h1><p><em>萌新日常问题</em><br><strong>今天看到之前写的一段代码大概为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(obj, arr)</span><br></pre></td></tr></table></figure></p>\n<p><strong>最终的obj为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那如果向一个map中push呢？<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(map, arr)</span><br></pre></td></tr></table></figure></p>\n<p><strong>最终的map为：</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span>(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span>,</span><br><span class=\"line\">  size: <span class=\"number\">0</span>,</span><br><span class=\"line\">  [[Entries]]: <span class=\"built_in\">Array</span>(<span class=\"number\">0</span>),</span><br><span class=\"line\">  length: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>依然是一放进对象方式放进了map，而map的entries是空的，length也为0，我知道map是通过实例化传入option或者通过set方法才可以设置键值对，那么为什么会有这样的输出呢？</p>\n<h2 id=\"Q-为什么会以数组下标和值组成键值对的方式放进这个对象呢\"><a href=\"#Q-为什么会以数组下标和值组成键值对的方式放进这个对象呢\" class=\"headerlink\" title=\"Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢\"></a><strong>Q.为什么会以数组下标和值组成键值对的方式放进这个对象呢</strong></h2><p>落后要挨打，不懂就要查？emmm，没google到…<br>显然我对搜索引擎的应用远远不行<br>落后要挨打，不懂就要问，菜鸡互啄之后：</p>\n<blockquote>\n<p>这个其实你可以看数组和对象的实现方式，map 和 obj 的实现是不一样的，而数组和 obj 的实现则是相似的<br>obj 其实代表的应该是 record，而不是 dictionary，map 才是 dictionary，只要把 Object 当成 record 看，那它和数组就是一家人了<br>所以可以试着在代码中做一点区分,map 对索引是有一些优化的，而 Object 对下标索引也有优化，唔，这种区分是指从代码编写者的角度来说的，record 和 dictionary 是两种很常见的数据结构，在不同语言中有不同的实现，比如 python 中的实现就是 tuple 和 map，这个其实可以结合着 v8 中对象模型的实现来理解，这就说来话长了<br>js 就是动态类型，从类型角度来说没什么意义，更多的实现的角度来考虑，比如说：在 v8 中如果你的对象索引是数字，在访问的时候那就很快，这个就是 tuple 的特性，但是在 js 中就是 obj，当然 object 也能作为 dictionary 来用，但是这样访问的速度就很慢了，同理，js 数组中也可以存放不同类型的值，但是如果放同样类型的值，那利用偏移值访存就会很快</p>\n</blockquote>\n<p>所以 js 才专门出了一个 Map，也是希望规范这种使用，这种归纳是实现相关的</p>\n<p><em>意思就是本质上其实数组与对象其实是同一个东西（实现方式一致），都是键值对组成的集合，只不过js中的数组将键以索引下标的形式展现而已</em></p>\n<p><strong>什么是record类型?</strong></p>\n<blockquote>\n<p>记录(Record)类型类似于C语言中的结构数据类型，它把逻辑相关的、分离的、基本数据类型的变量组成一个整体存储起来，它必须包括至少一个标量型或RECORD数据类型的成员，称作PL/SQL RECORD的域(FIELD)，其作用是存放互不相同但逻辑相关的信息。在使用记录数据类型变量时，需要先在声明部分先定义记录的组成、记录的变量，然后在执行部分引用该记录变量本身或其中的成员</p>\n</blockquote>\n<p>.<br>.<br>.<br>.<br>.<br>.<br>未完待续…👏</p>"},{"title":"小程序的路由封装","date":"2018-12-09T08:00:00.000Z","_content":"\n基于 `mpvue` 小程序的路由封装\n\n<!--more-->\n\n[toc]\n\n## 基本使用\n\n组件内使用方法：\n```js\n\n  // 不携带路由参数\n  this.$router.push('/home/page/index')\n  // 携带路由参数\n  this.$router.push({\n    path: '/home/page/index',\n    query: {\n      //\n    },\n    reLaunch: true, // 调用wx.reLaunch\n    isTab: true // 调用wx.switchTag\n  })\n\n  // 读取当前页面路由参数\n\n  const { query } = this.$route\n\n```\n组件外部使用只需要引入router.js内部导出的push方法即可\n\n\n## 封装起步\n\n分为两点切入：\n  1. 了解微信提供的api\n  2. 自己的需求\n\n总结为以下几点：\n\n- 对微信小程序的 `switchTab、reLaunch、navigateTo、redirectTo` 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 `this.$router.push` 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 `this.$route.query` 读取。\n\n- 路由默认跳转为 `wx.navigateTo` 静态跳转，调用其他跳转方式需传递相应参数\n\n* 封装的跳转优先级：\n```\n    wx.switchTab >> wx.reLaunch >> wx.navigateTo\n```\n\n- 路由拥有拦截器，分为全局拦截和针对指定页面根据 `path` 拦截。\n\n_注意： 路由不支持指定 `wx.redireactTo` 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）_\n\n\n下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题\n\n\n### 如何完成基本跳转功能\n\n_需求：页面内使用 `this.$router.push` 方法跳转页面_\n\n首先就是新建 `index.js` 自定义一个最基本的 `push` 方法用来跳转页面\n\n``` js\n  // location 为路由传参\n  function push(location) {\n\n    const params = { url: location.path }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n\n然后为了让我们可以在页面中使用这个方法需要将 `push` 方法挂载在页面的实例上, 同时使用插件式调用在 `index.js` 文件中导出 `install` 方法\n\n``` js\n  // 导出\n  export default {\n    install(Vue) {\n\n      const _router = {\n        mode: 'history',\n        push\n      }\n      // 定义描述符getter（也可直接赋值value）\n      const $router = {\n        get() {\n          return _router\n        }\n      }\n      // 挂载 (各凭喜好也可以直接赋值在prototype上）\n      Object.defineProperty(Vue.prototype, '$router', $router)\n    }\n  }\n```\n\n接下来在项目入口文件注入上面 `index.js` 文件并执行 `Vue.use`\n\n``` js\n  import Vue from 'vue'\n  import router from './index.js'\n  \n  Vue.use(router) \n```\n\n即可在任意页面使用 `this.$router.push` 方法并传入相应跳转方式和路径\n\n这里存在一个问题： 项目跳转为了更美观主要使用 `wx.navigateTo`， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释\n\n### 页面之间如何读写参数\n\n_需求： 页面内跳转通过路由参数 `query` 字段传参， 通过 `this.$route.query` 读取参数_\n\n所以我们需要一个能够简单解析 `push` 方法参数的功能型函数 `parseUrl`，里面包括将所传的 `query` 字段以地址栏参数形式拼接在 `path` 后面的一个 `stringifyQuery` 函数\n\n``` js\n  function parseUrl(location) {\n    const { path, query } = location\n    const queryStr = stringifyQuery(query)\n\n    return `${path}${queryStr}`\n  }\n\n  function stringifyQuery(obj) {\n    const res = obj\n      ? Object.keys(obj)\n          .filter(Boolean)\n          .map(key => {\n            let val = obj[key]\n\n            if ([Array, Object].includes(val.constructor)) {\n              val = JSON.stringify(obj[key])\n            }\n            return `${key}=${val}`\n          })\n          \n          .join('&')\n      : null\n\n    return res ? `?${res}` : ''\n  }\n```\n\n把 `parseUrl` 方法添加到上面的 `push` 方法，同时参数内部是支持小程序路由跳转过程的`success`, `fail`, `complete` 钩子的 \n\n``` js\n  // location 为路由传参\n  function push(location) {\n    // others 为用户可能传递的 `success`, `fail`, `complete`\n    const { path, query, ...others } = location\n\n    const url = parseUrl({ path, query })\n\n    const params = { url, ...others }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 `$route` 对象与前面的 `$router` 一致挂载页面实例上\n\n这一层读mpvue的实例创建一个 `parseRoute` 函数简单处理一下数据即可\n\n此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0\n以下同时简单处理一下\n\n``` js\n  function parseRoute($mp) {\n    // $mp 为mpvue实例root上挂载的对象\n    const _mp = $mp || {}\n    const path = _mp.page && _mp.page.route\n    const parseQuery = {}\n    const tempQuery = _mp.query\n\n    for (let k in tempQuery) {\n      let cur = tempQuery[k]\n\n      try {\n        // 解决长整型丢失精度\n        const transfer = JSON.parse(tempQuery[k])\n\n        if (!(typeof transfer === 'number')) {\n          cur = transfer\n        }\n      } catch (e) {}\n\n      parseQuery[k] = cur\n    }\n\n    return {\n      parseQuery\n    }\n  }\n```\n\n最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 `onShow` 钩子上\n\n``` js\n  const _route = {}\n\n  Vue.mixin({\n    onShow() {\n      const { $mp } = this.$root\n\n      _route = parseRoute($mp)\n    }\n  })\n\n  const $route = {\n    get() {\n      return _route\n    }\n  }\n\n  Object.defineProperty(Vue.prototype, '$route', $route)\n```\n以上便完成路由参数的读写\n\n### 解决上面提出的小程序堆栈限制问题\n\n小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 `wx.redirectTo` 即可（其他时间项目中仅使用 `navigateTo` 即可）\n\n首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 `push` 方法\n\n``` js\n  // 当前页面堆栈长度\n  let pageStackLen = 0\n  // 堆栈限制\n  const maxStackLen = 10\n\n  function push(location, success, ...ohters) {\n    pageStackLen = getCurrentPages().length + 1\n\n    const url = parseUrl(location)\n\n    // 包装跳转成功的回调\n    const _success = function() {\n      pageStackLen = getCurrentPages().length + 1\n\n      success && success()\n    }\n\n    const params = { url, success: _success, ...ohters}\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n      pageStackLen = 1\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n\n      pageStackLen = 1\n    } else {\n      if (pageStackLen >= maxStackLen) {\n        wx.redirectTo(params)\n        return\n      }\n      wx.navigateTo(params)\n    }\n  }\n```\n以上基本解决小程序堆栈限制问题\n\n### 完善路由跳转功能\n\n现在对路由的跳转做一些基本辅助功能的支持 `go`、 `back`, `replace` 等方法\n\n``` js\n  function replace(location, ...others) {\n    const url = parseUrl(location)\n\n    wx.redirectTo({\n      url,\n      ...others\n    })\n  }\n\n  function go(delta) {\n    wx.navigateBack({\n      delta\n    })\n  }\n\n  function back() {\n    wx.navigateBack()\n  }\n```\n\n将这些挂到 `$router` 对象\n\n``` js\n  const _router = {\n    mode: 'history',\n    push,\n    replace,\n    go,\n    back\n  }\n\n  const $router = {\n    get() {\n      return _router\n    }\n  }\n\n```\n\n此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 `push` 方法方便组件外部调用等优化\n\n最后我们还差路由拦截器功能的实现\n\n### 路由拦截器\n\n需求： 对象形式配置自己路由规则\n  - `[triggerAll]`： 所有路由跳转均会触发\n  - `[triggerMatch]`： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发\n\n参数介绍：\n- `config`: 携带当前路由跳转信息（路由参数）\n- `to`: 控制跳转（调用 `to()` ）\n\n\n使用方式：\n\n``` js\nexport default {\n  triggerAll(config, to) {\n    console.log(config, 'enter interceptor')\n    to()\n  },\n  triggerMatch: {\n    '/home/pages/categoryList': [\n      (config, to) => {\n        if (/*flag*/) {\n          console.log(1)\n          to()\n        }\n      }\n    ]\n  }\n}\n```\n\n本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的\n\n新建 `interceptor.js`\n\n首先引入之前的路由方便在实例上调用，定义 `triggerMatch` 的对象存储存入的函数 `key` 为当前路由的路径，`value` 为 中间件函数组成的数组\n\n关键： 将 `push` 方法当做单独的一个中间件并放在所有中间件的最后执行\n\n``` js\n  // 引入\n  import router from './index.js'\n  // 挂载\n  Vue.use(router)\n  // 存匹配指定路由的业务函数\n  let matchMiddlewares = {}\n\n```\n接下来要构建一个处理推入规则的业务函数（中间件）的 `compose` 函数\n\n这个函数的作用主要分为两个：\n - 依次派发推入拦截器的业务函数\n - 控制下一次派发的开始\n\n``` js\n  const compose = middlewares => (...args) => {\n    function dispatch(i) {\n      return !middlewares[i]\n        ? Promise.resolve('no arguments')\n        : Promise.resolve(\n            middlewares[i](...args, function() {\n              // 派发下个调用\n              // 此处即是拦截器中第二个实参 to 方法的函数体\n              // 调动 to() 即开启下一次派发\n              return dispatch(++i)\n            })\n          )\n    }\n    // 开启调用\n    return dispatch(0)\n  }\n```\n\n创建一个函数 `getMatchMiddlewares` 用来根据指定键值读取 `matchMiddlewares` 中中间件函数数组\n\n```js\n  function getMatchMiddlewares(path) {\n    return matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []\n  }\n```\n\n\n路由同样使用 `Vue.use` 方法注册，这里导出 `install` 方法, 在里面统一所有中间件函数\n\n``` js\n  // 包装 push\n  let $push\n\n  function pushMiddware(...args) {\n    $push(...args)\n  }\n\n  export default {\n    install(Vue, { triggerAll, triggerMatch }) {\n      // 存储原 push 函数\n      $push = Vue.prototype.$router.push\n      // 接收传入的匹配函数\n      matchMiddlewares = Object.assign({}, triggerMatch)\n      \n      // 重新赋值\n      Vue.prototype.$router.push = (...args) => {\n        // 合并\n        compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(\n          ...args\n        )\n      }\n    }\n  }\n\n\n```\n\n之后在入口文件中引入即可\n\n``` js\n  import Vue from 'vue'\n  import interceptor from './interceptor.js'\n\n  Vue.use(interceptor)\n```\n\n至此便完成了路由的所有功能的基本封装\n\n详细代码可以查看 [小程序路由](http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router)\n\n此篇文章已经发布在 [http://doc.yupaopao.com](http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857)\n\n## 总结\n路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步\n\n## 最后\npo一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：\n\n![比心小程序](https://yphoto.eryufm.cn/gh_3192acdd1484_258.jpg)","source":"_posts/writeSomething/appletRouter.md","raw":"---\ntitle: 小程序的路由封装\ntags:\n  - 微信小程序\n  - mpvue\n  - 路由\ndate: 2018-12-09 16:00:00\ncategories: 封装\n---\n\n基于 `mpvue` 小程序的路由封装\n\n<!--more-->\n\n[toc]\n\n## 基本使用\n\n组件内使用方法：\n```js\n\n  // 不携带路由参数\n  this.$router.push('/home/page/index')\n  // 携带路由参数\n  this.$router.push({\n    path: '/home/page/index',\n    query: {\n      //\n    },\n    reLaunch: true, // 调用wx.reLaunch\n    isTab: true // 调用wx.switchTag\n  })\n\n  // 读取当前页面路由参数\n\n  const { query } = this.$route\n\n```\n组件外部使用只需要引入router.js内部导出的push方法即可\n\n\n## 封装起步\n\n分为两点切入：\n  1. 了解微信提供的api\n  2. 自己的需求\n\n总结为以下几点：\n\n- 对微信小程序的 `switchTab、reLaunch、navigateTo、redirectTo` 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 `this.$router.push` 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 `this.$route.query` 读取。\n\n- 路由默认跳转为 `wx.navigateTo` 静态跳转，调用其他跳转方式需传递相应参数\n\n* 封装的跳转优先级：\n```\n    wx.switchTab >> wx.reLaunch >> wx.navigateTo\n```\n\n- 路由拥有拦截器，分为全局拦截和针对指定页面根据 `path` 拦截。\n\n_注意： 路由不支持指定 `wx.redireactTo` 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）_\n\n\n下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题\n\n\n### 如何完成基本跳转功能\n\n_需求：页面内使用 `this.$router.push` 方法跳转页面_\n\n首先就是新建 `index.js` 自定义一个最基本的 `push` 方法用来跳转页面\n\n``` js\n  // location 为路由传参\n  function push(location) {\n\n    const params = { url: location.path }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n\n然后为了让我们可以在页面中使用这个方法需要将 `push` 方法挂载在页面的实例上, 同时使用插件式调用在 `index.js` 文件中导出 `install` 方法\n\n``` js\n  // 导出\n  export default {\n    install(Vue) {\n\n      const _router = {\n        mode: 'history',\n        push\n      }\n      // 定义描述符getter（也可直接赋值value）\n      const $router = {\n        get() {\n          return _router\n        }\n      }\n      // 挂载 (各凭喜好也可以直接赋值在prototype上）\n      Object.defineProperty(Vue.prototype, '$router', $router)\n    }\n  }\n```\n\n接下来在项目入口文件注入上面 `index.js` 文件并执行 `Vue.use`\n\n``` js\n  import Vue from 'vue'\n  import router from './index.js'\n  \n  Vue.use(router) \n```\n\n即可在任意页面使用 `this.$router.push` 方法并传入相应跳转方式和路径\n\n这里存在一个问题： 项目跳转为了更美观主要使用 `wx.navigateTo`， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释\n\n### 页面之间如何读写参数\n\n_需求： 页面内跳转通过路由参数 `query` 字段传参， 通过 `this.$route.query` 读取参数_\n\n所以我们需要一个能够简单解析 `push` 方法参数的功能型函数 `parseUrl`，里面包括将所传的 `query` 字段以地址栏参数形式拼接在 `path` 后面的一个 `stringifyQuery` 函数\n\n``` js\n  function parseUrl(location) {\n    const { path, query } = location\n    const queryStr = stringifyQuery(query)\n\n    return `${path}${queryStr}`\n  }\n\n  function stringifyQuery(obj) {\n    const res = obj\n      ? Object.keys(obj)\n          .filter(Boolean)\n          .map(key => {\n            let val = obj[key]\n\n            if ([Array, Object].includes(val.constructor)) {\n              val = JSON.stringify(obj[key])\n            }\n            return `${key}=${val}`\n          })\n          \n          .join('&')\n      : null\n\n    return res ? `?${res}` : ''\n  }\n```\n\n把 `parseUrl` 方法添加到上面的 `push` 方法，同时参数内部是支持小程序路由跳转过程的`success`, `fail`, `complete` 钩子的 \n\n``` js\n  // location 为路由传参\n  function push(location) {\n    // others 为用户可能传递的 `success`, `fail`, `complete`\n    const { path, query, ...others } = location\n\n    const url = parseUrl({ path, query })\n\n    const params = { url, ...others }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 `$route` 对象与前面的 `$router` 一致挂载页面实例上\n\n这一层读mpvue的实例创建一个 `parseRoute` 函数简单处理一下数据即可\n\n此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0\n以下同时简单处理一下\n\n``` js\n  function parseRoute($mp) {\n    // $mp 为mpvue实例root上挂载的对象\n    const _mp = $mp || {}\n    const path = _mp.page && _mp.page.route\n    const parseQuery = {}\n    const tempQuery = _mp.query\n\n    for (let k in tempQuery) {\n      let cur = tempQuery[k]\n\n      try {\n        // 解决长整型丢失精度\n        const transfer = JSON.parse(tempQuery[k])\n\n        if (!(typeof transfer === 'number')) {\n          cur = transfer\n        }\n      } catch (e) {}\n\n      parseQuery[k] = cur\n    }\n\n    return {\n      parseQuery\n    }\n  }\n```\n\n最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 `onShow` 钩子上\n\n``` js\n  const _route = {}\n\n  Vue.mixin({\n    onShow() {\n      const { $mp } = this.$root\n\n      _route = parseRoute($mp)\n    }\n  })\n\n  const $route = {\n    get() {\n      return _route\n    }\n  }\n\n  Object.defineProperty(Vue.prototype, '$route', $route)\n```\n以上便完成路由参数的读写\n\n### 解决上面提出的小程序堆栈限制问题\n\n小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 `wx.redirectTo` 即可（其他时间项目中仅使用 `navigateTo` 即可）\n\n首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 `push` 方法\n\n``` js\n  // 当前页面堆栈长度\n  let pageStackLen = 0\n  // 堆栈限制\n  const maxStackLen = 10\n\n  function push(location, success, ...ohters) {\n    pageStackLen = getCurrentPages().length + 1\n\n    const url = parseUrl(location)\n\n    // 包装跳转成功的回调\n    const _success = function() {\n      pageStackLen = getCurrentPages().length + 1\n\n      success && success()\n    }\n\n    const params = { url, success: _success, ...ohters}\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n      pageStackLen = 1\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n\n      pageStackLen = 1\n    } else {\n      if (pageStackLen >= maxStackLen) {\n        wx.redirectTo(params)\n        return\n      }\n      wx.navigateTo(params)\n    }\n  }\n```\n以上基本解决小程序堆栈限制问题\n\n### 完善路由跳转功能\n\n现在对路由的跳转做一些基本辅助功能的支持 `go`、 `back`, `replace` 等方法\n\n``` js\n  function replace(location, ...others) {\n    const url = parseUrl(location)\n\n    wx.redirectTo({\n      url,\n      ...others\n    })\n  }\n\n  function go(delta) {\n    wx.navigateBack({\n      delta\n    })\n  }\n\n  function back() {\n    wx.navigateBack()\n  }\n```\n\n将这些挂到 `$router` 对象\n\n``` js\n  const _router = {\n    mode: 'history',\n    push,\n    replace,\n    go,\n    back\n  }\n\n  const $router = {\n    get() {\n      return _router\n    }\n  }\n\n```\n\n此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 `push` 方法方便组件外部调用等优化\n\n最后我们还差路由拦截器功能的实现\n\n### 路由拦截器\n\n需求： 对象形式配置自己路由规则\n  - `[triggerAll]`： 所有路由跳转均会触发\n  - `[triggerMatch]`： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发\n\n参数介绍：\n- `config`: 携带当前路由跳转信息（路由参数）\n- `to`: 控制跳转（调用 `to()` ）\n\n\n使用方式：\n\n``` js\nexport default {\n  triggerAll(config, to) {\n    console.log(config, 'enter interceptor')\n    to()\n  },\n  triggerMatch: {\n    '/home/pages/categoryList': [\n      (config, to) => {\n        if (/*flag*/) {\n          console.log(1)\n          to()\n        }\n      }\n    ]\n  }\n}\n```\n\n本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的\n\n新建 `interceptor.js`\n\n首先引入之前的路由方便在实例上调用，定义 `triggerMatch` 的对象存储存入的函数 `key` 为当前路由的路径，`value` 为 中间件函数组成的数组\n\n关键： 将 `push` 方法当做单独的一个中间件并放在所有中间件的最后执行\n\n``` js\n  // 引入\n  import router from './index.js'\n  // 挂载\n  Vue.use(router)\n  // 存匹配指定路由的业务函数\n  let matchMiddlewares = {}\n\n```\n接下来要构建一个处理推入规则的业务函数（中间件）的 `compose` 函数\n\n这个函数的作用主要分为两个：\n - 依次派发推入拦截器的业务函数\n - 控制下一次派发的开始\n\n``` js\n  const compose = middlewares => (...args) => {\n    function dispatch(i) {\n      return !middlewares[i]\n        ? Promise.resolve('no arguments')\n        : Promise.resolve(\n            middlewares[i](...args, function() {\n              // 派发下个调用\n              // 此处即是拦截器中第二个实参 to 方法的函数体\n              // 调动 to() 即开启下一次派发\n              return dispatch(++i)\n            })\n          )\n    }\n    // 开启调用\n    return dispatch(0)\n  }\n```\n\n创建一个函数 `getMatchMiddlewares` 用来根据指定键值读取 `matchMiddlewares` 中中间件函数数组\n\n```js\n  function getMatchMiddlewares(path) {\n    return matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []\n  }\n```\n\n\n路由同样使用 `Vue.use` 方法注册，这里导出 `install` 方法, 在里面统一所有中间件函数\n\n``` js\n  // 包装 push\n  let $push\n\n  function pushMiddware(...args) {\n    $push(...args)\n  }\n\n  export default {\n    install(Vue, { triggerAll, triggerMatch }) {\n      // 存储原 push 函数\n      $push = Vue.prototype.$router.push\n      // 接收传入的匹配函数\n      matchMiddlewares = Object.assign({}, triggerMatch)\n      \n      // 重新赋值\n      Vue.prototype.$router.push = (...args) => {\n        // 合并\n        compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(\n          ...args\n        )\n      }\n    }\n  }\n\n\n```\n\n之后在入口文件中引入即可\n\n``` js\n  import Vue from 'vue'\n  import interceptor from './interceptor.js'\n\n  Vue.use(interceptor)\n```\n\n至此便完成了路由的所有功能的基本封装\n\n详细代码可以查看 [小程序路由](http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router)\n\n此篇文章已经发布在 [http://doc.yupaopao.com](http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857)\n\n## 总结\n路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步\n\n## 最后\npo一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：\n\n![比心小程序](https://yphoto.eryufm.cn/gh_3192acdd1484_258.jpg)","slug":"writeSomething/appletRouter","published":1,"updated":"2019-03-14T06:26:08.018Z","_id":"cjtbdahhp000ezk48vqzgtull","comments":1,"layout":"post","photos":[],"link":"","content":"<p>基于 <code>mpvue</code> 小程序的路由封装</p>\n<a id=\"more\"></a>\n<p>[toc]</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>组件内使用方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/home/page/index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/home/page/index'</span>,</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reLaunch: <span class=\"literal\">true</span>, <span class=\"comment\">// 调用wx.reLaunch</span></span><br><span class=\"line\">  isTab: <span class=\"literal\">true</span> <span class=\"comment\">// 调用wx.switchTag</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取当前页面路由参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; query &#125; = <span class=\"keyword\">this</span>.$route</span><br></pre></td></tr></table></figure></p>\n<p>组件外部使用只需要引入router.js内部导出的push方法即可</p>\n<h2 id=\"封装起步\"><a href=\"#封装起步\" class=\"headerlink\" title=\"封装起步\"></a>封装起步</h2><p>分为两点切入：</p>\n<ol>\n<li>了解微信提供的api</li>\n<li>自己的需求</li>\n</ol>\n<p>总结为以下几点：</p>\n<ul>\n<li><p>对微信小程序的 <code>switchTab、reLaunch、navigateTo、redirectTo</code> 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 <code>this.$router.push</code> 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 <code>this.$route.query</code> 读取。</p>\n</li>\n<li><p>路由默认跳转为 <code>wx.navigateTo</code> 静态跳转，调用其他跳转方式需传递相应参数</p>\n</li>\n</ul>\n<ul>\n<li>封装的跳转优先级：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.switchTab &gt;&gt; wx.reLaunch &gt;&gt; wx.navigateTo</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>路由拥有拦截器，分为全局拦截和针对指定页面根据 <code>path</code> 拦截。</li>\n</ul>\n<p><em>注意： 路由不支持指定 <code>wx.redireactTo</code> 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）</em></p>\n<p>下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题</p>\n<h3 id=\"如何完成基本跳转功能\"><a href=\"#如何完成基本跳转功能\" class=\"headerlink\" title=\"如何完成基本跳转功能\"></a>如何完成基本跳转功能</h3><p><em>需求：页面内使用 <code>this.$router.push</code> 方法跳转页面</em></p>\n<p>首先就是新建 <code>index.js</code> 自定义一个最基本的 <code>push</code> 方法用来跳转页面</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; <span class=\"attr\">url</span>: location.path &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后为了让我们可以在页面中使用这个方法需要将 <code>push</code> 方法挂载在页面的实例上, 同时使用插件式调用在 <code>index.js</code> 文件中导出 <code>install</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">      mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">      push</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义描述符getter（也可直接赋值value）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">      get() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载 (各凭喜好也可以直接赋值在prototype上）</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$router'</span>, $router)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在项目入口文件注入上面 <code>index.js</code> 文件并执行 <code>Vue.use</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(router)</span><br></pre></td></tr></table></figure>\n<p>即可在任意页面使用 <code>this.$router.push</code> 方法并传入相应跳转方式和路径</p>\n<p>这里存在一个问题： 项目跳转为了更美观主要使用 <code>wx.navigateTo</code>， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释</p>\n<h3 id=\"页面之间如何读写参数\"><a href=\"#页面之间如何读写参数\" class=\"headerlink\" title=\"页面之间如何读写参数\"></a>页面之间如何读写参数</h3><p><em>需求： 页面内跳转通过路由参数 <code>query</code> 字段传参， 通过 <code>this.$route.query</code> 读取参数</em></p>\n<p>所以我们需要一个能够简单解析 <code>push</code> 方法参数的功能型函数 <code>parseUrl</code>，里面包括将所传的 <code>query</code> 字段以地址栏参数形式拼接在 <code>path</code> 后面的一个 <code>stringifyQuery</code> 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseUrl</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query &#125; = location</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queryStr = stringifyQuery(query)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;path&#125;</span><span class=\"subst\">$&#123;queryStr&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringifyQuery</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = obj</span><br><span class=\"line\">    ? <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">        .filter(<span class=\"built_in\">Boolean</span>)</span><br><span class=\"line\">        .map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> val = obj[key]</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ([<span class=\"built_in\">Array</span>, <span class=\"built_in\">Object</span>].includes(val.constructor)) &#123;</span><br><span class=\"line\">            val = <span class=\"built_in\">JSON</span>.stringify(obj[key])</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;val&#125;</span>`</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        .join(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? <span class=\"string\">`?<span class=\"subst\">$&#123;res&#125;</span>`</span> : <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 <code>parseUrl</code> 方法添加到上面的 <code>push</code> 方法，同时参数内部是支持小程序路由跳转过程的<code>success</code>, <code>fail</code>, <code>complete</code> 钩子的 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// others 为用户可能传递的 `success`, `fail`, `complete`</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query, ...others &#125; = location</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(&#123; path, query &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, ...others &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 <code>$route</code> 对象与前面的 <code>$router</code> 一致挂载页面实例上</p>\n<p>这一层读mpvue的实例创建一个 <code>parseRoute</code> 函数简单处理一下数据即可</p>\n<p>此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0<br>以下同时简单处理一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseRoute</span>(<span class=\"params\">$mp</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $mp 为mpvue实例root上挂载的对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _mp = $mp || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = _mp.page &amp;&amp; _mp.page.route</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parseQuery = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tempQuery = _mp.query</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> tempQuery) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cur = tempQuery[k]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 解决长整型丢失精度</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> transfer = <span class=\"built_in\">JSON</span>.parse(tempQuery[k])</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(<span class=\"keyword\">typeof</span> transfer === <span class=\"string\">'number'</span>)) &#123;</span><br><span class=\"line\">        cur = transfer</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parseQuery[k] = cur</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    parseQuery</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 <code>onShow</code> 钩子上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _route = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.mixin(&#123;</span><br><span class=\"line\">  onShow() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; $mp &#125; = <span class=\"keyword\">this</span>.$root</span><br><span class=\"line\"></span><br><span class=\"line\">    _route = parseRoute($mp)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $route = &#123;</span><br><span class=\"line\">  get() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _route</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$route'</span>, $route)</span><br></pre></td></tr></table></figure>\n<p>以上便完成路由参数的读写</p>\n<h3 id=\"解决上面提出的小程序堆栈限制问题\"><a href=\"#解决上面提出的小程序堆栈限制问题\" class=\"headerlink\" title=\"解决上面提出的小程序堆栈限制问题\"></a>解决上面提出的小程序堆栈限制问题</h3><p>小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 <code>wx.redirectTo</code> 即可（其他时间项目中仅使用 <code>navigateTo</code> 即可）</p>\n<p>首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 <code>push</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前页面堆栈长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pageStackLen = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 堆栈限制</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxStackLen = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location, success, ...ohters</span>) </span>&#123;</span><br><span class=\"line\">  pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 包装跳转成功的回调</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _success = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    success &amp;&amp; success()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, <span class=\"attr\">success</span>: _success, ...ohters&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pageStackLen &gt;= maxStackLen) &#123;</span><br><span class=\"line\">      wx.redirectTo(params)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上基本解决小程序堆栈限制问题</p>\n<h3 id=\"完善路由跳转功能\"><a href=\"#完善路由跳转功能\" class=\"headerlink\" title=\"完善路由跳转功能\"></a>完善路由跳转功能</h3><p>现在对路由的跳转做一些基本辅助功能的支持 <code>go</code>、 <code>back</code>, <code>replace</code> 等方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">location, ...others</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  wx.redirectTo(&#123;</span><br><span class=\"line\">    url,</span><br><span class=\"line\">    ...others</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">delta</span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack(&#123;</span><br><span class=\"line\">    delta</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">back</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这些挂到 <code>$router</code> 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">  push,</span><br><span class=\"line\">  replace,</span><br><span class=\"line\">  go,</span><br><span class=\"line\">  back</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">  get() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 <code>push</code> 方法方便组件外部调用等优化</p>\n<p>最后我们还差路由拦截器功能的实现</p>\n<h3 id=\"路由拦截器\"><a href=\"#路由拦截器\" class=\"headerlink\" title=\"路由拦截器\"></a>路由拦截器</h3><p>需求： 对象形式配置自己路由规则</p>\n<ul>\n<li><code>[triggerAll]</code>： 所有路由跳转均会触发</li>\n<li><code>[triggerMatch]</code>： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发</li>\n</ul>\n<p>参数介绍：</p>\n<ul>\n<li><code>config</code>: 携带当前路由跳转信息（路由参数）</li>\n<li><code>to</code>: 控制跳转（调用 <code>to()</code> ）</li>\n</ul>\n<p>使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  triggerAll(config, to) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(config, <span class=\"string\">'enter interceptor'</span>)</span><br><span class=\"line\">    to()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  triggerMatch: &#123;</span><br><span class=\"line\">    <span class=\"string\">'/home/pages/categoryList'</span>: [</span><br><span class=\"line\">      (config, to) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*flag*/</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">          to()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的</p>\n<p>新建 <code>interceptor.js</code></p>\n<p>首先引入之前的路由方便在实例上调用，定义 <code>triggerMatch</code> 的对象存储存入的函数 <code>key</code> 为当前路由的路径，<code>value</code> 为 中间件函数组成的数组</p>\n<p>关键： 将 <code>push</code> 方法当做单独的一个中间件并放在所有中间件的最后执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 挂载</span></span><br><span class=\"line\">Vue.use(router)</span><br><span class=\"line\"><span class=\"comment\">// 存匹配指定路由的业务函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> matchMiddlewares = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来要构建一个处理推入规则的业务函数（中间件）的 <code>compose</code> 函数</p>\n<p>这个函数的作用主要分为两个：</p>\n<ul>\n<li>依次派发推入拦截器的业务函数</li>\n<li>控制下一次派发的开始</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !middlewares[i]</span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'no arguments'</span>)</span><br><span class=\"line\">      : <span class=\"built_in\">Promise</span>.resolve(</span><br><span class=\"line\">          middlewares[i](...args, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 派发下个调用</span></span><br><span class=\"line\">            <span class=\"comment\">// 此处即是拦截器中第二个实参 to 方法的函数体</span></span><br><span class=\"line\">            <span class=\"comment\">// 调动 to() 即开启下一次派发</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatch(++i)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 开启调用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个函数 <code>getMatchMiddlewares</code> 用来根据指定键值读取 <code>matchMiddlewares</code> 中中间件函数数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMatchMiddlewares</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路由同样使用 <code>Vue.use</code> 方法注册，这里导出 <code>install</code> 方法, 在里面统一所有中间件函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包装 push</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> $push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushMiddware</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  $push(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue, &#123; triggerAll, triggerMatch &#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储原 push 函数</span></span><br><span class=\"line\">    $push = Vue.prototype.$router.push</span><br><span class=\"line\">    <span class=\"comment\">// 接收传入的匹配函数</span></span><br><span class=\"line\">    matchMiddlewares = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, triggerMatch)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">    Vue.prototype.$router.push = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 合并</span></span><br><span class=\"line\">      compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(</span><br><span class=\"line\">        ...args</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后在入口文件中引入即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> interceptor <span class=\"keyword\">from</span> <span class=\"string\">'./interceptor.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(interceptor)</span><br></pre></td></tr></table></figure>\n<p>至此便完成了路由的所有功能的基本封装</p>\n<p>详细代码可以查看 <a href=\"http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router\" target=\"_blank\" rel=\"noopener\">小程序路由</a></p>\n<p>此篇文章已经发布在 <a href=\"http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857\" target=\"_blank\" rel=\"noopener\">http://doc.yupaopao.com</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>po一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：</p>\n<p><img src=\"https://yphoto.eryufm.cn/gh_3192acdd1484_258.jpg\" alt=\"比心小程序\"></p>\n","site":{"data":{}},"excerpt":"<p>基于 <code>mpvue</code> 小程序的路由封装</p>","more":"<p>[toc]</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>组件内使用方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/home/page/index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/home/page/index'</span>,</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reLaunch: <span class=\"literal\">true</span>, <span class=\"comment\">// 调用wx.reLaunch</span></span><br><span class=\"line\">  isTab: <span class=\"literal\">true</span> <span class=\"comment\">// 调用wx.switchTag</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取当前页面路由参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; query &#125; = <span class=\"keyword\">this</span>.$route</span><br></pre></td></tr></table></figure></p>\n<p>组件外部使用只需要引入router.js内部导出的push方法即可</p>\n<h2 id=\"封装起步\"><a href=\"#封装起步\" class=\"headerlink\" title=\"封装起步\"></a>封装起步</h2><p>分为两点切入：</p>\n<ol>\n<li>了解微信提供的api</li>\n<li>自己的需求</li>\n</ol>\n<p>总结为以下几点：</p>\n<ul>\n<li><p>对微信小程序的 <code>switchTab、reLaunch、navigateTo、redirectTo</code> 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 <code>this.$router.push</code> 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 <code>this.$route.query</code> 读取。</p>\n</li>\n<li><p>路由默认跳转为 <code>wx.navigateTo</code> 静态跳转，调用其他跳转方式需传递相应参数</p>\n</li>\n</ul>\n<ul>\n<li>封装的跳转优先级：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.switchTab &gt;&gt; wx.reLaunch &gt;&gt; wx.navigateTo</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>路由拥有拦截器，分为全局拦截和针对指定页面根据 <code>path</code> 拦截。</li>\n</ul>\n<p><em>注意： 路由不支持指定 <code>wx.redireactTo</code> 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）</em></p>\n<p>下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题</p>\n<h3 id=\"如何完成基本跳转功能\"><a href=\"#如何完成基本跳转功能\" class=\"headerlink\" title=\"如何完成基本跳转功能\"></a>如何完成基本跳转功能</h3><p><em>需求：页面内使用 <code>this.$router.push</code> 方法跳转页面</em></p>\n<p>首先就是新建 <code>index.js</code> 自定义一个最基本的 <code>push</code> 方法用来跳转页面</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; <span class=\"attr\">url</span>: location.path &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后为了让我们可以在页面中使用这个方法需要将 <code>push</code> 方法挂载在页面的实例上, 同时使用插件式调用在 <code>index.js</code> 文件中导出 <code>install</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">      mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">      push</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义描述符getter（也可直接赋值value）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">      get() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载 (各凭喜好也可以直接赋值在prototype上）</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$router'</span>, $router)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在项目入口文件注入上面 <code>index.js</code> 文件并执行 <code>Vue.use</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(router)</span><br></pre></td></tr></table></figure>\n<p>即可在任意页面使用 <code>this.$router.push</code> 方法并传入相应跳转方式和路径</p>\n<p>这里存在一个问题： 项目跳转为了更美观主要使用 <code>wx.navigateTo</code>， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释</p>\n<h3 id=\"页面之间如何读写参数\"><a href=\"#页面之间如何读写参数\" class=\"headerlink\" title=\"页面之间如何读写参数\"></a>页面之间如何读写参数</h3><p><em>需求： 页面内跳转通过路由参数 <code>query</code> 字段传参， 通过 <code>this.$route.query</code> 读取参数</em></p>\n<p>所以我们需要一个能够简单解析 <code>push</code> 方法参数的功能型函数 <code>parseUrl</code>，里面包括将所传的 <code>query</code> 字段以地址栏参数形式拼接在 <code>path</code> 后面的一个 <code>stringifyQuery</code> 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseUrl</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query &#125; = location</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queryStr = stringifyQuery(query)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;path&#125;</span><span class=\"subst\">$&#123;queryStr&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringifyQuery</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = obj</span><br><span class=\"line\">    ? <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">        .filter(<span class=\"built_in\">Boolean</span>)</span><br><span class=\"line\">        .map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> val = obj[key]</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ([<span class=\"built_in\">Array</span>, <span class=\"built_in\">Object</span>].includes(val.constructor)) &#123;</span><br><span class=\"line\">            val = <span class=\"built_in\">JSON</span>.stringify(obj[key])</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;val&#125;</span>`</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        .join(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? <span class=\"string\">`?<span class=\"subst\">$&#123;res&#125;</span>`</span> : <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 <code>parseUrl</code> 方法添加到上面的 <code>push</code> 方法，同时参数内部是支持小程序路由跳转过程的<code>success</code>, <code>fail</code>, <code>complete</code> 钩子的 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// others 为用户可能传递的 `success`, `fail`, `complete`</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query, ...others &#125; = location</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(&#123; path, query &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, ...others &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 <code>$route</code> 对象与前面的 <code>$router</code> 一致挂载页面实例上</p>\n<p>这一层读mpvue的实例创建一个 <code>parseRoute</code> 函数简单处理一下数据即可</p>\n<p>此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0<br>以下同时简单处理一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseRoute</span>(<span class=\"params\">$mp</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $mp 为mpvue实例root上挂载的对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _mp = $mp || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = _mp.page &amp;&amp; _mp.page.route</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parseQuery = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tempQuery = _mp.query</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> tempQuery) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cur = tempQuery[k]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 解决长整型丢失精度</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> transfer = <span class=\"built_in\">JSON</span>.parse(tempQuery[k])</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(<span class=\"keyword\">typeof</span> transfer === <span class=\"string\">'number'</span>)) &#123;</span><br><span class=\"line\">        cur = transfer</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parseQuery[k] = cur</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    parseQuery</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 <code>onShow</code> 钩子上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _route = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.mixin(&#123;</span><br><span class=\"line\">  onShow() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; $mp &#125; = <span class=\"keyword\">this</span>.$root</span><br><span class=\"line\"></span><br><span class=\"line\">    _route = parseRoute($mp)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $route = &#123;</span><br><span class=\"line\">  get() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _route</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$route'</span>, $route)</span><br></pre></td></tr></table></figure>\n<p>以上便完成路由参数的读写</p>\n<h3 id=\"解决上面提出的小程序堆栈限制问题\"><a href=\"#解决上面提出的小程序堆栈限制问题\" class=\"headerlink\" title=\"解决上面提出的小程序堆栈限制问题\"></a>解决上面提出的小程序堆栈限制问题</h3><p>小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 <code>wx.redirectTo</code> 即可（其他时间项目中仅使用 <code>navigateTo</code> 即可）</p>\n<p>首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 <code>push</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前页面堆栈长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pageStackLen = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 堆栈限制</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxStackLen = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location, success, ...ohters</span>) </span>&#123;</span><br><span class=\"line\">  pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 包装跳转成功的回调</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _success = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    success &amp;&amp; success()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, <span class=\"attr\">success</span>: _success, ...ohters&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pageStackLen &gt;= maxStackLen) &#123;</span><br><span class=\"line\">      wx.redirectTo(params)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上基本解决小程序堆栈限制问题</p>\n<h3 id=\"完善路由跳转功能\"><a href=\"#完善路由跳转功能\" class=\"headerlink\" title=\"完善路由跳转功能\"></a>完善路由跳转功能</h3><p>现在对路由的跳转做一些基本辅助功能的支持 <code>go</code>、 <code>back</code>, <code>replace</code> 等方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">location, ...others</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  wx.redirectTo(&#123;</span><br><span class=\"line\">    url,</span><br><span class=\"line\">    ...others</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">delta</span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack(&#123;</span><br><span class=\"line\">    delta</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">back</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这些挂到 <code>$router</code> 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">  push,</span><br><span class=\"line\">  replace,</span><br><span class=\"line\">  go,</span><br><span class=\"line\">  back</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">  get() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 <code>push</code> 方法方便组件外部调用等优化</p>\n<p>最后我们还差路由拦截器功能的实现</p>\n<h3 id=\"路由拦截器\"><a href=\"#路由拦截器\" class=\"headerlink\" title=\"路由拦截器\"></a>路由拦截器</h3><p>需求： 对象形式配置自己路由规则</p>\n<ul>\n<li><code>[triggerAll]</code>： 所有路由跳转均会触发</li>\n<li><code>[triggerMatch]</code>： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发</li>\n</ul>\n<p>参数介绍：</p>\n<ul>\n<li><code>config</code>: 携带当前路由跳转信息（路由参数）</li>\n<li><code>to</code>: 控制跳转（调用 <code>to()</code> ）</li>\n</ul>\n<p>使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  triggerAll(config, to) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(config, <span class=\"string\">'enter interceptor'</span>)</span><br><span class=\"line\">    to()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  triggerMatch: &#123;</span><br><span class=\"line\">    <span class=\"string\">'/home/pages/categoryList'</span>: [</span><br><span class=\"line\">      (config, to) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*flag*/</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">          to()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的</p>\n<p>新建 <code>interceptor.js</code></p>\n<p>首先引入之前的路由方便在实例上调用，定义 <code>triggerMatch</code> 的对象存储存入的函数 <code>key</code> 为当前路由的路径，<code>value</code> 为 中间件函数组成的数组</p>\n<p>关键： 将 <code>push</code> 方法当做单独的一个中间件并放在所有中间件的最后执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 挂载</span></span><br><span class=\"line\">Vue.use(router)</span><br><span class=\"line\"><span class=\"comment\">// 存匹配指定路由的业务函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> matchMiddlewares = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来要构建一个处理推入规则的业务函数（中间件）的 <code>compose</code> 函数</p>\n<p>这个函数的作用主要分为两个：</p>\n<ul>\n<li>依次派发推入拦截器的业务函数</li>\n<li>控制下一次派发的开始</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !middlewares[i]</span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'no arguments'</span>)</span><br><span class=\"line\">      : <span class=\"built_in\">Promise</span>.resolve(</span><br><span class=\"line\">          middlewares[i](...args, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 派发下个调用</span></span><br><span class=\"line\">            <span class=\"comment\">// 此处即是拦截器中第二个实参 to 方法的函数体</span></span><br><span class=\"line\">            <span class=\"comment\">// 调动 to() 即开启下一次派发</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatch(++i)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 开启调用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个函数 <code>getMatchMiddlewares</code> 用来根据指定键值读取 <code>matchMiddlewares</code> 中中间件函数数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMatchMiddlewares</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路由同样使用 <code>Vue.use</code> 方法注册，这里导出 <code>install</code> 方法, 在里面统一所有中间件函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包装 push</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> $push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushMiddware</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  $push(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue, &#123; triggerAll, triggerMatch &#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储原 push 函数</span></span><br><span class=\"line\">    $push = Vue.prototype.$router.push</span><br><span class=\"line\">    <span class=\"comment\">// 接收传入的匹配函数</span></span><br><span class=\"line\">    matchMiddlewares = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, triggerMatch)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">    Vue.prototype.$router.push = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 合并</span></span><br><span class=\"line\">      compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(</span><br><span class=\"line\">        ...args</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后在入口文件中引入即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> interceptor <span class=\"keyword\">from</span> <span class=\"string\">'./interceptor.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(interceptor)</span><br></pre></td></tr></table></figure>\n<p>至此便完成了路由的所有功能的基本封装</p>\n<p>详细代码可以查看 <a href=\"http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router\" target=\"_blank\" rel=\"noopener\">小程序路由</a></p>\n<p>此篇文章已经发布在 <a href=\"http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857\" target=\"_blank\" rel=\"noopener\">http://doc.yupaopao.com</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>po一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：</p>\n<p><img src=\"https://yphoto.eryufm.cn/gh_3192acdd1484_258.jpg\" alt=\"比心小程序\"></p>"},{"title":"动态规划和递归：从虎羊草开始","date":"2019-02-21T12:36:00.000Z","_content":"\n老虎会吃羊吗？🐅🐑\n\n<!--more-->\n\n草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）\n\n_提示:每只老虎都很聪明_\n\n# 归纳\n\n#### case1: 两只老虎一只羊\n\n不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃\n\n#### case2: 三只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case1\n\n#### case3: 四只老虎一只羊\n\n不吃：一只老虎吃完羊后情景变为case2会被吃\n\n#### case4: 五只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case3\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃\n\n引出课题 `Dynamic Programming`\n\n# Dynamic Programming\n\n> 简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念\n\n- 最优子结构\n- 边界\n- 状态转移公式\n\n下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题\n\n_Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........这个数列从第3项开始，每一项都等于前两项之和_\n\n在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）因此可以直接写出以下代码：\n``` js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  return fn(n-1) + fn(n-2)\n}\n```\n运行结果如下：\n``` js\nconsole.log(\n  `第1项${fn(1)}`,\n  `第2项${fn(2)}`,\n  `第3项${fn(3)}`,\n  `第4项${fn(4)}`,\n  `第5项${fn(5)}`,\n  `第6项${fn(6)}`,\n  `第7项${fn(7)}`\n)\n// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13\n```\n\n现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念\n\n1. 最优子结构：若想求得第 `m` 项的值，那么只需要去求得第 `m-1` 和 `m-2` 的值即可，那么 `fn(m-1) + fn(m-2) === f(m)` 等式成立\n2. 边界: 即范围\n3. 状态转移公式：`f(m) = fn(m-1) + fn(m-2)`\n\n上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？\n具象化来看： 求得f(5) = ？\n - f(5)依赖 f(4)和f(3)\n - f(4)依赖 f(3)和f(2)\n - f(3)依赖 f(2)和f(1)\n\n显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：\n\n```js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  let m = 1, m_1 = 1, result\n\n  for(let i = 3; i <= n; i++){\n    result = m + m_1\n    m_1 = m\n    m = result\n  }\n\n  return result\n}\n```\n\n结果和上面是一致的但是性能就会有非常大的提升了\n\n# 既然上面提到了递归我们就再来说说递归\n_递归： 程序调用自身的编程技巧称为递归（recursion）_\n\n那么上面 `return fn(n-1) + fn(n-2)` 就是一个最普通的递归\n\n这里再引入一个尾递归的概念：就是函数在尾部调用自身\n\n那下面来简单说说为什么上面递归的写法性能会那么差\n\n调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存\n\n将上面方法改用尾递归的写法：\n```js\nfunction fn(n, m_1 = 1, m = 1) {  \n  if (n === 1 || n === 2) return m\n\n  return fn(n - 1, m, m + m_1)\n}\n```\n此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍\n\n当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈\n\n# summary\n\ndraven：好好看 好好学\n\n\n","source":"_posts/writeSomething/dynamicProgrammingAndRecursion.md","raw":"---\ntitle: 动态规划和递归：从虎羊草开始\ntags:\n  - 算法\n  - 动态规划\n  - 递归\ndate: 2019-02-21 20:36:00\ncategories: 算法\n---\n\n老虎会吃羊吗？🐅🐑\n\n<!--more-->\n\n草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）\n\n_提示:每只老虎都很聪明_\n\n# 归纳\n\n#### case1: 两只老虎一只羊\n\n不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃\n\n#### case2: 三只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case1\n\n#### case3: 四只老虎一只羊\n\n不吃：一只老虎吃完羊后情景变为case2会被吃\n\n#### case4: 五只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case3\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃\n\n引出课题 `Dynamic Programming`\n\n# Dynamic Programming\n\n> 简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念\n\n- 最优子结构\n- 边界\n- 状态转移公式\n\n下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题\n\n_Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........这个数列从第3项开始，每一项都等于前两项之和_\n\n在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）因此可以直接写出以下代码：\n``` js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  return fn(n-1) + fn(n-2)\n}\n```\n运行结果如下：\n``` js\nconsole.log(\n  `第1项${fn(1)}`,\n  `第2项${fn(2)}`,\n  `第3项${fn(3)}`,\n  `第4项${fn(4)}`,\n  `第5项${fn(5)}`,\n  `第6项${fn(6)}`,\n  `第7项${fn(7)}`\n)\n// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13\n```\n\n现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念\n\n1. 最优子结构：若想求得第 `m` 项的值，那么只需要去求得第 `m-1` 和 `m-2` 的值即可，那么 `fn(m-1) + fn(m-2) === f(m)` 等式成立\n2. 边界: 即范围\n3. 状态转移公式：`f(m) = fn(m-1) + fn(m-2)`\n\n上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？\n具象化来看： 求得f(5) = ？\n - f(5)依赖 f(4)和f(3)\n - f(4)依赖 f(3)和f(2)\n - f(3)依赖 f(2)和f(1)\n\n显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：\n\n```js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  let m = 1, m_1 = 1, result\n\n  for(let i = 3; i <= n; i++){\n    result = m + m_1\n    m_1 = m\n    m = result\n  }\n\n  return result\n}\n```\n\n结果和上面是一致的但是性能就会有非常大的提升了\n\n# 既然上面提到了递归我们就再来说说递归\n_递归： 程序调用自身的编程技巧称为递归（recursion）_\n\n那么上面 `return fn(n-1) + fn(n-2)` 就是一个最普通的递归\n\n这里再引入一个尾递归的概念：就是函数在尾部调用自身\n\n那下面来简单说说为什么上面递归的写法性能会那么差\n\n调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存\n\n将上面方法改用尾递归的写法：\n```js\nfunction fn(n, m_1 = 1, m = 1) {  \n  if (n === 1 || n === 2) return m\n\n  return fn(n - 1, m, m + m_1)\n}\n```\n此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍\n\n当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈\n\n# summary\n\ndraven：好好看 好好学\n\n\n","slug":"writeSomething/dynamicProgrammingAndRecursion","published":1,"updated":"2019-03-14T06:26:08.020Z","_id":"cjtbdahhr000jzk484gzrh4ib","comments":1,"layout":"post","photos":[],"link":"","content":"<p>老虎会吃羊吗？🐅🐑</p>\n<a id=\"more\"></a>\n<p>草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）</p>\n<p><em>提示:每只老虎都很聪明</em></p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><h4 id=\"case1-两只老虎一只羊\"><a href=\"#case1-两只老虎一只羊\" class=\"headerlink\" title=\"case1: 两只老虎一只羊\"></a>case1: 两只老虎一只羊</h4><p>不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃</p>\n<h4 id=\"case2-三只老虎一只羊\"><a href=\"#case2-三只老虎一只羊\" class=\"headerlink\" title=\"case2: 三只老虎一只羊\"></a>case2: 三只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case1</p>\n<h4 id=\"case3-四只老虎一只羊\"><a href=\"#case3-四只老虎一只羊\" class=\"headerlink\" title=\"case3: 四只老虎一只羊\"></a>case3: 四只老虎一只羊</h4><p>不吃：一只老虎吃完羊后情景变为case2会被吃</p>\n<h4 id=\"case4-五只老虎一只羊\"><a href=\"#case4-五只老虎一只羊\" class=\"headerlink\" title=\"case4: 五只老虎一只羊\"></a>case4: 五只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case3</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃</p>\n<p>引出课题 <code>Dynamic Programming</code></p>\n<h1 id=\"Dynamic-Programming\"><a href=\"#Dynamic-Programming\" class=\"headerlink\" title=\"Dynamic Programming\"></a>Dynamic Programming</h1><blockquote>\n<p>简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念</p>\n</blockquote>\n<ul>\n<li>最优子结构</li>\n<li>边界</li>\n<li>状态转移公式</li>\n</ul>\n<p>下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题</p>\n<p><em>Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..这个数列从第3项开始，每一项都等于前两项之和</em></p>\n<p>在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）因此可以直接写出以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n<span class=\"number\">-1</span>) + fn(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第1项<span class=\"subst\">$&#123;fn(<span class=\"number\">1</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第2项<span class=\"subst\">$&#123;fn(<span class=\"number\">2</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第3项<span class=\"subst\">$&#123;fn(<span class=\"number\">3</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第4项<span class=\"subst\">$&#123;fn(<span class=\"number\">4</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第5项<span class=\"subst\">$&#123;fn(<span class=\"number\">5</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第6项<span class=\"subst\">$&#123;fn(<span class=\"number\">6</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第7项<span class=\"subst\">$&#123;fn(<span class=\"number\">7</span>)&#125;</span>`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13</span></span><br></pre></td></tr></table></figure></p>\n<p>现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念</p>\n<ol>\n<li>最优子结构：若想求得第 <code>m</code> 项的值，那么只需要去求得第 <code>m-1</code> 和 <code>m-2</code> 的值即可，那么 <code>fn(m-1) + fn(m-2) === f(m)</code> 等式成立</li>\n<li>边界: 即范围</li>\n<li>状态转移公式：<code>f(m) = fn(m-1) + fn(m-2)</code></li>\n</ol>\n<p>上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？<br>具象化来看： 求得f(5) = ？</p>\n<ul>\n<li>f(5)依赖 f(4)和f(3)</li>\n<li>f(4)依赖 f(3)和f(2)</li>\n<li>f(3)依赖 f(2)和f(1)</li>\n</ul>\n<p>显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>, m_1 = <span class=\"number\">1</span>, result</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">    result = m + m_1</span><br><span class=\"line\">    m_1 = m</span><br><span class=\"line\">    m = result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果和上面是一致的但是性能就会有非常大的提升了</p>\n<h1 id=\"既然上面提到了递归我们就再来说说递归\"><a href=\"#既然上面提到了递归我们就再来说说递归\" class=\"headerlink\" title=\"既然上面提到了递归我们就再来说说递归\"></a>既然上面提到了递归我们就再来说说递归</h1><p><em>递归： 程序调用自身的编程技巧称为递归（recursion）</em></p>\n<p>那么上面 <code>return fn(n-1) + fn(n-2)</code> 就是一个最普通的递归</p>\n<p>这里再引入一个尾递归的概念：就是函数在尾部调用自身</p>\n<p>那下面来简单说说为什么上面递归的写法性能会那么差</p>\n<p>调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存</p>\n<p>将上面方法改用尾递归的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n, m_1 = <span class=\"number\">1</span>, m = <span class=\"number\">1</span></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> m</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n - <span class=\"number\">1</span>, m, m + m_1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍</p>\n<p>当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>draven：好好看 好好学</p>\n","site":{"data":{}},"excerpt":"<p>老虎会吃羊吗？🐅🐑</p>","more":"<p>草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）</p>\n<p><em>提示:每只老虎都很聪明</em></p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><h4 id=\"case1-两只老虎一只羊\"><a href=\"#case1-两只老虎一只羊\" class=\"headerlink\" title=\"case1: 两只老虎一只羊\"></a>case1: 两只老虎一只羊</h4><p>不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃</p>\n<h4 id=\"case2-三只老虎一只羊\"><a href=\"#case2-三只老虎一只羊\" class=\"headerlink\" title=\"case2: 三只老虎一只羊\"></a>case2: 三只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case1</p>\n<h4 id=\"case3-四只老虎一只羊\"><a href=\"#case3-四只老虎一只羊\" class=\"headerlink\" title=\"case3: 四只老虎一只羊\"></a>case3: 四只老虎一只羊</h4><p>不吃：一只老虎吃完羊后情景变为case2会被吃</p>\n<h4 id=\"case4-五只老虎一只羊\"><a href=\"#case4-五只老虎一只羊\" class=\"headerlink\" title=\"case4: 五只老虎一只羊\"></a>case4: 五只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case3</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃</p>\n<p>引出课题 <code>Dynamic Programming</code></p>\n<h1 id=\"Dynamic-Programming\"><a href=\"#Dynamic-Programming\" class=\"headerlink\" title=\"Dynamic Programming\"></a>Dynamic Programming</h1><blockquote>\n<p>简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念</p>\n</blockquote>\n<ul>\n<li>最优子结构</li>\n<li>边界</li>\n<li>状态转移公式</li>\n</ul>\n<p>下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题</p>\n<p><em>Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..这个数列从第3项开始，每一项都等于前两项之和</em></p>\n<p>在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）因此可以直接写出以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n<span class=\"number\">-1</span>) + fn(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第1项<span class=\"subst\">$&#123;fn(<span class=\"number\">1</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第2项<span class=\"subst\">$&#123;fn(<span class=\"number\">2</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第3项<span class=\"subst\">$&#123;fn(<span class=\"number\">3</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第4项<span class=\"subst\">$&#123;fn(<span class=\"number\">4</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第5项<span class=\"subst\">$&#123;fn(<span class=\"number\">5</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第6项<span class=\"subst\">$&#123;fn(<span class=\"number\">6</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第7项<span class=\"subst\">$&#123;fn(<span class=\"number\">7</span>)&#125;</span>`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13</span></span><br></pre></td></tr></table></figure></p>\n<p>现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念</p>\n<ol>\n<li>最优子结构：若想求得第 <code>m</code> 项的值，那么只需要去求得第 <code>m-1</code> 和 <code>m-2</code> 的值即可，那么 <code>fn(m-1) + fn(m-2) === f(m)</code> 等式成立</li>\n<li>边界: 即范围</li>\n<li>状态转移公式：<code>f(m) = fn(m-1) + fn(m-2)</code></li>\n</ol>\n<p>上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？<br>具象化来看： 求得f(5) = ？</p>\n<ul>\n<li>f(5)依赖 f(4)和f(3)</li>\n<li>f(4)依赖 f(3)和f(2)</li>\n<li>f(3)依赖 f(2)和f(1)</li>\n</ul>\n<p>显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>, m_1 = <span class=\"number\">1</span>, result</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">    result = m + m_1</span><br><span class=\"line\">    m_1 = m</span><br><span class=\"line\">    m = result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果和上面是一致的但是性能就会有非常大的提升了</p>\n<h1 id=\"既然上面提到了递归我们就再来说说递归\"><a href=\"#既然上面提到了递归我们就再来说说递归\" class=\"headerlink\" title=\"既然上面提到了递归我们就再来说说递归\"></a>既然上面提到了递归我们就再来说说递归</h1><p><em>递归： 程序调用自身的编程技巧称为递归（recursion）</em></p>\n<p>那么上面 <code>return fn(n-1) + fn(n-2)</code> 就是一个最普通的递归</p>\n<p>这里再引入一个尾递归的概念：就是函数在尾部调用自身</p>\n<p>那下面来简单说说为什么上面递归的写法性能会那么差</p>\n<p>调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存</p>\n<p>将上面方法改用尾递归的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n, m_1 = <span class=\"number\">1</span>, m = <span class=\"number\">1</span></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> m</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n - <span class=\"number\">1</span>, m, m + m_1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍</p>\n<p>当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>draven：好好看 好好学</p>"},{"title":"有趣的JS题目整理","date":"2019-03-12T11:33:00.000Z","_content":"\nJS相关各类型题目记录\n<!--more-->\n\n# JS执行上下文（作用域）以及变量提升\n先看题目：以下代码输出分别是什么\n\n###### 平安的一道笔试题\n```js\nvar a = 10\n\nfunction fn() {\n  a()\n\n  try {\n    a()\n    console.log(a, ' try')\n    a = 100\n  } catch (e) {\n    a = 1\n    console.log(a, ' catch')\n  }\n  \n  console.log(a, ' inner function fn')\n\n  function a() {\n    console.log(a, ' inner function a')\n    a = 1000\n  }\n}\n\nfn()\nconsole.log(a, 'outer result')\n\n```\n先试着预想一下执行结果\n.\n.\n.\n.\n.\n.\n输出\n```js\n// [Function] inner function a\n// 1 catch\n// 1 inner function fn\n// 10 outer result\n```\n是否和预想的一致呢？\n\n先来了解几个概念：\n - 每一个函数都有自己的执行上下文EC（执行环境 execution context）\n   - 全局脚本是一个全局上下文\n - EC预解析的时候会有变量提升\n   - 只有关键字声明的变量才会有变量提升\n   - 函数优先级高于普通变量\n\n下面开始分析一下执行结果\n首先 fn 会获得变量提升然后声明并且赋值全局变量 `var a = 10` \n\n执行fn：\n  - 首先 fn 内部进行变量提升\n    - 内部函数a提升到当前EC顶部\n    - ```js\n      function fn() {\n        function a() {\n          console.log(a, ' inner function a')\n          a = 1000\n        }\n        a()\n      }\n      ```\n    - 主要的一点：fn 内部的变量 a 已经被重新声明 相当于 `var a = function () {}` 所以此处 fn 内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局\n\nfn内部输出：\n  - a本身是个函数，invoke a() 输出 `[Function] inner function a`，然后将fn内部的 a 重新赋值为1000\n  - 执行try语句：\n    - a是1000所以 invoke a()会抛出异常 `a is not a function` 被catch语句捕获，当前try语句终端不在继续向下执行\n      - *try语句内部的 `a = 100` 只是简单的赋值操作，没有关键字声明所以没有变量提升*\n  - 执行catch语句\n    - 重新赋值 `a = 1`，输出 `a catch`\n  - try catch语句执行结束继续向下执行, 此时a已经被catch语句赋值为1输出 `1 inner function fn`\n\nfn执行结束继续执行全局上下文环境中的代码，上面说了fn内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局, 所以全局上下文中a依旧是10，输出 10\n运行结束\n\n# 深入理解“连等赋值”问题\n```js\nvar a = { n: 1 }\nvar b = a\na.x = a = { n: 2 }\nalert(a.x) // --> undefined\nalert(b.x) // --> { n: 2 }\n```\n\n理解该问题需要知道以下两点：\n- JS引擎对赋值表达式的处理过程\n- 赋值运算的右结合性\n\n#### JS引擎对赋值表达式的处理过程\n如赋值表达式 `A = B`\n1. 计算表达式左表达式A，得到一个引用refA\n2. 计算表达式B，得到一个引用refB\n3. 通过 `GetValue(refB)` 得到valueB\n4. 进行判断，当如下情况全部符合则抛出语法异常\n   1. refA是一个引用\n   2. refA是一个严格引用\n   3. refA是一个 `environment records`(**这里理解是refA是一个声明的变量或者是对象的某个属性**)\n   4. refA的引用名是’eval‘或’arguments‘\n5. 将valueB赋给refA指向的名称绑定\n6. 返回valueB\n\n*`GetValue(refB)` 是通过一系列判断得出value值，具体步骤参考[GetValue(refB)](http://es5.github.io/#x8.7.1)*\n\n具体参考：\n> [http://es5.github.io/#x11.13.1](http://es5.github.io/#x11.13.1)\n\n#### 结合性\n所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。\n赋值表达式是右结合的。这意味着：`A1 = A2 = A3 = A4` 等价于 `A1 = (A2 = (A3 = A4))`\n\n\n总的简单s来说就是：***先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用***\n\n#### 分析\n```js\na.x = a = { n: 2 }\n```\n首先得到 a.x 和 a 的两个引用\n得到右表达式是一个对象 `{ n: 2 }`\na.x 和 a 的两个引用并且判断属于 `environment records`（a.x 属于对象的某个属性，a属于当前上下文的变量a）\n将 `{ n: 2 }` 赋值给 当前上下文变量 a 的 refA，a已被重新赋值为 `{ n: 2 }`\n将 `{ n: 2 }` 赋值给 当前上下文变量 a.x 的 ref（a.x）*ref（a.x）与ref（b.x）是同一个*, refA已经与 `{ n: 2 }` 重新绑定，所以此时 b 为 `{ n: 1, x: { n: 2 } }`\n\n所以最终结果：a为 `{ n：2 }`，b为 `{ n: 1, x: { n: 2 } }`, 并且由于是同一个对象 `{ n: 2 }` 赋值给b.x以及a获得的引用相同，所以 `b.x === a`\n\n所以 `a.x` 为 `undefined`, `b.x` 为 `{ n: 2 }`\n\nLink:\n> [由ES规范学JavaScript(二)：深入理解“连等赋值”问题](https://segmentfault.com/a/1190000004224719)\n\n# 立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)\n```js\n(function A() {\n    console.log(A) // [Function A]\n    A = 1\n    console.log(window.A) // undefined\n    console.log(A) // [Function A]\n}())\n```\n上面立即执行函数中直接将1赋值给一个未声明的变量，正常逻辑下我们知道会将他绑定的全局作为全局变量，但是上面的输出显然不是如此，原因在于匿名执行函数有了名字且和赋值的变量A同名\n\n有了名字的函数（NFE）有两个特性：\n- 作为函数名的标识符（在这里是 A ）只能从函数体内部访问，在函数外部访问不到 (IE9+)\n- 绑定为函数名的标识符（在这里是A）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），所以在 NFE 函数体内对 A 重新赋值是无效的\n\n创建 NFE 的机制：\n> The production FunctionExpression : function Identifier (\nFormalParameterListopt ) { FunctionBody }\nis evaluated as follows:\n  - Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument\n  - Let envRec be funcEnv’s environment record.\n  - Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.\n  - Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.\n  - Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.\n  - Return closure.\n\n注意步骤 3 和 5，分别调用了 createImmutableBinding 和 InitializeImmutableBinding 内部方法，**创建的是不可更改的绑定**\n\n要理解这两个特性，最重要的是搞清楚标识符 A的绑定记录保存在哪里。让我们问自己几个问题：\n1. 标识符 A 与 该 NFE 是什么关系？ 两层关系：首先，该 NFE 的 name 属性是 字符串 'A'；更重要的是，A是该 NFE 的一个自由变量。在函数体内部，我们引用了 A，但 A 既不是该 NFE 的形参，又不是它的局部变量，那它不是自由变量是什么！解析自由变量，要从函数的 [[scope]] 内部属性所保存的词法环境 (Lexical Environment) 中查找变量的绑定记录。\n\n2. 标识符 A 保存在全局执行环境（Global Execution Context）的词法环境(Lexical Environment)中吗？ 答案是否。如果你仔细看过 ES5 Section 13 这一节，会发现创建 NFE 比创建 匿名函数表达式 （Anonymous Function Expression, AFE） 和 函数声明 (Function Declaration) 的过程要复杂得多\n\n那么为何创建 NFE 要搞得那么复杂呢？就是为了实现 NFE 的只能从函数内部访问A，而不能从外部访问这一特性！咋实现的？ 创建 NFE 时，创建了一个专门的词法环境用于保存 A 的绑定记录(见上面步骤 1~3)！对于 NFE, 有如下关系：\n```js\nA.[[scope]]\n  --->  Lexical Environment {'environment record': {A: function ...}, outer: --}\n  ---> Lexical Environment of Global Context {'environment record': {...}, outer --}\n  ---> null\n```\n\n可见，A 的绑定记录不在全局执行上下文的词法环境中，故不能从外部访问\n\n但是有个疑问：如果内部输出的时候进行赋值呢？\n```js\n(function A() {\n    console.log(A = 100) // 100\n}())\n```\n却可以打印出100，<a href=\"#JS引擎对赋值表达式的处理过程\">JS引擎对赋值表达式的处理过程</a>中我们知道赋值表达式最终结果是返回这个值，如果NFE内部没有成功赋值为何可以打印出100呢？\n\nLink:\n> [在JavaScript的立即执行的具名函数A内修改A的值时到底发生了什么](https://segmentfault.com/q/1010000002810093)","source":"_posts/writeSomething/interestingCode.md","raw":"---\ntitle: 有趣的JS题目整理\ntags:\n  - interview\ndate: 2019-03-012 19:33:00\ncategories: 你应该知道的\n---\n\nJS相关各类型题目记录\n<!--more-->\n\n# JS执行上下文（作用域）以及变量提升\n先看题目：以下代码输出分别是什么\n\n###### 平安的一道笔试题\n```js\nvar a = 10\n\nfunction fn() {\n  a()\n\n  try {\n    a()\n    console.log(a, ' try')\n    a = 100\n  } catch (e) {\n    a = 1\n    console.log(a, ' catch')\n  }\n  \n  console.log(a, ' inner function fn')\n\n  function a() {\n    console.log(a, ' inner function a')\n    a = 1000\n  }\n}\n\nfn()\nconsole.log(a, 'outer result')\n\n```\n先试着预想一下执行结果\n.\n.\n.\n.\n.\n.\n输出\n```js\n// [Function] inner function a\n// 1 catch\n// 1 inner function fn\n// 10 outer result\n```\n是否和预想的一致呢？\n\n先来了解几个概念：\n - 每一个函数都有自己的执行上下文EC（执行环境 execution context）\n   - 全局脚本是一个全局上下文\n - EC预解析的时候会有变量提升\n   - 只有关键字声明的变量才会有变量提升\n   - 函数优先级高于普通变量\n\n下面开始分析一下执行结果\n首先 fn 会获得变量提升然后声明并且赋值全局变量 `var a = 10` \n\n执行fn：\n  - 首先 fn 内部进行变量提升\n    - 内部函数a提升到当前EC顶部\n    - ```js\n      function fn() {\n        function a() {\n          console.log(a, ' inner function a')\n          a = 1000\n        }\n        a()\n      }\n      ```\n    - 主要的一点：fn 内部的变量 a 已经被重新声明 相当于 `var a = function () {}` 所以此处 fn 内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局\n\nfn内部输出：\n  - a本身是个函数，invoke a() 输出 `[Function] inner function a`，然后将fn内部的 a 重新赋值为1000\n  - 执行try语句：\n    - a是1000所以 invoke a()会抛出异常 `a is not a function` 被catch语句捕获，当前try语句终端不在继续向下执行\n      - *try语句内部的 `a = 100` 只是简单的赋值操作，没有关键字声明所以没有变量提升*\n  - 执行catch语句\n    - 重新赋值 `a = 1`，输出 `a catch`\n  - try catch语句执行结束继续向下执行, 此时a已经被catch语句赋值为1输出 `1 inner function fn`\n\nfn执行结束继续执行全局上下文环境中的代码，上面说了fn内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局, 所以全局上下文中a依旧是10，输出 10\n运行结束\n\n# 深入理解“连等赋值”问题\n```js\nvar a = { n: 1 }\nvar b = a\na.x = a = { n: 2 }\nalert(a.x) // --> undefined\nalert(b.x) // --> { n: 2 }\n```\n\n理解该问题需要知道以下两点：\n- JS引擎对赋值表达式的处理过程\n- 赋值运算的右结合性\n\n#### JS引擎对赋值表达式的处理过程\n如赋值表达式 `A = B`\n1. 计算表达式左表达式A，得到一个引用refA\n2. 计算表达式B，得到一个引用refB\n3. 通过 `GetValue(refB)` 得到valueB\n4. 进行判断，当如下情况全部符合则抛出语法异常\n   1. refA是一个引用\n   2. refA是一个严格引用\n   3. refA是一个 `environment records`(**这里理解是refA是一个声明的变量或者是对象的某个属性**)\n   4. refA的引用名是’eval‘或’arguments‘\n5. 将valueB赋给refA指向的名称绑定\n6. 返回valueB\n\n*`GetValue(refB)` 是通过一系列判断得出value值，具体步骤参考[GetValue(refB)](http://es5.github.io/#x8.7.1)*\n\n具体参考：\n> [http://es5.github.io/#x11.13.1](http://es5.github.io/#x11.13.1)\n\n#### 结合性\n所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。\n赋值表达式是右结合的。这意味着：`A1 = A2 = A3 = A4` 等价于 `A1 = (A2 = (A3 = A4))`\n\n\n总的简单s来说就是：***先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用***\n\n#### 分析\n```js\na.x = a = { n: 2 }\n```\n首先得到 a.x 和 a 的两个引用\n得到右表达式是一个对象 `{ n: 2 }`\na.x 和 a 的两个引用并且判断属于 `environment records`（a.x 属于对象的某个属性，a属于当前上下文的变量a）\n将 `{ n: 2 }` 赋值给 当前上下文变量 a 的 refA，a已被重新赋值为 `{ n: 2 }`\n将 `{ n: 2 }` 赋值给 当前上下文变量 a.x 的 ref（a.x）*ref（a.x）与ref（b.x）是同一个*, refA已经与 `{ n: 2 }` 重新绑定，所以此时 b 为 `{ n: 1, x: { n: 2 } }`\n\n所以最终结果：a为 `{ n：2 }`，b为 `{ n: 1, x: { n: 2 } }`, 并且由于是同一个对象 `{ n: 2 }` 赋值给b.x以及a获得的引用相同，所以 `b.x === a`\n\n所以 `a.x` 为 `undefined`, `b.x` 为 `{ n: 2 }`\n\nLink:\n> [由ES规范学JavaScript(二)：深入理解“连等赋值”问题](https://segmentfault.com/a/1190000004224719)\n\n# 立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)\n```js\n(function A() {\n    console.log(A) // [Function A]\n    A = 1\n    console.log(window.A) // undefined\n    console.log(A) // [Function A]\n}())\n```\n上面立即执行函数中直接将1赋值给一个未声明的变量，正常逻辑下我们知道会将他绑定的全局作为全局变量，但是上面的输出显然不是如此，原因在于匿名执行函数有了名字且和赋值的变量A同名\n\n有了名字的函数（NFE）有两个特性：\n- 作为函数名的标识符（在这里是 A ）只能从函数体内部访问，在函数外部访问不到 (IE9+)\n- 绑定为函数名的标识符（在这里是A）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），所以在 NFE 函数体内对 A 重新赋值是无效的\n\n创建 NFE 的机制：\n> The production FunctionExpression : function Identifier (\nFormalParameterListopt ) { FunctionBody }\nis evaluated as follows:\n  - Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument\n  - Let envRec be funcEnv’s environment record.\n  - Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.\n  - Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.\n  - Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.\n  - Return closure.\n\n注意步骤 3 和 5，分别调用了 createImmutableBinding 和 InitializeImmutableBinding 内部方法，**创建的是不可更改的绑定**\n\n要理解这两个特性，最重要的是搞清楚标识符 A的绑定记录保存在哪里。让我们问自己几个问题：\n1. 标识符 A 与 该 NFE 是什么关系？ 两层关系：首先，该 NFE 的 name 属性是 字符串 'A'；更重要的是，A是该 NFE 的一个自由变量。在函数体内部，我们引用了 A，但 A 既不是该 NFE 的形参，又不是它的局部变量，那它不是自由变量是什么！解析自由变量，要从函数的 [[scope]] 内部属性所保存的词法环境 (Lexical Environment) 中查找变量的绑定记录。\n\n2. 标识符 A 保存在全局执行环境（Global Execution Context）的词法环境(Lexical Environment)中吗？ 答案是否。如果你仔细看过 ES5 Section 13 这一节，会发现创建 NFE 比创建 匿名函数表达式 （Anonymous Function Expression, AFE） 和 函数声明 (Function Declaration) 的过程要复杂得多\n\n那么为何创建 NFE 要搞得那么复杂呢？就是为了实现 NFE 的只能从函数内部访问A，而不能从外部访问这一特性！咋实现的？ 创建 NFE 时，创建了一个专门的词法环境用于保存 A 的绑定记录(见上面步骤 1~3)！对于 NFE, 有如下关系：\n```js\nA.[[scope]]\n  --->  Lexical Environment {'environment record': {A: function ...}, outer: --}\n  ---> Lexical Environment of Global Context {'environment record': {...}, outer --}\n  ---> null\n```\n\n可见，A 的绑定记录不在全局执行上下文的词法环境中，故不能从外部访问\n\n但是有个疑问：如果内部输出的时候进行赋值呢？\n```js\n(function A() {\n    console.log(A = 100) // 100\n}())\n```\n却可以打印出100，<a href=\"#JS引擎对赋值表达式的处理过程\">JS引擎对赋值表达式的处理过程</a>中我们知道赋值表达式最终结果是返回这个值，如果NFE内部没有成功赋值为何可以打印出100呢？\n\nLink:\n> [在JavaScript的立即执行的具名函数A内修改A的值时到底发生了什么](https://segmentfault.com/q/1010000002810093)","slug":"writeSomething/interestingCode","published":1,"updated":"2019-03-22T08:46:13.614Z","_id":"cjtbdahht000kzk48o7ugb0nl","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JS相关各类型题目记录<br><a id=\"more\"></a></p>\n<h1 id=\"JS执行上下文（作用域）以及变量提升\"><a href=\"#JS执行上下文（作用域）以及变量提升\" class=\"headerlink\" title=\"JS执行上下文（作用域）以及变量提升\"></a>JS执行上下文（作用域）以及变量提升</h1><p>先看题目：以下代码输出分别是什么</p>\n<h6 id=\"平安的一道笔试题\"><a href=\"#平安的一道笔试题\" class=\"headerlink\" title=\"平安的一道笔试题\"></a>平安的一道笔试题</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  a()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    a()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' try'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">100</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' catch'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function fn'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function a'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">1000</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, <span class=\"string\">'outer result'</span>)</span><br></pre></td></tr></table></figure>\n<p>先试着预想一下执行结果<br>.<br>.<br>.<br>.<br>.<br>.<br>输出<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [Function] inner function a</span></span><br><span class=\"line\"><span class=\"comment\">// 1 catch</span></span><br><span class=\"line\"><span class=\"comment\">// 1 inner function fn</span></span><br><span class=\"line\"><span class=\"comment\">// 10 outer result</span></span><br></pre></td></tr></table></figure></p>\n<p>是否和预想的一致呢？</p>\n<p>先来了解几个概念：</p>\n<ul>\n<li>每一个函数都有自己的执行上下文EC（执行环境 execution context）<ul>\n<li>全局脚本是一个全局上下文</li>\n</ul>\n</li>\n<li>EC预解析的时候会有变量提升<ul>\n<li>只有关键字声明的变量才会有变量提升</li>\n<li>函数优先级高于普通变量</li>\n</ul>\n</li>\n</ul>\n<p>下面开始分析一下执行结果<br>首先 fn 会获得变量提升然后声明并且赋值全局变量 <code>var a = 10</code> </p>\n<p>执行fn：</p>\n<ul>\n<li><p>首先 fn 内部进行变量提升</p>\n<ul>\n<li>内部函数a提升到当前EC顶部</li>\n<li><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function a'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">1000</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  a()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>主要的一点：fn 内部的变量 a 已经被重新声明 相当于 <code>var a = function () {}</code> 所以此处 fn 内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>fn内部输出：</p>\n<ul>\n<li>a本身是个函数，invoke a() 输出 <code>[Function] inner function a</code>，然后将fn内部的 a 重新赋值为1000</li>\n<li>执行try语句：<ul>\n<li>a是1000所以 invoke a()会抛出异常 <code>a is not a function</code> 被catch语句捕获，当前try语句终端不在继续向下执行<ul>\n<li><em>try语句内部的 <code>a = 100</code> 只是简单的赋值操作，没有关键字声明所以没有变量提升</em></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>执行catch语句<ul>\n<li>重新赋值 <code>a = 1</code>，输出 <code>a catch</code></li>\n</ul>\n</li>\n<li>try catch语句执行结束继续向下执行, 此时a已经被catch语句赋值为1输出 <code>1 inner function fn</code></li>\n</ul>\n<p>fn执行结束继续执行全局上下文环境中的代码，上面说了fn内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局, 所以全局上下文中a依旧是10，输出 10<br>运行结束</p>\n<h1 id=\"深入理解“连等赋值”问题\"><a href=\"#深入理解“连等赋值”问题\" class=\"headerlink\" title=\"深入理解“连等赋值”问题\"></a>深入理解“连等赋值”问题</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a</span><br><span class=\"line\">a.x = a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">alert(a.x) <span class=\"comment\">// --&gt; undefined</span></span><br><span class=\"line\">alert(b.x) <span class=\"comment\">// --&gt; &#123; n: 2 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>理解该问题需要知道以下两点：</p>\n<ul>\n<li>JS引擎对赋值表达式的处理过程</li>\n<li>赋值运算的右结合性</li>\n</ul>\n<h4 id=\"JS引擎对赋值表达式的处理过程\"><a href=\"#JS引擎对赋值表达式的处理过程\" class=\"headerlink\" title=\"JS引擎对赋值表达式的处理过程\"></a>JS引擎对赋值表达式的处理过程</h4><p>如赋值表达式 <code>A = B</code></p>\n<ol>\n<li>计算表达式左表达式A，得到一个引用refA</li>\n<li>计算表达式B，得到一个引用refB</li>\n<li>通过 <code>GetValue(refB)</code> 得到valueB</li>\n<li>进行判断，当如下情况全部符合则抛出语法异常<ol>\n<li>refA是一个引用</li>\n<li>refA是一个严格引用</li>\n<li>refA是一个 <code>environment records</code>(<strong>这里理解是refA是一个声明的变量或者是对象的某个属性</strong>)</li>\n<li>refA的引用名是’eval‘或’arguments‘</li>\n</ol>\n</li>\n<li>将valueB赋给refA指向的名称绑定</li>\n<li>返回valueB</li>\n</ol>\n<p><em><code>GetValue(refB)</code> 是通过一系列判断得出value值，具体步骤参考<a href=\"http://es5.github.io/#x8.7.1\" target=\"_blank\" rel=\"noopener\">GetValue(refB)</a></em></p>\n<p>具体参考：</p>\n<blockquote>\n<p><a href=\"http://es5.github.io/#x11.13.1\" target=\"_blank\" rel=\"noopener\">http://es5.github.io/#x11.13.1</a></p>\n</blockquote>\n<h4 id=\"结合性\"><a href=\"#结合性\" class=\"headerlink\" title=\"结合性\"></a>结合性</h4><p>所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。<br>赋值表达式是右结合的。这意味着：<code>A1 = A2 = A3 = A4</code> 等价于 <code>A1 = (A2 = (A3 = A4))</code></p>\n<p>总的简单s来说就是：<strong><em>先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用</em></strong></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.x = a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">2</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>首先得到 a.x 和 a 的两个引用<br>得到右表达式是一个对象 <code>{ n: 2 }</code><br>a.x 和 a 的两个引用并且判断属于 <code>environment records</code>（a.x 属于对象的某个属性，a属于当前上下文的变量a）<br>将 <code>{ n: 2 }</code> 赋值给 当前上下文变量 a 的 refA，a已被重新赋值为 <code>{ n: 2 }</code><br>将 <code>{ n: 2 }</code> 赋值给 当前上下文变量 a.x 的 ref（a.x）<em>ref（a.x）与ref（b.x）是同一个</em>, refA已经与 <code>{ n: 2 }</code> 重新绑定，所以此时 b 为 <code>{ n: 1, x: { n: 2 } }</code></p>\n<p>所以最终结果：a为 <code>{ n：2 }</code>，b为 <code>{ n: 1, x: { n: 2 } }</code>, 并且由于是同一个对象 <code>{ n: 2 }</code> 赋值给b.x以及a获得的引用相同，所以 <code>b.x === a</code></p>\n<p>所以 <code>a.x</code> 为 <code>undefined</code>, <code>b.x</code> 为 <code>{ n: 2 }</code></p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000004224719\" target=\"_blank\" rel=\"noopener\">由ES规范学JavaScript(二)：深入理解“连等赋值”问题</a></p>\n</blockquote>\n<h1 id=\"立即执行的函数-Immediately-invoked-function-的具名函数表达式-Named-function-expression-NFE\"><a href=\"#立即执行的函数-Immediately-invoked-function-的具名函数表达式-Named-function-expression-NFE\" class=\"headerlink\" title=\"立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)\"></a>立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A) <span class=\"comment\">// [Function A]</span></span><br><span class=\"line\">    A = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.A) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A) <span class=\"comment\">// [Function A]</span></span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure>\n<p>上面立即执行函数中直接将1赋值给一个未声明的变量，正常逻辑下我们知道会将他绑定的全局作为全局变量，但是上面的输出显然不是如此，原因在于匿名执行函数有了名字且和赋值的变量A同名</p>\n<p>有了名字的函数（NFE）有两个特性：</p>\n<ul>\n<li>作为函数名的标识符（在这里是 A ）只能从函数体内部访问，在函数外部访问不到 (IE9+)</li>\n<li>绑定为函数名的标识符（在这里是A）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），所以在 NFE 函数体内对 A 重新赋值是无效的</li>\n</ul>\n<p>创建 NFE 的机制：</p>\n<blockquote>\n<p>The production FunctionExpression : function Identifier (<br>FormalParameterListopt ) { FunctionBody }<br>is evaluated as follows:</p>\n<ul>\n<li>Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument</li>\n<li>Let envRec be funcEnv’s environment record.</li>\n<li>Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.</li>\n<li>Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.</li>\n<li>Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.</li>\n<li>Return closure.</li>\n</ul>\n</blockquote>\n<p>注意步骤 3 和 5，分别调用了 createImmutableBinding 和 InitializeImmutableBinding 内部方法，<strong>创建的是不可更改的绑定</strong></p>\n<p>要理解这两个特性，最重要的是搞清楚标识符 A的绑定记录保存在哪里。让我们问自己几个问题：</p>\n<ol>\n<li><p>标识符 A 与 该 NFE 是什么关系？ 两层关系：首先，该 NFE 的 name 属性是 字符串 ‘A’；更重要的是，A是该 NFE 的一个自由变量。在函数体内部，我们引用了 A，但 A 既不是该 NFE 的形参，又不是它的局部变量，那它不是自由变量是什么！解析自由变量，要从函数的 [[scope]] 内部属性所保存的词法环境 (Lexical Environment) 中查找变量的绑定记录。</p>\n</li>\n<li><p>标识符 A 保存在全局执行环境（Global Execution Context）的词法环境(Lexical Environment)中吗？ 答案是否。如果你仔细看过 ES5 Section 13 这一节，会发现创建 NFE 比创建 匿名函数表达式 （Anonymous Function Expression, AFE） 和 函数声明 (Function Declaration) 的过程要复杂得多</p>\n</li>\n</ol>\n<p>那么为何创建 NFE 要搞得那么复杂呢？就是为了实现 NFE 的只能从函数内部访问A，而不能从外部访问这一特性！咋实现的？ 创建 NFE 时，创建了一个专门的词法环境用于保存 A 的绑定记录(见上面步骤 1~3)！对于 NFE, 有如下关系：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A.[[scope]]</span><br><span class=\"line\">  ---&gt;  Lexical Environment &#123;<span class=\"string\">'environment record'</span>: &#123;<span class=\"attr\">A</span>: <span class=\"function\"><span class=\"keyword\">function</span> ...&#125;, <span class=\"title\">outer</span>: --&#125;</span></span><br><span class=\"line\"><span class=\"function\">  ---&gt; <span class=\"title\">Lexical</span> <span class=\"title\">Environment</span> <span class=\"title\">of</span> <span class=\"title\">Global</span> <span class=\"title\">Context</span> </span>&#123;<span class=\"string\">'environment record'</span>: &#123;...&#125;, outer --&#125;</span><br><span class=\"line\">  ---&gt; <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure></p>\n<p>可见，A 的绑定记录不在全局执行上下文的词法环境中，故不能从外部访问</p>\n<p>但是有个疑问：如果内部输出的时候进行赋值呢？<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A = <span class=\"number\">100</span>) <span class=\"comment\">// 100</span></span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure></p>\n<p>却可以打印出100，<a href=\"#JS引擎对赋值表达式的处理过程\">JS引擎对赋值表达式的处理过程</a>中我们知道赋值表达式最终结果是返回这个值，如果NFE内部没有成功赋值为何可以打印出100呢？</p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/q/1010000002810093\" target=\"_blank\" rel=\"noopener\">在JavaScript的立即执行的具名函数A内修改A的值时到底发生了什么</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>JS相关各类型题目记录<br></p>","more":"<p></p>\n<h1 id=\"JS执行上下文（作用域）以及变量提升\"><a href=\"#JS执行上下文（作用域）以及变量提升\" class=\"headerlink\" title=\"JS执行上下文（作用域）以及变量提升\"></a>JS执行上下文（作用域）以及变量提升</h1><p>先看题目：以下代码输出分别是什么</p>\n<h6 id=\"平安的一道笔试题\"><a href=\"#平安的一道笔试题\" class=\"headerlink\" title=\"平安的一道笔试题\"></a>平安的一道笔试题</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  a()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    a()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' try'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">100</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' catch'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function fn'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function a'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">1000</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a, <span class=\"string\">'outer result'</span>)</span><br></pre></td></tr></table></figure>\n<p>先试着预想一下执行结果<br>.<br>.<br>.<br>.<br>.<br>.<br>输出<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [Function] inner function a</span></span><br><span class=\"line\"><span class=\"comment\">// 1 catch</span></span><br><span class=\"line\"><span class=\"comment\">// 1 inner function fn</span></span><br><span class=\"line\"><span class=\"comment\">// 10 outer result</span></span><br></pre></td></tr></table></figure></p>\n<p>是否和预想的一致呢？</p>\n<p>先来了解几个概念：</p>\n<ul>\n<li>每一个函数都有自己的执行上下文EC（执行环境 execution context）<ul>\n<li>全局脚本是一个全局上下文</li>\n</ul>\n</li>\n<li>EC预解析的时候会有变量提升<ul>\n<li>只有关键字声明的变量才会有变量提升</li>\n<li>函数优先级高于普通变量</li>\n</ul>\n</li>\n</ul>\n<p>下面开始分析一下执行结果<br>首先 fn 会获得变量提升然后声明并且赋值全局变量 <code>var a = 10</code> </p>\n<p>执行fn：</p>\n<ul>\n<li><p>首先 fn 内部进行变量提升</p>\n<ul>\n<li>内部函数a提升到当前EC顶部</li>\n<li><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a, <span class=\"string\">' inner function a'</span>)</span><br><span class=\"line\">    a = <span class=\"number\">1000</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  a()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>主要的一点：fn 内部的变量 a 已经被重新声明 相当于 <code>var a = function () {}</code> 所以此处 fn 内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>fn内部输出：</p>\n<ul>\n<li>a本身是个函数，invoke a() 输出 <code>[Function] inner function a</code>，然后将fn内部的 a 重新赋值为1000</li>\n<li>执行try语句：<ul>\n<li>a是1000所以 invoke a()会抛出异常 <code>a is not a function</code> 被catch语句捕获，当前try语句终端不在继续向下执行<ul>\n<li><em>try语句内部的 <code>a = 100</code> 只是简单的赋值操作，没有关键字声明所以没有变量提升</em></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>执行catch语句<ul>\n<li>重新赋值 <code>a = 1</code>，输出 <code>a catch</code></li>\n</ul>\n</li>\n<li>try catch语句执行结束继续向下执行, 此时a已经被catch语句赋值为1输出 <code>1 inner function fn</code></li>\n</ul>\n<p>fn执行结束继续执行全局上下文环境中的代码，上面说了fn内部的 a 相当于局部变量不在和全局上下文的a关联，fn内部改变不会影响到全局, 所以全局上下文中a依旧是10，输出 10<br>运行结束</p>\n<h1 id=\"深入理解“连等赋值”问题\"><a href=\"#深入理解“连等赋值”问题\" class=\"headerlink\" title=\"深入理解“连等赋值”问题\"></a>深入理解“连等赋值”问题</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a</span><br><span class=\"line\">a.x = a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">alert(a.x) <span class=\"comment\">// --&gt; undefined</span></span><br><span class=\"line\">alert(b.x) <span class=\"comment\">// --&gt; &#123; n: 2 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>理解该问题需要知道以下两点：</p>\n<ul>\n<li>JS引擎对赋值表达式的处理过程</li>\n<li>赋值运算的右结合性</li>\n</ul>\n<h4 id=\"JS引擎对赋值表达式的处理过程\"><a href=\"#JS引擎对赋值表达式的处理过程\" class=\"headerlink\" title=\"JS引擎对赋值表达式的处理过程\"></a>JS引擎对赋值表达式的处理过程</h4><p>如赋值表达式 <code>A = B</code></p>\n<ol>\n<li>计算表达式左表达式A，得到一个引用refA</li>\n<li>计算表达式B，得到一个引用refB</li>\n<li>通过 <code>GetValue(refB)</code> 得到valueB</li>\n<li>进行判断，当如下情况全部符合则抛出语法异常<ol>\n<li>refA是一个引用</li>\n<li>refA是一个严格引用</li>\n<li>refA是一个 <code>environment records</code>(<strong>这里理解是refA是一个声明的变量或者是对象的某个属性</strong>)</li>\n<li>refA的引用名是’eval‘或’arguments‘</li>\n</ol>\n</li>\n<li>将valueB赋给refA指向的名称绑定</li>\n<li>返回valueB</li>\n</ol>\n<p><em><code>GetValue(refB)</code> 是通过一系列判断得出value值，具体步骤参考<a href=\"http://es5.github.io/#x8.7.1\" target=\"_blank\" rel=\"noopener\">GetValue(refB)</a></em></p>\n<p>具体参考：</p>\n<blockquote>\n<p><a href=\"http://es5.github.io/#x11.13.1\" target=\"_blank\" rel=\"noopener\">http://es5.github.io/#x11.13.1</a></p>\n</blockquote>\n<h4 id=\"结合性\"><a href=\"#结合性\" class=\"headerlink\" title=\"结合性\"></a>结合性</h4><p>所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。<br>赋值表达式是右结合的。这意味着：<code>A1 = A2 = A3 = A4</code> 等价于 <code>A1 = (A2 = (A3 = A4))</code></p>\n<p>总的简单s来说就是：<strong><em>先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用</em></strong></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.x = a = &#123; <span class=\"attr\">n</span>: <span class=\"number\">2</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>首先得到 a.x 和 a 的两个引用<br>得到右表达式是一个对象 <code>{ n: 2 }</code><br>a.x 和 a 的两个引用并且判断属于 <code>environment records</code>（a.x 属于对象的某个属性，a属于当前上下文的变量a）<br>将 <code>{ n: 2 }</code> 赋值给 当前上下文变量 a 的 refA，a已被重新赋值为 <code>{ n: 2 }</code><br>将 <code>{ n: 2 }</code> 赋值给 当前上下文变量 a.x 的 ref（a.x）<em>ref（a.x）与ref（b.x）是同一个</em>, refA已经与 <code>{ n: 2 }</code> 重新绑定，所以此时 b 为 <code>{ n: 1, x: { n: 2 } }</code></p>\n<p>所以最终结果：a为 <code>{ n：2 }</code>，b为 <code>{ n: 1, x: { n: 2 } }</code>, 并且由于是同一个对象 <code>{ n: 2 }</code> 赋值给b.x以及a获得的引用相同，所以 <code>b.x === a</code></p>\n<p>所以 <code>a.x</code> 为 <code>undefined</code>, <code>b.x</code> 为 <code>{ n: 2 }</code></p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000004224719\" target=\"_blank\" rel=\"noopener\">由ES规范学JavaScript(二)：深入理解“连等赋值”问题</a></p>\n</blockquote>\n<h1 id=\"立即执行的函数-Immediately-invoked-function-的具名函数表达式-Named-function-expression-NFE\"><a href=\"#立即执行的函数-Immediately-invoked-function-的具名函数表达式-Named-function-expression-NFE\" class=\"headerlink\" title=\"立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)\"></a>立即执行的函数(Immediately-invoked function)的具名函数表达式(Named function expression, NFE)</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A) <span class=\"comment\">// [Function A]</span></span><br><span class=\"line\">    A = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.A) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A) <span class=\"comment\">// [Function A]</span></span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure>\n<p>上面立即执行函数中直接将1赋值给一个未声明的变量，正常逻辑下我们知道会将他绑定的全局作为全局变量，但是上面的输出显然不是如此，原因在于匿名执行函数有了名字且和赋值的变量A同名</p>\n<p>有了名字的函数（NFE）有两个特性：</p>\n<ul>\n<li>作为函数名的标识符（在这里是 A ）只能从函数体内部访问，在函数外部访问不到 (IE9+)</li>\n<li>绑定为函数名的标识符（在这里是A）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），所以在 NFE 函数体内对 A 重新赋值是无效的</li>\n</ul>\n<p>创建 NFE 的机制：</p>\n<blockquote>\n<p>The production FunctionExpression : function Identifier (<br>FormalParameterListopt ) { FunctionBody }<br>is evaluated as follows:</p>\n<ul>\n<li>Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument</li>\n<li>Let envRec be funcEnv’s environment record.</li>\n<li>Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.</li>\n<li>Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.</li>\n<li>Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.</li>\n<li>Return closure.</li>\n</ul>\n</blockquote>\n<p>注意步骤 3 和 5，分别调用了 createImmutableBinding 和 InitializeImmutableBinding 内部方法，<strong>创建的是不可更改的绑定</strong></p>\n<p>要理解这两个特性，最重要的是搞清楚标识符 A的绑定记录保存在哪里。让我们问自己几个问题：</p>\n<ol>\n<li><p>标识符 A 与 该 NFE 是什么关系？ 两层关系：首先，该 NFE 的 name 属性是 字符串 ‘A’；更重要的是，A是该 NFE 的一个自由变量。在函数体内部，我们引用了 A，但 A 既不是该 NFE 的形参，又不是它的局部变量，那它不是自由变量是什么！解析自由变量，要从函数的 [[scope]] 内部属性所保存的词法环境 (Lexical Environment) 中查找变量的绑定记录。</p>\n</li>\n<li><p>标识符 A 保存在全局执行环境（Global Execution Context）的词法环境(Lexical Environment)中吗？ 答案是否。如果你仔细看过 ES5 Section 13 这一节，会发现创建 NFE 比创建 匿名函数表达式 （Anonymous Function Expression, AFE） 和 函数声明 (Function Declaration) 的过程要复杂得多</p>\n</li>\n</ol>\n<p>那么为何创建 NFE 要搞得那么复杂呢？就是为了实现 NFE 的只能从函数内部访问A，而不能从外部访问这一特性！咋实现的？ 创建 NFE 时，创建了一个专门的词法环境用于保存 A 的绑定记录(见上面步骤 1~3)！对于 NFE, 有如下关系：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A.[[scope]]</span><br><span class=\"line\">  ---&gt;  Lexical Environment &#123;<span class=\"string\">'environment record'</span>: &#123;<span class=\"attr\">A</span>: <span class=\"function\"><span class=\"keyword\">function</span> ...&#125;, <span class=\"title\">outer</span>: --&#125;</span></span><br><span class=\"line\"><span class=\"function\">  ---&gt; <span class=\"title\">Lexical</span> <span class=\"title\">Environment</span> <span class=\"title\">of</span> <span class=\"title\">Global</span> <span class=\"title\">Context</span> </span>&#123;<span class=\"string\">'environment record'</span>: &#123;...&#125;, outer --&#125;</span><br><span class=\"line\">  ---&gt; <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure></p>\n<p>可见，A 的绑定记录不在全局执行上下文的词法环境中，故不能从外部访问</p>\n<p>但是有个疑问：如果内部输出的时候进行赋值呢？<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(A = <span class=\"number\">100</span>) <span class=\"comment\">// 100</span></span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure></p>\n<p>却可以打印出100，<a href=\"#JS引擎对赋值表达式的处理过程\">JS引擎对赋值表达式的处理过程</a>中我们知道赋值表达式最终结果是返回这个值，如果NFE内部没有成功赋值为何可以打印出100呢？</p>\n<p>Link:</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/q/1010000002810093\" target=\"_blank\" rel=\"noopener\">在JavaScript的立即执行的具名函数A内修改A的值时到底发生了什么</a></p>\n</blockquote>"},{"title":"JS常用的设计模式","date":"2019-02-24T14:52:00.000Z","_content":"持续更新\nJS常用的设计模式以及应用场景\n<!-- more -->\n*以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝*\n\n# 何谓设计模式\n\n没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多\n\n抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位\n\n定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案\n\n补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题\n\n软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍\n\n# 设计原则\n在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：\n- 单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度\n\n- 最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理\n\n- 开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定\n\n\n\n# 从最简单的单体/单例模式开始\n\n### 定义：\n\n单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象\n\n单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例\n*在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供*\n\n### 优点:\n- 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例\n- 因为类控制了实例化过程，所以类可以灵活更改实例化过程\n- 单体可以控制局部变量污染\n\n### 应用场景：\n- 可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存\n- 借助单例模式，可以把代码组织的更为一致\n\n#### 最基本的单体模式\n直接导出一个方法属性集合的对象\n```js\n// commonjs 导出\nmodule.exports = {\n  getSingleton() {\n    return this \n  }\n}\n```\n#### 用闭包来实现单例\n```js\nconst Ins1 = (function() {\n  let instance = null\n  // 利用闭包特性保证实例私有化\n  return function(opt) {\n    if (instance === null) {\n      instance = this\n    }\n\n    for(let k in opt) {\n      instance[k] = opt[k]\n    }\n\n    return instance\n  }\n})()\n```\n测试：\n```js\nconst i1 = new Ins1({ name: 'i1' })\n\nconst i2 = new Ins1({ name: 'i2' })\n\nconsole.log(i1 === i2) // true\n\nconsole.log(i1.name) // i2\n```\n补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： `class T {} export default new T` 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化\n\n# 策略模式\n\n### 定义：\n就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则\n\n### 优点：\n- 减少`command c & command v`, 提高复用性\n- 遵循开闭原则，算法独立易于切换、理解、拓展\n\n### 应用场景：\n针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试\n\n#### 最简单的执行\n```js\nfunction closure() {\n  // 定义\n  const strategies = {\n      plus10: function(arg) {\n        return arg + 10\n      },\n      plus100: function(arg) {\n        return arg + 100\n      }\n  }\n  // 执行\n  return function(plus, base){\n    return strategies[plus](base);\n  }\n}\nconst strategy = closure()\n\nconsole.log(strategy('plus10', 1)) // 11\nconsole.log(strategy('plus100', 1)) // 101\n```\n#### 对比分析\neg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额\n\n意大利逻辑:\n\n```js\nfunction context (name, type, price) {\n  if (type === 'vip') {\n    return price * 0.5\n  } else if (type === 'vip') {\n    return price * 0.8\n  } else {\n    return price\n  }\n}\n```\n如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:\n``` js\nclass Vip {\n  constructor () {\n    this.discount = 0.5\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Old {\n  constructor () {\n    this.discount = 0.8\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Others {\n  constructor () {\n  }\n  getPrice (price) {\n    return price\n  }\n}\n\nclass Context {\n  constructor () {\n    this.name = ''\n    this.strategy = null\n    this.price = 0\n  }\n  setPrice (name, strategy, price) {\n    this.name = name\n    this.strategy = strategy\n    this.price = price\n  }\n  getPrice () {\n    console.log(this.name, this.strategy.getPrice(this.price), '元')\n    return this.strategy.getPrice(this.price)\n  }\n}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Vip\nconst old = new Old\nconst other = new Others\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本\n\n补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：\n```js\n// 定义父类\nclass Handler {\n  constructor(discount) {\n    // 不传为原价\n    this.discount = discount || 1\n  }\n\n  getPrice(price) {\n    return this.discount === 1\n      ? price\n      : this.discount * price\n  }\n}\n\n// 声明子类\nclass Sub extends Handler {}\n\n// 可以自定义更多不同级别顾客不同需求\n// class Test extend Handler {\n//   getGifts() {\n//     if (this.discount < 1) {\n//       // 赠送赠品\n//     }\n//   }\n// }\n// const master = new Test(0.1)\n// master.getGifts()\n\n// Context类同上方便统一接口输出\nclass Context {}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Sub(0.5)\nconst old = new Sub(0.8)\nconst other = new Sub\n\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n测试结果一致\n\n# 代理模式\n\n### 定义：\n为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用\n著名的代理模式例子为引用计数（reference counting）指针对象\n另外代理模式还可分为：\n- 虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象\n- 保护代理：用于控制不同权限的对象对目标对象的访问\n- 缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果\n\n### 优点：\n独立职责归属，便于维护测试\n\n### 应用场景：\n比如图片的懒加载，数据缓存等\n\n#### 虚拟代理实现图片懒加载\n```js\nconst imgSet = (() => {\n  let node = new Image\n  document.body.append(node)\n\n  return function(src) {\n    node.src = src\n  }\n})()\n\nconst proxyImg = (() => {\n  let _img = new Image\n\n  _img.onload = function() {\n    setTimeout(imgSet, 2000, this.src)\n  }\n\n  return function(src) {\n    imgSet('https://yphoto.eryufm.cn/upload/assets/jump.gif')\n    _img.src = src\n  }\n})()\n// call\nproxyImg(`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1551174639&di=90b4757f68c9480f78c132c930c1df10&src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`)\n```\n\n#### 保护代理\n对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发\n```js\n// filter some no use or unneed requestions or data\n// A  ---> B(proxy) ----> C\nconst a = {\n  name: 'a',\n  send (target, info) {\n    target.receive(info)\n  }\n}\nconst c = {\n  name: 'c',\n  receive (target, info) {\n    console.log('c receive ', info, ' from ', target.name)\n  }\n}\nconst b = {\n  name: 'b',\n  receive (info) {\n    if (info) {\n      c.receive(this, info)\n    }\n  }\n}\na.send(b, 'good morning')\na.send(b, '')\na.send(b, 'send again')\n\n// output:\n// c receive good morning from b\n// c receive send again from b\n```\n上面表示一个最简单的保护代理\n\n#### 缓存代理\n顾名思义就是缓存相关的代理\n\n有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存\n```js\n// 存储所有标签\nlet tags\n\nconst sendApiGetTags = index => {\n  // ajax.get('/api', { index })\n}\nlet proxyCache = (async () => {\n  const allTagsCache = {}\n  const number = 5\n  const all = []\n  const params = {}\n\n  for (let index = 0; index < number; index++) {\n    all.push(sendApiGetTags({\n      ...params,\n      index\n    }))\n  }\n  const list = await Promise.all(all)\n\n  list.forEach((res, i) => allTagsCache[i] = res)\n\n  return allTagsCache\n})()\n\nlet setTags = async index => {\n  // 缓存中有直接拿\n  if (proxyCache[index]) {\n    tags = proxyCache[index]\n  } else {\n  // 缓存中没有则重发请求\n    tags = await sendApiGetTags(index)\n  }\n}\n```\n\n\n\n# 发布订阅模式\n\n### 定义：\n一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。\n至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法\n\n### 优点：\n订阅者可以根据自己需求当某种Action被触发时完成自己的调度\n\n### 应用场景：\nAngularJs的广播、vue的eventbus等\n\n#### 根据主体构建发布订阅的基类\n构造发布者基类\n```js\nclass Publisher {\n  constructor () {\n    // 订阅发布者的队列 存储每个订阅者\n    this.subscribers = []\n  }\n  deliver (data) {\n    // 发布消息 调用订阅者的回调 告知订阅者\n    this.subscribers.forEach(fn => fn.shot(data))\n\n    return this\n  }\n}\n```\n构造订阅者基类\n```js\nclass Observer {\n  constructor (call) {\n    // 传入订阅回调\n    this.shot = call\n  }\n  subscribe (publisher) {\n    if (!publisher.subscribers.some(v => v.shot === this.shot)) {\n      console.log('订阅该消息')\n      // 判断当前订阅者是否订阅\n      publisher.subscribers.push(this)\n    }\n    return this\n  }\n  unsubscribe (publisher) {\n    // 移除当前订阅者\n    console.log('取消订阅')\n\n    publisher.subscribers = publisher.subscribers.filter(v => v.shot !== this.shot)\n\n    return this\n  }\n}\n```\n测试：\n```js\nconst pub = new Publisher\nconst pub2 = new Publisher\nconst obs = new Observer(deliver => console.log(deliver))\n\nobs.subscribe(pub) // 订阅该消息\nobs.subscribe(pub2) // 订阅该消息\n\npub.deliver('pub deliver first message') // pub deliver first message\npub2.deliver('pub2 deliver first message') // pub2 deliver first message\n\nobs.unsubscribe(pub) // 取消订阅\npub.deliver('pub deliver second message') //\n```\n\n# 装饰者模式\n\n### 定义：\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能\n\n### 优点：\n- 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互\n- 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展\n\n### 应用场景：\n- 需要扩展一个类的功能，或给一个类添加附加职责\n- 需要动态的给一个对象添加功能，这些功能可以再动态的撤销\n- 不必改动原本的逻辑造成不可知问题\n\n#### 给所有的函数调用添加调用前和调用后的钩子\n\n普通函数：\n```js\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nfn('let go') // lets go right now\n```\n我们知道JS中所有的函数都是基于父类 `Function` 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：\n```js\n// 执行前\nFunction.prototype.before = function (call) {\n  const fn = this\n  \n  // 返回体本身也是函数所以支持继续调用钩子\n  return function () {\n    // 调用钩子，同时参数传递到钩子内\n    call.apply(this, arguments)\n    // 调用自身\n    return fn.apply(this, arguments)\n  }\n}\n// 执行后\n// 和 before 同理\nFunction.prototype.after = function (call) {\n  const fn = this\n\n  return function () {\n    const res = fn.apply(this, arguments)\n\n    call.apply(this, arguments)\n\n    // 返回自身的返回值\n    return res\n  }\n}\n```\n测试：\n```js\n// 重新包装 fn\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nconst decoratorFn = fn.before(function (msg) {\n  console.log('when we go,', msg)\n}).after(function (msg){\n  console.log('had to go', msg)\n})\n\ndecoratorFn('lets go')\n\n// out put:\n// when we go, right now\n// lets go, right now\n// had to go, right now\n```\n# 职责链（责任链）模式\n\n### 定义：\n它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求\n\n### 优点：\n职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了\n\n### 应用场景：\nJS 中的事件冒泡（事件委托）就是经典案例\n\n#### 实例分析\n\n部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购\n下面分别抽象处理者构造基类\n\n责任链调度中心：\n```js\nclass Handler {\n  constructor() {\n    this.next = null\n  }\n  setNext(_handler) {\n    this.next = _handler\n  }\n  handleRequest(money) {}\n}\n\n\n```\n\n采购部经理：\n```js\nclass CGBHandler extends Handler {\n  handleRequest(money) {\n    // 1w\n    if (money < 10000){\n      console.log('1w以内，同意')\n    } else {\n      console.log('金额太大，只能处理1w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n总经理：\n```js\nclass ZJLHandler extends Handler {\n  handleRequest(money) {\n    // 10w\n    if (money < 100000){\n      console.log('10w以内，同意')\n    } else {\n      console.log('金额太大，只能处理10w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n董事长：\n```js\nclass DSZHandler extends Handler {\n  handleRequest(money) {\n    // 100w\n    if (money >= 100000){\n      console.log('10万以上的我来处理')\n      //处理其他逻辑\n    } \n  }\n}\n```\n\n封装客户端接口：\n```js\nconst dispatch = (function client() {\n  const cgb = new CGBHandler()\n  const zjl = new ZJLHandler()\n  const dsz = new DSZHandler()\n\n  cgb.setNext(zjl)\n  zjl.setNext(dsz)\n\n  return cgb.handleRequest.bind(cgb)\n})()\n```\n测试：\n```js\n\ndispath(800000)\n// output:\n// 金额太大，只能处理1w以内的采购\n// 金额太大，只能处理10w以内的采购\n// 10万以上的我来处理\n\ndispath(7000)\n// output:\n// 1w以内，同意\n\n```\n补充：\n- 纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理\n\n- 不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理\n\n.\n.\n.\n.\n.\n.\n未完待续...👏\n","source":"_posts/writeSomething/jsDesignPattern.md","raw":"---\ntitle: JS常用的设计模式\ntags:\n  - 设计模式\n  - 算法\ndate: 2019-02-24 22:52:00\ncategories: 算法\n---\n持续更新\nJS常用的设计模式以及应用场景\n<!-- more -->\n*以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝*\n\n# 何谓设计模式\n\n没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多\n\n抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位\n\n定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案\n\n补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题\n\n软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍\n\n# 设计原则\n在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：\n- 单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度\n\n- 最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理\n\n- 开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定\n\n\n\n# 从最简单的单体/单例模式开始\n\n### 定义：\n\n单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象\n\n单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例\n*在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供*\n\n### 优点:\n- 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例\n- 因为类控制了实例化过程，所以类可以灵活更改实例化过程\n- 单体可以控制局部变量污染\n\n### 应用场景：\n- 可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存\n- 借助单例模式，可以把代码组织的更为一致\n\n#### 最基本的单体模式\n直接导出一个方法属性集合的对象\n```js\n// commonjs 导出\nmodule.exports = {\n  getSingleton() {\n    return this \n  }\n}\n```\n#### 用闭包来实现单例\n```js\nconst Ins1 = (function() {\n  let instance = null\n  // 利用闭包特性保证实例私有化\n  return function(opt) {\n    if (instance === null) {\n      instance = this\n    }\n\n    for(let k in opt) {\n      instance[k] = opt[k]\n    }\n\n    return instance\n  }\n})()\n```\n测试：\n```js\nconst i1 = new Ins1({ name: 'i1' })\n\nconst i2 = new Ins1({ name: 'i2' })\n\nconsole.log(i1 === i2) // true\n\nconsole.log(i1.name) // i2\n```\n补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： `class T {} export default new T` 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化\n\n# 策略模式\n\n### 定义：\n就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则\n\n### 优点：\n- 减少`command c & command v`, 提高复用性\n- 遵循开闭原则，算法独立易于切换、理解、拓展\n\n### 应用场景：\n针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试\n\n#### 最简单的执行\n```js\nfunction closure() {\n  // 定义\n  const strategies = {\n      plus10: function(arg) {\n        return arg + 10\n      },\n      plus100: function(arg) {\n        return arg + 100\n      }\n  }\n  // 执行\n  return function(plus, base){\n    return strategies[plus](base);\n  }\n}\nconst strategy = closure()\n\nconsole.log(strategy('plus10', 1)) // 11\nconsole.log(strategy('plus100', 1)) // 101\n```\n#### 对比分析\neg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额\n\n意大利逻辑:\n\n```js\nfunction context (name, type, price) {\n  if (type === 'vip') {\n    return price * 0.5\n  } else if (type === 'vip') {\n    return price * 0.8\n  } else {\n    return price\n  }\n}\n```\n如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:\n``` js\nclass Vip {\n  constructor () {\n    this.discount = 0.5\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Old {\n  constructor () {\n    this.discount = 0.8\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Others {\n  constructor () {\n  }\n  getPrice (price) {\n    return price\n  }\n}\n\nclass Context {\n  constructor () {\n    this.name = ''\n    this.strategy = null\n    this.price = 0\n  }\n  setPrice (name, strategy, price) {\n    this.name = name\n    this.strategy = strategy\n    this.price = price\n  }\n  getPrice () {\n    console.log(this.name, this.strategy.getPrice(this.price), '元')\n    return this.strategy.getPrice(this.price)\n  }\n}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Vip\nconst old = new Old\nconst other = new Others\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本\n\n补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：\n```js\n// 定义父类\nclass Handler {\n  constructor(discount) {\n    // 不传为原价\n    this.discount = discount || 1\n  }\n\n  getPrice(price) {\n    return this.discount === 1\n      ? price\n      : this.discount * price\n  }\n}\n\n// 声明子类\nclass Sub extends Handler {}\n\n// 可以自定义更多不同级别顾客不同需求\n// class Test extend Handler {\n//   getGifts() {\n//     if (this.discount < 1) {\n//       // 赠送赠品\n//     }\n//   }\n// }\n// const master = new Test(0.1)\n// master.getGifts()\n\n// Context类同上方便统一接口输出\nclass Context {}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Sub(0.5)\nconst old = new Sub(0.8)\nconst other = new Sub\n\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n测试结果一致\n\n# 代理模式\n\n### 定义：\n为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用\n著名的代理模式例子为引用计数（reference counting）指针对象\n另外代理模式还可分为：\n- 虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象\n- 保护代理：用于控制不同权限的对象对目标对象的访问\n- 缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果\n\n### 优点：\n独立职责归属，便于维护测试\n\n### 应用场景：\n比如图片的懒加载，数据缓存等\n\n#### 虚拟代理实现图片懒加载\n```js\nconst imgSet = (() => {\n  let node = new Image\n  document.body.append(node)\n\n  return function(src) {\n    node.src = src\n  }\n})()\n\nconst proxyImg = (() => {\n  let _img = new Image\n\n  _img.onload = function() {\n    setTimeout(imgSet, 2000, this.src)\n  }\n\n  return function(src) {\n    imgSet('https://yphoto.eryufm.cn/upload/assets/jump.gif')\n    _img.src = src\n  }\n})()\n// call\nproxyImg(`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1551174639&di=90b4757f68c9480f78c132c930c1df10&src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`)\n```\n\n#### 保护代理\n对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发\n```js\n// filter some no use or unneed requestions or data\n// A  ---> B(proxy) ----> C\nconst a = {\n  name: 'a',\n  send (target, info) {\n    target.receive(info)\n  }\n}\nconst c = {\n  name: 'c',\n  receive (target, info) {\n    console.log('c receive ', info, ' from ', target.name)\n  }\n}\nconst b = {\n  name: 'b',\n  receive (info) {\n    if (info) {\n      c.receive(this, info)\n    }\n  }\n}\na.send(b, 'good morning')\na.send(b, '')\na.send(b, 'send again')\n\n// output:\n// c receive good morning from b\n// c receive send again from b\n```\n上面表示一个最简单的保护代理\n\n#### 缓存代理\n顾名思义就是缓存相关的代理\n\n有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存\n```js\n// 存储所有标签\nlet tags\n\nconst sendApiGetTags = index => {\n  // ajax.get('/api', { index })\n}\nlet proxyCache = (async () => {\n  const allTagsCache = {}\n  const number = 5\n  const all = []\n  const params = {}\n\n  for (let index = 0; index < number; index++) {\n    all.push(sendApiGetTags({\n      ...params,\n      index\n    }))\n  }\n  const list = await Promise.all(all)\n\n  list.forEach((res, i) => allTagsCache[i] = res)\n\n  return allTagsCache\n})()\n\nlet setTags = async index => {\n  // 缓存中有直接拿\n  if (proxyCache[index]) {\n    tags = proxyCache[index]\n  } else {\n  // 缓存中没有则重发请求\n    tags = await sendApiGetTags(index)\n  }\n}\n```\n\n\n\n# 发布订阅模式\n\n### 定义：\n一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。\n至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法\n\n### 优点：\n订阅者可以根据自己需求当某种Action被触发时完成自己的调度\n\n### 应用场景：\nAngularJs的广播、vue的eventbus等\n\n#### 根据主体构建发布订阅的基类\n构造发布者基类\n```js\nclass Publisher {\n  constructor () {\n    // 订阅发布者的队列 存储每个订阅者\n    this.subscribers = []\n  }\n  deliver (data) {\n    // 发布消息 调用订阅者的回调 告知订阅者\n    this.subscribers.forEach(fn => fn.shot(data))\n\n    return this\n  }\n}\n```\n构造订阅者基类\n```js\nclass Observer {\n  constructor (call) {\n    // 传入订阅回调\n    this.shot = call\n  }\n  subscribe (publisher) {\n    if (!publisher.subscribers.some(v => v.shot === this.shot)) {\n      console.log('订阅该消息')\n      // 判断当前订阅者是否订阅\n      publisher.subscribers.push(this)\n    }\n    return this\n  }\n  unsubscribe (publisher) {\n    // 移除当前订阅者\n    console.log('取消订阅')\n\n    publisher.subscribers = publisher.subscribers.filter(v => v.shot !== this.shot)\n\n    return this\n  }\n}\n```\n测试：\n```js\nconst pub = new Publisher\nconst pub2 = new Publisher\nconst obs = new Observer(deliver => console.log(deliver))\n\nobs.subscribe(pub) // 订阅该消息\nobs.subscribe(pub2) // 订阅该消息\n\npub.deliver('pub deliver first message') // pub deliver first message\npub2.deliver('pub2 deliver first message') // pub2 deliver first message\n\nobs.unsubscribe(pub) // 取消订阅\npub.deliver('pub deliver second message') //\n```\n\n# 装饰者模式\n\n### 定义：\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能\n\n### 优点：\n- 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互\n- 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展\n\n### 应用场景：\n- 需要扩展一个类的功能，或给一个类添加附加职责\n- 需要动态的给一个对象添加功能，这些功能可以再动态的撤销\n- 不必改动原本的逻辑造成不可知问题\n\n#### 给所有的函数调用添加调用前和调用后的钩子\n\n普通函数：\n```js\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nfn('let go') // lets go right now\n```\n我们知道JS中所有的函数都是基于父类 `Function` 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：\n```js\n// 执行前\nFunction.prototype.before = function (call) {\n  const fn = this\n  \n  // 返回体本身也是函数所以支持继续调用钩子\n  return function () {\n    // 调用钩子，同时参数传递到钩子内\n    call.apply(this, arguments)\n    // 调用自身\n    return fn.apply(this, arguments)\n  }\n}\n// 执行后\n// 和 before 同理\nFunction.prototype.after = function (call) {\n  const fn = this\n\n  return function () {\n    const res = fn.apply(this, arguments)\n\n    call.apply(this, arguments)\n\n    // 返回自身的返回值\n    return res\n  }\n}\n```\n测试：\n```js\n// 重新包装 fn\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nconst decoratorFn = fn.before(function (msg) {\n  console.log('when we go,', msg)\n}).after(function (msg){\n  console.log('had to go', msg)\n})\n\ndecoratorFn('lets go')\n\n// out put:\n// when we go, right now\n// lets go, right now\n// had to go, right now\n```\n# 职责链（责任链）模式\n\n### 定义：\n它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求\n\n### 优点：\n职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了\n\n### 应用场景：\nJS 中的事件冒泡（事件委托）就是经典案例\n\n#### 实例分析\n\n部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购\n下面分别抽象处理者构造基类\n\n责任链调度中心：\n```js\nclass Handler {\n  constructor() {\n    this.next = null\n  }\n  setNext(_handler) {\n    this.next = _handler\n  }\n  handleRequest(money) {}\n}\n\n\n```\n\n采购部经理：\n```js\nclass CGBHandler extends Handler {\n  handleRequest(money) {\n    // 1w\n    if (money < 10000){\n      console.log('1w以内，同意')\n    } else {\n      console.log('金额太大，只能处理1w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n总经理：\n```js\nclass ZJLHandler extends Handler {\n  handleRequest(money) {\n    // 10w\n    if (money < 100000){\n      console.log('10w以内，同意')\n    } else {\n      console.log('金额太大，只能处理10w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n董事长：\n```js\nclass DSZHandler extends Handler {\n  handleRequest(money) {\n    // 100w\n    if (money >= 100000){\n      console.log('10万以上的我来处理')\n      //处理其他逻辑\n    } \n  }\n}\n```\n\n封装客户端接口：\n```js\nconst dispatch = (function client() {\n  const cgb = new CGBHandler()\n  const zjl = new ZJLHandler()\n  const dsz = new DSZHandler()\n\n  cgb.setNext(zjl)\n  zjl.setNext(dsz)\n\n  return cgb.handleRequest.bind(cgb)\n})()\n```\n测试：\n```js\n\ndispath(800000)\n// output:\n// 金额太大，只能处理1w以内的采购\n// 金额太大，只能处理10w以内的采购\n// 10万以上的我来处理\n\ndispath(7000)\n// output:\n// 1w以内，同意\n\n```\n补充：\n- 纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理\n\n- 不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理\n\n.\n.\n.\n.\n.\n.\n未完待续...👏\n","slug":"writeSomething/jsDesignPattern","published":1,"updated":"2019-03-06T12:18:12.292Z","_id":"cjtbdahhu000pzk48e4phf52v","comments":1,"layout":"post","photos":[],"link":"","content":"<p>持续更新<br>JS常用的设计模式以及应用场景<br><a id=\"more\"></a><br><em>以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝</em></p>\n<h1 id=\"何谓设计模式\"><a href=\"#何谓设计模式\" class=\"headerlink\" title=\"何谓设计模式\"></a>何谓设计模式</h1><p>没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多</p>\n<p>抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位</p>\n<p>定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案</p>\n<p>补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题</p>\n<p>软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍</p>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><p>在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：</p>\n<ul>\n<li><p>单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度</p>\n</li>\n<li><p>最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理</p>\n</li>\n<li><p>开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定</p>\n</li>\n</ul>\n<h1 id=\"从最简单的单体-单例模式开始\"><a href=\"#从最简单的单体-单例模式开始\" class=\"headerlink\" title=\"从最简单的单体/单例模式开始\"></a>从最简单的单体/单例模式开始</h1><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象</p>\n<p>单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例<br><em>在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供</em></p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例</li>\n<li>因为类控制了实例化过程，所以类可以灵活更改实例化过程</li>\n<li>单体可以控制局部变量污染</li>\n</ul>\n<h3 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存</li>\n<li>借助单例模式，可以把代码组织的更为一致</li>\n</ul>\n<h4 id=\"最基本的单体模式\"><a href=\"#最基本的单体模式\" class=\"headerlink\" title=\"最基本的单体模式\"></a>最基本的单体模式</h4><p>直接导出一个方法属性集合的对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// commonjs 导出</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  getSingleton() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"用闭包来实现单例\"><a href=\"#用闭包来实现单例\" class=\"headerlink\" title=\"用闭包来实现单例\"></a>用闭包来实现单例</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Ins1 = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> instance = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"comment\">// 利用闭包特性保证实例私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opt</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> opt) &#123;</span><br><span class=\"line\">      instance[k] = opt[k]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> i1 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i1'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> i2 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i2'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1 === i2) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1.name) <span class=\"comment\">// i2</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： <code>class T {} export default new T</code> 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化</p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><h3 id=\"定义：-1\"><a href=\"#定义：-1\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>减少<code>command c &amp; command v</code>, 提高复用性</li>\n<li>遵循开闭原则，算法独立易于切换、理解、拓展</li>\n</ul>\n<h3 id=\"应用场景：-1\"><a href=\"#应用场景：-1\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试</p>\n<h4 id=\"最简单的执行\"><a href=\"#最简单的执行\" class=\"headerlink\" title=\"最简单的执行\"></a>最简单的执行</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> strategies = &#123;</span><br><span class=\"line\">      plus10: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">10</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      plus100: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">100</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plus, base</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strategies[plus](base);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> strategy = closure()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus10'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus100'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 101</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对比分析\"><a href=\"#对比分析\" class=\"headerlink\" title=\"对比分析\"></a>对比分析</h4><p>eg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额</p>\n<p>意大利逻辑:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">context</span> (<span class=\"params\">name, type, price</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vip</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Old</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Others</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setPrice (name, strategy, price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name, <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price), <span class=\"string\">'元'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Vip</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Old</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Others</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本</p>\n<p>补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义父类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(discount) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不传为原价</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = discount || <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice(price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount === <span class=\"number\">1</span></span><br><span class=\"line\">      ? price</span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以自定义更多不同级别顾客不同需求</span></span><br><span class=\"line\"><span class=\"comment\">// class Test extend Handler &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   getGifts() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     if (this.discount &lt; 1) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       // 赠送赠品</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// const master = new Test(0.1)</span></span><br><span class=\"line\"><span class=\"comment\">// master.getGifts()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Context类同上方便统一接口输出</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.5</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.8</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Sub</span><br><span class=\"line\"></span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>测试结果一致</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"定义：-2\"><a href=\"#定义：-2\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用<br>著名的代理模式例子为引用计数（reference counting）指针对象<br>另外代理模式还可分为：</p>\n<ul>\n<li>虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象</li>\n<li>保护代理：用于控制不同权限的对象对目标对象的访问</li>\n<li>缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</li>\n</ul>\n<h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>独立职责归属，便于维护测试</p>\n<h3 id=\"应用场景：-2\"><a href=\"#应用场景：-2\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>比如图片的懒加载，数据缓存等</p>\n<h4 id=\"虚拟代理实现图片懒加载\"><a href=\"#虚拟代理实现图片懒加载\" class=\"headerlink\" title=\"虚拟代理实现图片懒加载\"></a>虚拟代理实现图片懒加载</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> imgSet = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.append(node)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    node.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxyImg = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _img = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\"></span><br><span class=\"line\">  _img.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(imgSet, <span class=\"number\">2000</span>, <span class=\"keyword\">this</span>.src)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    imgSet(<span class=\"string\">'https://yphoto.eryufm.cn/upload/assets/jump.gif'</span>)</span><br><span class=\"line\">    _img.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">// call</span></span><br><span class=\"line\">proxyImg(<span class=\"string\">`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1551174639&amp;di=90b4757f68c9480f78c132c930c1df10&amp;src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h4><p>对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filter some no use or unneed requestions or data</span></span><br><span class=\"line\"><span class=\"comment\">// A  ---&gt; B(proxy) ----&gt; C</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  send (target, info) &#123;</span><br><span class=\"line\">    target.receive(info)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  receive (target, info) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c receive '</span>, info, <span class=\"string\">' from '</span>, target.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  receive (info) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (info) &#123;</span><br><span class=\"line\">      c.receive(<span class=\"keyword\">this</span>, info)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.send(b, <span class=\"string\">'good morning'</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">''</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">'send again'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// c receive good morning from b</span></span><br><span class=\"line\"><span class=\"comment\">// c receive send again from b</span></span><br></pre></td></tr></table></figure></p>\n<p>上面表示一个最简单的保护代理</p>\n<h4 id=\"缓存代理\"><a href=\"#缓存代理\" class=\"headerlink\" title=\"缓存代理\"></a>缓存代理</h4><p>顾名思义就是缓存相关的代理</p>\n<p>有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储所有标签</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sendApiGetTags = <span class=\"function\"><span class=\"params\">index</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ajax.get('/api', &#123; index &#125;)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyCache = <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">async</span> (</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allTagsCache = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> number = <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> all = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index = <span class=\"number\">0</span>; index &lt; number; index++) &#123;</span><br><span class=\"line\">    all.push(sendApiGetTags(&#123;</span><br><span class=\"line\">      ...params,</span><br><span class=\"line\">      index</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> list = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(all)</span><br><span class=\"line\"></span><br><span class=\"line\">  list.forEach(<span class=\"function\">(<span class=\"params\">res, i</span>) =&gt;</span> allTagsCache[i] = res)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> allTagsCache</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> setTags = <span class=\"keyword\">async</span> index =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中有直接拿</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (proxyCache[index]) &#123;</span><br><span class=\"line\">    tags = proxyCache[index]</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中没有则重发请求</span></span><br><span class=\"line\">    tags = <span class=\"keyword\">await</span> sendApiGetTags(index)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h1><h3 id=\"定义：-3\"><a href=\"#定义：-3\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。<br>至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法</p>\n<h3 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>订阅者可以根据自己需求当某种Action被触发时完成自己的调度</p>\n<h3 id=\"应用场景：-3\"><a href=\"#应用场景：-3\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>AngularJs的广播、vue的eventbus等</p>\n<h4 id=\"根据主体构建发布订阅的基类\"><a href=\"#根据主体构建发布订阅的基类\" class=\"headerlink\" title=\"根据主体构建发布订阅的基类\"></a>根据主体构建发布订阅的基类</h4><p>构造发布者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Publisher</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 订阅发布者的队列 存储每个订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  deliver (data) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布消息 调用订阅者的回调 告知订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn.shot(data))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造订阅者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (call) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入订阅回调</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.shot = call</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  subscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!publisher.subscribers.some(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot === <span class=\"keyword\">this</span>.shot)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'订阅该消息'</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 判断当前订阅者是否订阅</span></span><br><span class=\"line\">      publisher.subscribers.push(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  unsubscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 移除当前订阅者</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'取消订阅'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    publisher.subscribers = publisher.subscribers.filter(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot !== <span class=\"keyword\">this</span>.shot)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pub = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> pub2 = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> obs = <span class=\"keyword\">new</span> Observer(<span class=\"function\"><span class=\"params\">deliver</span> =&gt;</span> <span class=\"built_in\">console</span>.log(deliver))</span><br><span class=\"line\"></span><br><span class=\"line\">obs.subscribe(pub) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\">obs.subscribe(pub2) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\"></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver first message'</span>) <span class=\"comment\">// pub deliver first message</span></span><br><span class=\"line\">pub2.deliver(<span class=\"string\">'pub2 deliver first message'</span>) <span class=\"comment\">// pub2 deliver first message</span></span><br><span class=\"line\"></span><br><span class=\"line\">obs.unsubscribe(pub) <span class=\"comment\">// 取消订阅</span></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver second message'</span>) <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><h3 id=\"定义：-4\"><a href=\"#定义：-4\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能</p>\n<h3 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展</li>\n</ul>\n<h3 id=\"应用场景：-4\"><a href=\"#应用场景：-4\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>需要扩展一个类的功能，或给一个类添加附加职责</li>\n<li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销</li>\n<li>不必改动原本的逻辑造成不可知问题</li>\n</ul>\n<h4 id=\"给所有的函数调用添加调用前和调用后的钩子\"><a href=\"#给所有的函数调用添加调用前和调用后的钩子\" class=\"headerlink\" title=\"给所有的函数调用添加调用前和调用后的钩子\"></a>给所有的函数调用添加调用前和调用后的钩子</h4><p>普通函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"string\">'let go'</span>) <span class=\"comment\">// lets go right now</span></span><br></pre></td></tr></table></figure></p>\n<p>我们知道JS中所有的函数都是基于父类 <code>Function</code> 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行前</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.before = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 返回体本身也是函数所以支持继续调用钩子</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用钩子，同时参数传递到钩子内</span></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 调用自身</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 执行后</span></span><br><span class=\"line\"><span class=\"comment\">// 和 before 同理</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.after = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回自身的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重新包装 fn</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decoratorFn = fn.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'when we go,'</span>, msg)</span><br><span class=\"line\">&#125;).after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'had to go'</span>, msg)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">decoratorFn(<span class=\"string\">'lets go'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// out put:</span></span><br><span class=\"line\"><span class=\"comment\">// when we go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// lets go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// had to go, right now</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"职责链（责任链）模式\"><a href=\"#职责链（责任链）模式\" class=\"headerlink\" title=\"职责链（责任链）模式\"></a>职责链（责任链）模式</h1><h3 id=\"定义：-5\"><a href=\"#定义：-5\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求</p>\n<h3 id=\"优点：-4\"><a href=\"#优点：-4\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了</p>\n<h3 id=\"应用场景：-5\"><a href=\"#应用场景：-5\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>JS 中的事件冒泡（事件委托）就是经典案例</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购<br>下面分别抽象处理者构造基类</p>\n<p>责任链调度中心：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setNext(_handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = _handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleRequest(money) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采购部经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CGBHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'1w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理1w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZJLHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 10w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理10w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>董事长：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DSZHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 100w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &gt;= <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10万以上的我来处理'</span>)</span><br><span class=\"line\">      <span class=\"comment\">//处理其他逻辑</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>封装客户端接口：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dispatch = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">client</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cgb = <span class=\"keyword\">new</span> CGBHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> zjl = <span class=\"keyword\">new</span> ZJLHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dsz = <span class=\"keyword\">new</span> DSZHandler()</span><br><span class=\"line\"></span><br><span class=\"line\">  cgb.setNext(zjl)</span><br><span class=\"line\">  zjl.setNext(dsz)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cgb.handleRequest.bind(cgb)</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">800000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理1w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理10w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 10万以上的我来处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">7000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 1w以内，同意</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：</p>\n<ul>\n<li><p>纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理</p>\n</li>\n<li><p>不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理</p>\n</li>\n</ul>\n<p>.<br>.<br>.<br>.<br>.<br>.<br>未完待续…👏</p>\n","site":{"data":{}},"excerpt":"<p>持续更新<br>JS常用的设计模式以及应用场景<br></p>","more":"<br><em>以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝</em><p></p>\n<h1 id=\"何谓设计模式\"><a href=\"#何谓设计模式\" class=\"headerlink\" title=\"何谓设计模式\"></a>何谓设计模式</h1><p>没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多</p>\n<p>抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位</p>\n<p>定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案</p>\n<p>补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题</p>\n<p>软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍</p>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><p>在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：</p>\n<ul>\n<li><p>单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度</p>\n</li>\n<li><p>最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理</p>\n</li>\n<li><p>开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定</p>\n</li>\n</ul>\n<h1 id=\"从最简单的单体-单例模式开始\"><a href=\"#从最简单的单体-单例模式开始\" class=\"headerlink\" title=\"从最简单的单体/单例模式开始\"></a>从最简单的单体/单例模式开始</h1><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象</p>\n<p>单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例<br><em>在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供</em></p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例</li>\n<li>因为类控制了实例化过程，所以类可以灵活更改实例化过程</li>\n<li>单体可以控制局部变量污染</li>\n</ul>\n<h3 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存</li>\n<li>借助单例模式，可以把代码组织的更为一致</li>\n</ul>\n<h4 id=\"最基本的单体模式\"><a href=\"#最基本的单体模式\" class=\"headerlink\" title=\"最基本的单体模式\"></a>最基本的单体模式</h4><p>直接导出一个方法属性集合的对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// commonjs 导出</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  getSingleton() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"用闭包来实现单例\"><a href=\"#用闭包来实现单例\" class=\"headerlink\" title=\"用闭包来实现单例\"></a>用闭包来实现单例</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Ins1 = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> instance = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"comment\">// 利用闭包特性保证实例私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opt</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> opt) &#123;</span><br><span class=\"line\">      instance[k] = opt[k]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> i1 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i1'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> i2 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i2'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1 === i2) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1.name) <span class=\"comment\">// i2</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： <code>class T {} export default new T</code> 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化</p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><h3 id=\"定义：-1\"><a href=\"#定义：-1\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>减少<code>command c &amp; command v</code>, 提高复用性</li>\n<li>遵循开闭原则，算法独立易于切换、理解、拓展</li>\n</ul>\n<h3 id=\"应用场景：-1\"><a href=\"#应用场景：-1\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试</p>\n<h4 id=\"最简单的执行\"><a href=\"#最简单的执行\" class=\"headerlink\" title=\"最简单的执行\"></a>最简单的执行</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> strategies = &#123;</span><br><span class=\"line\">      plus10: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">10</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      plus100: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">100</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plus, base</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strategies[plus](base);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> strategy = closure()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus10'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus100'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 101</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对比分析\"><a href=\"#对比分析\" class=\"headerlink\" title=\"对比分析\"></a>对比分析</h4><p>eg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额</p>\n<p>意大利逻辑:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">context</span> (<span class=\"params\">name, type, price</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vip</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Old</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Others</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setPrice (name, strategy, price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name, <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price), <span class=\"string\">'元'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Vip</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Old</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Others</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本</p>\n<p>补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义父类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(discount) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不传为原价</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = discount || <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice(price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount === <span class=\"number\">1</span></span><br><span class=\"line\">      ? price</span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以自定义更多不同级别顾客不同需求</span></span><br><span class=\"line\"><span class=\"comment\">// class Test extend Handler &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   getGifts() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     if (this.discount &lt; 1) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       // 赠送赠品</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// const master = new Test(0.1)</span></span><br><span class=\"line\"><span class=\"comment\">// master.getGifts()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Context类同上方便统一接口输出</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.5</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.8</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Sub</span><br><span class=\"line\"></span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>测试结果一致</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"定义：-2\"><a href=\"#定义：-2\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用<br>著名的代理模式例子为引用计数（reference counting）指针对象<br>另外代理模式还可分为：</p>\n<ul>\n<li>虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象</li>\n<li>保护代理：用于控制不同权限的对象对目标对象的访问</li>\n<li>缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</li>\n</ul>\n<h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>独立职责归属，便于维护测试</p>\n<h3 id=\"应用场景：-2\"><a href=\"#应用场景：-2\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>比如图片的懒加载，数据缓存等</p>\n<h4 id=\"虚拟代理实现图片懒加载\"><a href=\"#虚拟代理实现图片懒加载\" class=\"headerlink\" title=\"虚拟代理实现图片懒加载\"></a>虚拟代理实现图片懒加载</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> imgSet = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.append(node)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    node.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxyImg = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _img = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\"></span><br><span class=\"line\">  _img.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(imgSet, <span class=\"number\">2000</span>, <span class=\"keyword\">this</span>.src)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    imgSet(<span class=\"string\">'https://yphoto.eryufm.cn/upload/assets/jump.gif'</span>)</span><br><span class=\"line\">    _img.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">// call</span></span><br><span class=\"line\">proxyImg(<span class=\"string\">`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1551174639&amp;di=90b4757f68c9480f78c132c930c1df10&amp;src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h4><p>对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filter some no use or unneed requestions or data</span></span><br><span class=\"line\"><span class=\"comment\">// A  ---&gt; B(proxy) ----&gt; C</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  send (target, info) &#123;</span><br><span class=\"line\">    target.receive(info)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  receive (target, info) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c receive '</span>, info, <span class=\"string\">' from '</span>, target.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  receive (info) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (info) &#123;</span><br><span class=\"line\">      c.receive(<span class=\"keyword\">this</span>, info)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.send(b, <span class=\"string\">'good morning'</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">''</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">'send again'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// c receive good morning from b</span></span><br><span class=\"line\"><span class=\"comment\">// c receive send again from b</span></span><br></pre></td></tr></table></figure></p>\n<p>上面表示一个最简单的保护代理</p>\n<h4 id=\"缓存代理\"><a href=\"#缓存代理\" class=\"headerlink\" title=\"缓存代理\"></a>缓存代理</h4><p>顾名思义就是缓存相关的代理</p>\n<p>有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储所有标签</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sendApiGetTags = <span class=\"function\"><span class=\"params\">index</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ajax.get('/api', &#123; index &#125;)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyCache = <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">async</span> (</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allTagsCache = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> number = <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> all = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index = <span class=\"number\">0</span>; index &lt; number; index++) &#123;</span><br><span class=\"line\">    all.push(sendApiGetTags(&#123;</span><br><span class=\"line\">      ...params,</span><br><span class=\"line\">      index</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> list = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(all)</span><br><span class=\"line\"></span><br><span class=\"line\">  list.forEach(<span class=\"function\">(<span class=\"params\">res, i</span>) =&gt;</span> allTagsCache[i] = res)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> allTagsCache</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> setTags = <span class=\"keyword\">async</span> index =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中有直接拿</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (proxyCache[index]) &#123;</span><br><span class=\"line\">    tags = proxyCache[index]</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中没有则重发请求</span></span><br><span class=\"line\">    tags = <span class=\"keyword\">await</span> sendApiGetTags(index)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h1><h3 id=\"定义：-3\"><a href=\"#定义：-3\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。<br>至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法</p>\n<h3 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>订阅者可以根据自己需求当某种Action被触发时完成自己的调度</p>\n<h3 id=\"应用场景：-3\"><a href=\"#应用场景：-3\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>AngularJs的广播、vue的eventbus等</p>\n<h4 id=\"根据主体构建发布订阅的基类\"><a href=\"#根据主体构建发布订阅的基类\" class=\"headerlink\" title=\"根据主体构建发布订阅的基类\"></a>根据主体构建发布订阅的基类</h4><p>构造发布者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Publisher</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 订阅发布者的队列 存储每个订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  deliver (data) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布消息 调用订阅者的回调 告知订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn.shot(data))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造订阅者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (call) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入订阅回调</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.shot = call</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  subscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!publisher.subscribers.some(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot === <span class=\"keyword\">this</span>.shot)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'订阅该消息'</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 判断当前订阅者是否订阅</span></span><br><span class=\"line\">      publisher.subscribers.push(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  unsubscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 移除当前订阅者</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'取消订阅'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    publisher.subscribers = publisher.subscribers.filter(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot !== <span class=\"keyword\">this</span>.shot)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pub = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> pub2 = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> obs = <span class=\"keyword\">new</span> Observer(<span class=\"function\"><span class=\"params\">deliver</span> =&gt;</span> <span class=\"built_in\">console</span>.log(deliver))</span><br><span class=\"line\"></span><br><span class=\"line\">obs.subscribe(pub) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\">obs.subscribe(pub2) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\"></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver first message'</span>) <span class=\"comment\">// pub deliver first message</span></span><br><span class=\"line\">pub2.deliver(<span class=\"string\">'pub2 deliver first message'</span>) <span class=\"comment\">// pub2 deliver first message</span></span><br><span class=\"line\"></span><br><span class=\"line\">obs.unsubscribe(pub) <span class=\"comment\">// 取消订阅</span></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver second message'</span>) <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><h3 id=\"定义：-4\"><a href=\"#定义：-4\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能</p>\n<h3 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展</li>\n</ul>\n<h3 id=\"应用场景：-4\"><a href=\"#应用场景：-4\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>需要扩展一个类的功能，或给一个类添加附加职责</li>\n<li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销</li>\n<li>不必改动原本的逻辑造成不可知问题</li>\n</ul>\n<h4 id=\"给所有的函数调用添加调用前和调用后的钩子\"><a href=\"#给所有的函数调用添加调用前和调用后的钩子\" class=\"headerlink\" title=\"给所有的函数调用添加调用前和调用后的钩子\"></a>给所有的函数调用添加调用前和调用后的钩子</h4><p>普通函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"string\">'let go'</span>) <span class=\"comment\">// lets go right now</span></span><br></pre></td></tr></table></figure></p>\n<p>我们知道JS中所有的函数都是基于父类 <code>Function</code> 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行前</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.before = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 返回体本身也是函数所以支持继续调用钩子</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用钩子，同时参数传递到钩子内</span></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 调用自身</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 执行后</span></span><br><span class=\"line\"><span class=\"comment\">// 和 before 同理</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.after = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回自身的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重新包装 fn</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decoratorFn = fn.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'when we go,'</span>, msg)</span><br><span class=\"line\">&#125;).after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'had to go'</span>, msg)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">decoratorFn(<span class=\"string\">'lets go'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// out put:</span></span><br><span class=\"line\"><span class=\"comment\">// when we go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// lets go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// had to go, right now</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"职责链（责任链）模式\"><a href=\"#职责链（责任链）模式\" class=\"headerlink\" title=\"职责链（责任链）模式\"></a>职责链（责任链）模式</h1><h3 id=\"定义：-5\"><a href=\"#定义：-5\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求</p>\n<h3 id=\"优点：-4\"><a href=\"#优点：-4\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了</p>\n<h3 id=\"应用场景：-5\"><a href=\"#应用场景：-5\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>JS 中的事件冒泡（事件委托）就是经典案例</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购<br>下面分别抽象处理者构造基类</p>\n<p>责任链调度中心：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setNext(_handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = _handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleRequest(money) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采购部经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CGBHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'1w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理1w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZJLHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 10w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理10w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>董事长：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DSZHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 100w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &gt;= <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10万以上的我来处理'</span>)</span><br><span class=\"line\">      <span class=\"comment\">//处理其他逻辑</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>封装客户端接口：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dispatch = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">client</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cgb = <span class=\"keyword\">new</span> CGBHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> zjl = <span class=\"keyword\">new</span> ZJLHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dsz = <span class=\"keyword\">new</span> DSZHandler()</span><br><span class=\"line\"></span><br><span class=\"line\">  cgb.setNext(zjl)</span><br><span class=\"line\">  zjl.setNext(dsz)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cgb.handleRequest.bind(cgb)</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">800000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理1w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理10w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 10万以上的我来处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">7000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 1w以内，同意</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：</p>\n<ul>\n<li><p>纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理</p>\n</li>\n<li><p>不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理</p>\n</li>\n</ul>\n<p>.<br>.<br>.<br>.<br>.<br>.<br>未完待续…👏</p>"},{"title":"十行代码实现Koa2洋葱模型","date":"2019-02-22T11:00:00.000Z","_content":"\n十行代码实现 `koa2` 洋葱模型\n\n<!--more-->\n\n#### 洋葱图模型\n![avatar](/onion.png)\n\nkoa2上独特的中间件流程控制，是一个典型的洋葱模型\n\n# 运行 koa2 demo\n```js\nconst Koa = require('koa2')\n\nconst app = new Koa()\n\napp.use(async (ctx, next)=>{\n    console.log(1, ' start')\n    await next()\n    console.log(1, ' end')\n})\n\napp.use(async (ctx, next) => {\n    console.log(2, ' start')\n    await next()\n    console.log(2, ' end')\n})\napp.use(async (ctx, next) => {\n    console.log(3, ' start')\n    await next()\n    console.log(3, ' end')\n})\n\napp.listen(3000)\n```\n输出结果：\n```bash\n1 start\n2 start\n3 start\n3 end\n2 end\n1 end\n```\n\n展现如上图洋葱式的输出结果\n\n# 归纳\n\n接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：\n- 首先变为最简case：只有两个中间件函数\n- 那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 `1 start -> 2 start -> 2 end -> 1 end` 的结果\n- 同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n和之前的一篇 [动态规划和递归：从虎羊草开始](https://rollawaypoint.github.io/2019/02/21/writeSomething/dynamicProgrammingAndRecursion/) 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码\n\n# 三步完成封装\n\n第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n```\n\n第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -> 2 -> 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：\n```js\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n```\n\n第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：\n```js\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n```\n\n以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试\n\n# 测试\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n\nconst app = new App\n\napp.use(async function m1(next) {\n  console.log('m1')\n  await next()\n  console.log('m1 end')\n})\n\napp.use(async function m2(next) {\n  console.log('m2')\n  await next()\n  console.log('m2 end')\n})\n\napp.use(async function m3(next) {\n  console.log('m3')\n  await next()\n  console.log('m3 end')\n})\n\n\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n\ncompose(app.middleware)()\n\n// output:\n// m1\n// m2\n// m3\n// m3 end\n// m2 end\n// m1 end\n```\n\n达到预期结果ahhhhh💐\n\n# summary\n\n当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2","source":"_posts/writeSomething/koa2OnionModel.md","raw":"---\ntitle: 十行代码实现Koa2洋葱模型\ntags:\n  - 封装\n  - koa\n  - 洋葱模型\ndate: 2019-02-22 19:00:00\ncategories: 封装\n---\n\n十行代码实现 `koa2` 洋葱模型\n\n<!--more-->\n\n#### 洋葱图模型\n![avatar](/onion.png)\n\nkoa2上独特的中间件流程控制，是一个典型的洋葱模型\n\n# 运行 koa2 demo\n```js\nconst Koa = require('koa2')\n\nconst app = new Koa()\n\napp.use(async (ctx, next)=>{\n    console.log(1, ' start')\n    await next()\n    console.log(1, ' end')\n})\n\napp.use(async (ctx, next) => {\n    console.log(2, ' start')\n    await next()\n    console.log(2, ' end')\n})\napp.use(async (ctx, next) => {\n    console.log(3, ' start')\n    await next()\n    console.log(3, ' end')\n})\n\napp.listen(3000)\n```\n输出结果：\n```bash\n1 start\n2 start\n3 start\n3 end\n2 end\n1 end\n```\n\n展现如上图洋葱式的输出结果\n\n# 归纳\n\n接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：\n- 首先变为最简case：只有两个中间件函数\n- 那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 `1 start -> 2 start -> 2 end -> 1 end` 的结果\n- 同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n和之前的一篇 [动态规划和递归：从虎羊草开始](https://rollawaypoint.github.io/2019/02/21/writeSomething/dynamicProgrammingAndRecursion/) 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码\n\n# 三步完成封装\n\n第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n```\n\n第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -> 2 -> 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：\n```js\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n```\n\n第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：\n```js\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n```\n\n以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试\n\n# 测试\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n\nconst app = new App\n\napp.use(async function m1(next) {\n  console.log('m1')\n  await next()\n  console.log('m1 end')\n})\n\napp.use(async function m2(next) {\n  console.log('m2')\n  await next()\n  console.log('m2 end')\n})\n\napp.use(async function m3(next) {\n  console.log('m3')\n  await next()\n  console.log('m3 end')\n})\n\n\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n\ncompose(app.middleware)()\n\n// output:\n// m1\n// m2\n// m3\n// m3 end\n// m2 end\n// m1 end\n```\n\n达到预期结果ahhhhh💐\n\n# summary\n\n当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2","slug":"writeSomething/koa2OnionModel","published":1,"updated":"2019-03-14T06:26:08.022Z","_id":"cjtbdahhv000qzk484wd8kra9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>十行代码实现 <code>koa2</code> 洋葱模型</p>\n<a id=\"more\"></a>\n<h4 id=\"洋葱图模型\"><a href=\"#洋葱图模型\" class=\"headerlink\" title=\"洋葱图模型\"></a>洋葱图模型</h4><p><img src=\"/2019/02/22/writeSomething/koa2OnionModel/onion.png\" alt=\"avatar\"></p>\n<p>koa2上独特的中间件流程控制，是一个典型的洋葱模型</p>\n<h1 id=\"运行-koa2-demo\"><a href=\"#运行-koa2-demo\" class=\"headerlink\" title=\"运行 koa2 demo\"></a>运行 koa2 demo</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 start</span><br><span class=\"line\">2 start</span><br><span class=\"line\">3 start</span><br><span class=\"line\">3 end</span><br><span class=\"line\">2 end</span><br><span class=\"line\">1 end</span><br></pre></td></tr></table></figure></p>\n<p>展现如上图洋葱式的输出结果</p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><p>接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：</p>\n<ul>\n<li>首先变为最简case：只有两个中间件函数</li>\n<li>那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 <code>1 start -&gt; 2 start -&gt; 2 end -&gt; 1 end</code> 的结果</li>\n<li>同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调</li>\n</ul>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.<br>和之前的一篇 <a href=\"https://rollawaypoint.github.io/2019/02/21/writeSomething/dynamicProgrammingAndRecursion/\">动态规划和递归：从虎羊草开始</a> 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码</p>\n<h1 id=\"三步完成封装\"><a href=\"#三步完成封装\" class=\"headerlink\" title=\"三步完成封装\"></a>三步完成封装</h1><p>第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -&gt; 2 -&gt; 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></p>\n<p>第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> App</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m3</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br><span class=\"line\"></span><br><span class=\"line\">compose(app.middleware)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// m1</span></span><br><span class=\"line\"><span class=\"comment\">// m2</span></span><br><span class=\"line\"><span class=\"comment\">// m3</span></span><br><span class=\"line\"><span class=\"comment\">// m3 end</span></span><br><span class=\"line\"><span class=\"comment\">// m2 end</span></span><br><span class=\"line\"><span class=\"comment\">// m1 end</span></span><br></pre></td></tr></table></figure>\n<p>达到预期结果ahhhhh💐</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2</p>\n","site":{"data":{}},"excerpt":"<p>十行代码实现 <code>koa2</code> 洋葱模型</p>","more":"<h4 id=\"洋葱图模型\"><a href=\"#洋葱图模型\" class=\"headerlink\" title=\"洋葱图模型\"></a>洋葱图模型</h4><p><img src=\"/2019/02/22/writeSomething/koa2OnionModel/onion.png\" alt=\"avatar\"></p>\n<p>koa2上独特的中间件流程控制，是一个典型的洋葱模型</p>\n<h1 id=\"运行-koa2-demo\"><a href=\"#运行-koa2-demo\" class=\"headerlink\" title=\"运行 koa2 demo\"></a>运行 koa2 demo</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 start</span><br><span class=\"line\">2 start</span><br><span class=\"line\">3 start</span><br><span class=\"line\">3 end</span><br><span class=\"line\">2 end</span><br><span class=\"line\">1 end</span><br></pre></td></tr></table></figure></p>\n<p>展现如上图洋葱式的输出结果</p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><p>接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：</p>\n<ul>\n<li>首先变为最简case：只有两个中间件函数</li>\n<li>那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 <code>1 start -&gt; 2 start -&gt; 2 end -&gt; 1 end</code> 的结果</li>\n<li>同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调</li>\n</ul>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.<br>和之前的一篇 <a href=\"https://rollawaypoint.github.io/2019/02/21/writeSomething/dynamicProgrammingAndRecursion/\">动态规划和递归：从虎羊草开始</a> 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码</p>\n<h1 id=\"三步完成封装\"><a href=\"#三步完成封装\" class=\"headerlink\" title=\"三步完成封装\"></a>三步完成封装</h1><p>第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -&gt; 2 -&gt; 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></p>\n<p>第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> App</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m3</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br><span class=\"line\"></span><br><span class=\"line\">compose(app.middleware)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// m1</span></span><br><span class=\"line\"><span class=\"comment\">// m2</span></span><br><span class=\"line\"><span class=\"comment\">// m3</span></span><br><span class=\"line\"><span class=\"comment\">// m3 end</span></span><br><span class=\"line\"><span class=\"comment\">// m2 end</span></span><br><span class=\"line\"><span class=\"comment\">// m1 end</span></span><br></pre></td></tr></table></figure>\n<p>达到预期结果ahhhhh💐</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2</p>"},{"title":"functional event emitter","date":"2019-03-22T08:35:00.000Z","_content":"\n用函数式编程简单封装一个 `event emitter`\n<!--more-->\n\n函数式编程：函数式编程（英语：functional programming），又称泛函编程，是一种编程范式，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象\n*起源于范畴论*\n\n# 从函数柯里化说起\n*从低阶函数变为高阶函数的过程*\n从调用上来看，就是将 `f(a, b, c)` 变为支持 `f(a)(b)(c)`、`f(a, b)(c)`、`f(a)(b, c)`的形式\n如最基本的 `(a, b) => a + b` 可以柯里化为：\n```js\nconst f = a => b => a + b\n\n// output:\nf(4)(6) // 10\n```\n\n这表明函数柯里化是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。从某种意义上来讲，这是一种对参数的缓存，是一种非常高效的编写函数的方法\n\n具体的细节不赘述主要内容是封装这个event emitter，*很多时候js相关的类函数式操作（reduce、compose）被当做了函数式编程*, 有机会单独深入了解函数式编程Functor、Monad、Applicative后来仔细说说\n\n# 传统封装event emitter\n首先定义一个拥有着基本的订阅和发布的event类\n```js\nclass Event {\n  addEventListener () {\n    // to do\n  }\n  dispatch () {\n    // to do\n  }\n}\n```\n\n这个类要有一个存储订阅者的地方，同时发布的时候要将消息推送给所有订阅该消息的订阅者\n```js\nclass Event {\n  constructor (eventMap = new Map()) {\n    // 使用map存储订阅者\n    this.eventMap = eventMap\n  }\n  addEventListener (event, handler) {\n    // to do\n  }\n  dispatch (event) {\n    // 发布\n    // 该消息的订阅队列不存在\n    if (!this.eventMap.has(event)) return\n\n    // 推送消息\n    this.eventMap.get(event).forEach(fn => fn())\n  }\n}\n```\n\n下面添加event的订阅方法，支持传入订阅消息名和对应的回调\n```js\nclass Event {\n  constructor (eventMap = new Map()) {\n    // 使用map存储订阅者\n    this.eventMap = eventMap\n  }\n  addEventListener (event, handler) {\n    this.eventMap.has(event)\n      // 判断当前订阅的消息队列中是否已经存在\n      ? this.eventMap.set(event, this.eventMap.get(event).concat([ handler ]))\n      : this.eventMap.set(event, [ handler ])\n  }\n  dispatch (event) {\n    // 发布\n    // 该消息的订阅队列不存在\n    if (!this.eventMap.has(event)) return\n\n    // 推送消息\n    this.eventMap.get(event).forEach(fn => fn())\n  }\n}\n```\n以上基本的event emitter调度中心已经封装完成了正常使用应该是没有问题的\n测试：\n```js\nconst e = new Event()\n\ne.addEventListener('e1', (e) => {\n  console.log('handle e1 first')\n})\n\ne.addEventListener('e1', (e) => {\n  console.log('handle e1 second', e)\n})\n\ne.dispatch('e1')\n\n// output: \n// handle e1 first\n// handle e1 second\n```\n那么如何使用函数式编程的思想将上面的event emitter封装起来呢？\n\n# functional event emitter\n#### functional addEventListener\n如传统封装方法的一致，addEventListener内部需要分别使用消息类型event，消息回调handler以及存储中心eventMap，用柯里化的思想分别将这三个传入新封装的函数，新函数即为：\n```js\nconst addEventListener = event\n  => handler\n    => eventMap\n      => eventMap.has(event)\n        // 判断逻辑不变\n        ? new Map(eventMap).set(event, eventMap.get(event).concat([handler]))\n        : new Map(eventMap).set(event, [handler])\n```\n\n#### functional dispatch\n同样，观察上面封装的dispatch方法，我们需要消息类型event和存储中心eventMap两个数据，下面也分为两个参数分别传入，改写的dispatch方法如下：\n```js\nconst dispatch = event\n  => eventMap\n    => eventMap.has(event) && eventMap.get(event).forEach(fn => fn())\n```\nevent emitter类两个核心的函数已经改写完毕了，可是我们观察上面的addEventListener方法，可以看到上面的封装分三步将所需要的参数分别传入，调用即为：`addEventListener('e2')(() => log('hey'))`, 此时的返回值是一个需要接受存储中心 `eventMap` 为参数的一个新函数，这里需要注意\n我们要对所有的addEventListener进行整合最终传入同一个map对象作为唯一存储对象，下面我们要写一个compose函数\n\n#### functional compose\n这个compose需要接受函数的集合（函数即为`addEventListener('e2')(() => log('hey'))`的返回值的函数）作为参数，使用数组最强大的reduce方法对传入的函数进行批处理调用即可，如果大家熟悉redux里面的compose函数，其实都是一样的，都是处理一组函数集合的集中调用（类似的还有之前的一篇博客 [十行代码实现Koa2洋葱模型](https://rollawaypoint.github.io/2019/02/22/writeSomething/koa2OnionModel/#%E4%B8%89%E6%AD%A5%E5%AE%8C%E6%88%90%E5%B0%81%E8%A3%85) 中的compose函数）， 代码如下：\n```js\nconst compose = (...fns)\n  => fns.reduceRight((f, g)\n    => (...args)\n      => f(g(...args)))\n```\n至此，所有的封装基本已经完成了，使用函数式的封装，保护函数状态的单一性，下面进行测试：\n\n\n```js\nconst addEventListeners = compose(\n  addEventListener('e2')(() => log('hey')),\n  addEventListener('e2')(() => log('hi'))\n)\n\nconst m = addEventListeners(new Map())\ndispatch('e2')(m)\n\n// output:\n// hey\n// hi\n\n```\n\n**end**\n","source":"_posts/writeSomething/FunctionalEventEmitter.md","raw":"---\ntitle: functional event emitter\ntags:\n  - 函数式编程\n  - event emitter\ndate: 2019-03-22 16:35:00\ncategories: 算法\n---\n\n用函数式编程简单封装一个 `event emitter`\n<!--more-->\n\n函数式编程：函数式编程（英语：functional programming），又称泛函编程，是一种编程范式，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象\n*起源于范畴论*\n\n# 从函数柯里化说起\n*从低阶函数变为高阶函数的过程*\n从调用上来看，就是将 `f(a, b, c)` 变为支持 `f(a)(b)(c)`、`f(a, b)(c)`、`f(a)(b, c)`的形式\n如最基本的 `(a, b) => a + b` 可以柯里化为：\n```js\nconst f = a => b => a + b\n\n// output:\nf(4)(6) // 10\n```\n\n这表明函数柯里化是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。从某种意义上来讲，这是一种对参数的缓存，是一种非常高效的编写函数的方法\n\n具体的细节不赘述主要内容是封装这个event emitter，*很多时候js相关的类函数式操作（reduce、compose）被当做了函数式编程*, 有机会单独深入了解函数式编程Functor、Monad、Applicative后来仔细说说\n\n# 传统封装event emitter\n首先定义一个拥有着基本的订阅和发布的event类\n```js\nclass Event {\n  addEventListener () {\n    // to do\n  }\n  dispatch () {\n    // to do\n  }\n}\n```\n\n这个类要有一个存储订阅者的地方，同时发布的时候要将消息推送给所有订阅该消息的订阅者\n```js\nclass Event {\n  constructor (eventMap = new Map()) {\n    // 使用map存储订阅者\n    this.eventMap = eventMap\n  }\n  addEventListener (event, handler) {\n    // to do\n  }\n  dispatch (event) {\n    // 发布\n    // 该消息的订阅队列不存在\n    if (!this.eventMap.has(event)) return\n\n    // 推送消息\n    this.eventMap.get(event).forEach(fn => fn())\n  }\n}\n```\n\n下面添加event的订阅方法，支持传入订阅消息名和对应的回调\n```js\nclass Event {\n  constructor (eventMap = new Map()) {\n    // 使用map存储订阅者\n    this.eventMap = eventMap\n  }\n  addEventListener (event, handler) {\n    this.eventMap.has(event)\n      // 判断当前订阅的消息队列中是否已经存在\n      ? this.eventMap.set(event, this.eventMap.get(event).concat([ handler ]))\n      : this.eventMap.set(event, [ handler ])\n  }\n  dispatch (event) {\n    // 发布\n    // 该消息的订阅队列不存在\n    if (!this.eventMap.has(event)) return\n\n    // 推送消息\n    this.eventMap.get(event).forEach(fn => fn())\n  }\n}\n```\n以上基本的event emitter调度中心已经封装完成了正常使用应该是没有问题的\n测试：\n```js\nconst e = new Event()\n\ne.addEventListener('e1', (e) => {\n  console.log('handle e1 first')\n})\n\ne.addEventListener('e1', (e) => {\n  console.log('handle e1 second', e)\n})\n\ne.dispatch('e1')\n\n// output: \n// handle e1 first\n// handle e1 second\n```\n那么如何使用函数式编程的思想将上面的event emitter封装起来呢？\n\n# functional event emitter\n#### functional addEventListener\n如传统封装方法的一致，addEventListener内部需要分别使用消息类型event，消息回调handler以及存储中心eventMap，用柯里化的思想分别将这三个传入新封装的函数，新函数即为：\n```js\nconst addEventListener = event\n  => handler\n    => eventMap\n      => eventMap.has(event)\n        // 判断逻辑不变\n        ? new Map(eventMap).set(event, eventMap.get(event).concat([handler]))\n        : new Map(eventMap).set(event, [handler])\n```\n\n#### functional dispatch\n同样，观察上面封装的dispatch方法，我们需要消息类型event和存储中心eventMap两个数据，下面也分为两个参数分别传入，改写的dispatch方法如下：\n```js\nconst dispatch = event\n  => eventMap\n    => eventMap.has(event) && eventMap.get(event).forEach(fn => fn())\n```\nevent emitter类两个核心的函数已经改写完毕了，可是我们观察上面的addEventListener方法，可以看到上面的封装分三步将所需要的参数分别传入，调用即为：`addEventListener('e2')(() => log('hey'))`, 此时的返回值是一个需要接受存储中心 `eventMap` 为参数的一个新函数，这里需要注意\n我们要对所有的addEventListener进行整合最终传入同一个map对象作为唯一存储对象，下面我们要写一个compose函数\n\n#### functional compose\n这个compose需要接受函数的集合（函数即为`addEventListener('e2')(() => log('hey'))`的返回值的函数）作为参数，使用数组最强大的reduce方法对传入的函数进行批处理调用即可，如果大家熟悉redux里面的compose函数，其实都是一样的，都是处理一组函数集合的集中调用（类似的还有之前的一篇博客 [十行代码实现Koa2洋葱模型](https://rollawaypoint.github.io/2019/02/22/writeSomething/koa2OnionModel/#%E4%B8%89%E6%AD%A5%E5%AE%8C%E6%88%90%E5%B0%81%E8%A3%85) 中的compose函数）， 代码如下：\n```js\nconst compose = (...fns)\n  => fns.reduceRight((f, g)\n    => (...args)\n      => f(g(...args)))\n```\n至此，所有的封装基本已经完成了，使用函数式的封装，保护函数状态的单一性，下面进行测试：\n\n\n```js\nconst addEventListeners = compose(\n  addEventListener('e2')(() => log('hey')),\n  addEventListener('e2')(() => log('hi'))\n)\n\nconst m = addEventListeners(new Map())\ndispatch('e2')(m)\n\n// output:\n// hey\n// hi\n\n```\n\n**end**\n","slug":"writeSomething/FunctionalEventEmitter","published":1,"updated":"2019-03-25T03:23:24.585Z","_id":"cjtcsssju0000cy4801w2r2jy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>用函数式编程简单封装一个 <code>event emitter</code><br><a id=\"more\"></a></p>\n<p>函数式编程：函数式编程（英语：functional programming），又称泛函编程，是一种编程范式，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象<br><em>起源于范畴论</em></p>\n<h1 id=\"从函数柯里化说起\"><a href=\"#从函数柯里化说起\" class=\"headerlink\" title=\"从函数柯里化说起\"></a>从函数柯里化说起</h1><p><em>从低阶函数变为高阶函数的过程</em><br>从调用上来看，就是将 <code>f(a, b, c)</code> 变为支持 <code>f(a)(b)(c)</code>、<code>f(a, b)(c)</code>、<code>f(a)(b, c)</code>的形式<br>如最基本的 <code>(a, b) =&gt; a + b</code> 可以柯里化为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> b =&gt; a + b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\">f(<span class=\"number\">4</span>)(<span class=\"number\">6</span>) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure></p>\n<p>这表明函数柯里化是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。从某种意义上来讲，这是一种对参数的缓存，是一种非常高效的编写函数的方法</p>\n<p>具体的细节不赘述主要内容是封装这个event emitter，<em>很多时候js相关的类函数式操作（reduce、compose）被当做了函数式编程</em>, 有机会单独深入了解函数式编程Functor、Monad、Applicative后来仔细说说</p>\n<h1 id=\"传统封装event-emitter\"><a href=\"#传统封装event-emitter\" class=\"headerlink\" title=\"传统封装event emitter\"></a>传统封装event emitter</h1><p>首先定义一个拥有着基本的订阅和发布的event类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  addEventListener () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类要有一个存储订阅者的地方，同时发布的时候要将消息推送给所有订阅该消息的订阅者<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (eventMap = new Map()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用map存储订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap = eventMap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addEventListener (event, handler) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch (event) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布</span></span><br><span class=\"line\">    <span class=\"comment\">// 该消息的订阅队列不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.eventMap.has(event)) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 推送消息</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面添加event的订阅方法，支持传入订阅消息名和对应的回调<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (eventMap = new Map()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用map存储订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap = eventMap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addEventListener (event, handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.has(event)</span><br><span class=\"line\">      <span class=\"comment\">// 判断当前订阅的消息队列中是否已经存在</span></span><br><span class=\"line\">      ? <span class=\"keyword\">this</span>.eventMap.set(event, <span class=\"keyword\">this</span>.eventMap.get(event).concat([ handler ]))</span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.eventMap.set(event, [ handler ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch (event) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布</span></span><br><span class=\"line\">    <span class=\"comment\">// 该消息的订阅队列不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.eventMap.has(event)) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 推送消息</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的event emitter调度中心已经封装完成了正常使用应该是没有问题的<br>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> e = <span class=\"keyword\">new</span> Event()</span><br><span class=\"line\"></span><br><span class=\"line\">e.addEventListener(<span class=\"string\">'e1'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'handle e1 first'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">e.addEventListener(<span class=\"string\">'e1'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'handle e1 second'</span>, e)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">e.dispatch(<span class=\"string\">'e1'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: </span></span><br><span class=\"line\"><span class=\"comment\">// handle e1 first</span></span><br><span class=\"line\"><span class=\"comment\">// handle e1 second</span></span><br></pre></td></tr></table></figure></p>\n<p>那么如何使用函数式编程的思想将上面的event emitter封装起来呢？</p>\n<h1 id=\"functional-event-emitter\"><a href=\"#functional-event-emitter\" class=\"headerlink\" title=\"functional event emitter\"></a>functional event emitter</h1><h4 id=\"functional-addEventListener\"><a href=\"#functional-addEventListener\" class=\"headerlink\" title=\"functional addEventListener\"></a>functional addEventListener</h4><p>如传统封装方法的一致，addEventListener内部需要分别使用消息类型event，消息回调handler以及存储中心eventMap，用柯里化的思想分别将这三个传入新封装的函数，新函数即为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> addEventListener = event</span><br><span class=\"line\">  =&gt; handler</span><br><span class=\"line\">    =&gt; eventMap</span><br><span class=\"line\">      =&gt; eventMap.has(event)</span><br><span class=\"line\">        <span class=\"comment\">// 判断逻辑不变</span></span><br><span class=\"line\">        ? <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(eventMap).set(event, eventMap.get(event).concat([handler]))</span><br><span class=\"line\">        : <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(eventMap).set(event, [handler])</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"functional-dispatch\"><a href=\"#functional-dispatch\" class=\"headerlink\" title=\"functional dispatch\"></a>functional dispatch</h4><p>同样，观察上面封装的dispatch方法，我们需要消息类型event和存储中心eventMap两个数据，下面也分为两个参数分别传入，改写的dispatch方法如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dispatch = event</span><br><span class=\"line\">  =&gt; eventMap</span><br><span class=\"line\">    =&gt; eventMap.has(event) &amp;&amp; eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br></pre></td></tr></table></figure></p>\n<p>event emitter类两个核心的函数已经改写完毕了，可是我们观察上面的addEventListener方法，可以看到上面的封装分三步将所需要的参数分别传入，调用即为：<code>addEventListener(&#39;e2&#39;)(() =&gt; log(&#39;hey&#39;))</code>, 此时的返回值是一个需要接受存储中心 <code>eventMap</code> 为参数的一个新函数，这里需要注意<br>我们要对所有的addEventListener进行整合最终传入同一个map对象作为唯一存储对象，下面我们要写一个compose函数</p>\n<h4 id=\"functional-compose\"><a href=\"#functional-compose\" class=\"headerlink\" title=\"functional compose\"></a>functional compose</h4><p>这个compose需要接受函数的集合（函数即为<code>addEventListener(&#39;e2&#39;)(() =&gt; log(&#39;hey&#39;))</code>的返回值的函数）作为参数，使用数组最强大的reduce方法对传入的函数进行批处理调用即可，如果大家熟悉redux里面的compose函数，其实都是一样的，都是处理一组函数集合的集中调用（类似的还有之前的一篇博客 <a href=\"https://rollawaypoint.github.io/2019/02/22/writeSomething/koa2OnionModel/#%E4%B8%89%E6%AD%A5%E5%AE%8C%E6%88%90%E5%B0%81%E8%A3%85\">十行代码实现Koa2洋葱模型</a> 中的compose函数）， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = (...fns)</span><br><span class=\"line\">  =&gt; fns.reduceRight((f, g)</span><br><span class=\"line\">    =&gt; (...args)</span><br><span class=\"line\">      =&gt; f(g(...args)))</span><br></pre></td></tr></table></figure></p>\n<p>至此，所有的封装基本已经完成了，使用函数式的封装，保护函数状态的单一性，下面进行测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> addEventListeners = compose(</span><br><span class=\"line\">  addEventListener(<span class=\"string\">'e2'</span>)(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> log(<span class=\"string\">'hey'</span>)),</span><br><span class=\"line\">  addEventListener(<span class=\"string\">'e2'</span>)(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> log(<span class=\"string\">'hi'</span>))</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> m = addEventListeners(<span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>())</span><br><span class=\"line\">dispatch(<span class=\"string\">'e2'</span>)(m)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// hey</span></span><br><span class=\"line\"><span class=\"comment\">// hi</span></span><br></pre></td></tr></table></figure>\n<p><strong>end</strong></p>\n","site":{"data":{}},"excerpt":"<p>用函数式编程简单封装一个 <code>event emitter</code><br></p>","more":"<p></p>\n<p>函数式编程：函数式编程（英语：functional programming），又称泛函编程，是一种编程范式，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象<br><em>起源于范畴论</em></p>\n<h1 id=\"从函数柯里化说起\"><a href=\"#从函数柯里化说起\" class=\"headerlink\" title=\"从函数柯里化说起\"></a>从函数柯里化说起</h1><p><em>从低阶函数变为高阶函数的过程</em><br>从调用上来看，就是将 <code>f(a, b, c)</code> 变为支持 <code>f(a)(b)(c)</code>、<code>f(a, b)(c)</code>、<code>f(a)(b, c)</code>的形式<br>如最基本的 <code>(a, b) =&gt; a + b</code> 可以柯里化为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> b =&gt; a + b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\">f(<span class=\"number\">4</span>)(<span class=\"number\">6</span>) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure></p>\n<p>这表明函数柯里化是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。从某种意义上来讲，这是一种对参数的缓存，是一种非常高效的编写函数的方法</p>\n<p>具体的细节不赘述主要内容是封装这个event emitter，<em>很多时候js相关的类函数式操作（reduce、compose）被当做了函数式编程</em>, 有机会单独深入了解函数式编程Functor、Monad、Applicative后来仔细说说</p>\n<h1 id=\"传统封装event-emitter\"><a href=\"#传统封装event-emitter\" class=\"headerlink\" title=\"传统封装event emitter\"></a>传统封装event emitter</h1><p>首先定义一个拥有着基本的订阅和发布的event类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  addEventListener () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类要有一个存储订阅者的地方，同时发布的时候要将消息推送给所有订阅该消息的订阅者<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (eventMap = new Map()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用map存储订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap = eventMap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addEventListener (event, handler) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// to do</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch (event) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布</span></span><br><span class=\"line\">    <span class=\"comment\">// 该消息的订阅队列不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.eventMap.has(event)) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 推送消息</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面添加event的订阅方法，支持传入订阅消息名和对应的回调<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (eventMap = new Map()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用map存储订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap = eventMap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addEventListener (event, handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.has(event)</span><br><span class=\"line\">      <span class=\"comment\">// 判断当前订阅的消息队列中是否已经存在</span></span><br><span class=\"line\">      ? <span class=\"keyword\">this</span>.eventMap.set(event, <span class=\"keyword\">this</span>.eventMap.get(event).concat([ handler ]))</span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.eventMap.set(event, [ handler ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dispatch (event) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布</span></span><br><span class=\"line\">    <span class=\"comment\">// 该消息的订阅队列不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.eventMap.has(event)) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 推送消息</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的event emitter调度中心已经封装完成了正常使用应该是没有问题的<br>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> e = <span class=\"keyword\">new</span> Event()</span><br><span class=\"line\"></span><br><span class=\"line\">e.addEventListener(<span class=\"string\">'e1'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'handle e1 first'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">e.addEventListener(<span class=\"string\">'e1'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'handle e1 second'</span>, e)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">e.dispatch(<span class=\"string\">'e1'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: </span></span><br><span class=\"line\"><span class=\"comment\">// handle e1 first</span></span><br><span class=\"line\"><span class=\"comment\">// handle e1 second</span></span><br></pre></td></tr></table></figure></p>\n<p>那么如何使用函数式编程的思想将上面的event emitter封装起来呢？</p>\n<h1 id=\"functional-event-emitter\"><a href=\"#functional-event-emitter\" class=\"headerlink\" title=\"functional event emitter\"></a>functional event emitter</h1><h4 id=\"functional-addEventListener\"><a href=\"#functional-addEventListener\" class=\"headerlink\" title=\"functional addEventListener\"></a>functional addEventListener</h4><p>如传统封装方法的一致，addEventListener内部需要分别使用消息类型event，消息回调handler以及存储中心eventMap，用柯里化的思想分别将这三个传入新封装的函数，新函数即为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> addEventListener = event</span><br><span class=\"line\">  =&gt; handler</span><br><span class=\"line\">    =&gt; eventMap</span><br><span class=\"line\">      =&gt; eventMap.has(event)</span><br><span class=\"line\">        <span class=\"comment\">// 判断逻辑不变</span></span><br><span class=\"line\">        ? <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(eventMap).set(event, eventMap.get(event).concat([handler]))</span><br><span class=\"line\">        : <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(eventMap).set(event, [handler])</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"functional-dispatch\"><a href=\"#functional-dispatch\" class=\"headerlink\" title=\"functional dispatch\"></a>functional dispatch</h4><p>同样，观察上面封装的dispatch方法，我们需要消息类型event和存储中心eventMap两个数据，下面也分为两个参数分别传入，改写的dispatch方法如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dispatch = event</span><br><span class=\"line\">  =&gt; eventMap</span><br><span class=\"line\">    =&gt; eventMap.has(event) &amp;&amp; eventMap.get(event).forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn())</span><br></pre></td></tr></table></figure></p>\n<p>event emitter类两个核心的函数已经改写完毕了，可是我们观察上面的addEventListener方法，可以看到上面的封装分三步将所需要的参数分别传入，调用即为：<code>addEventListener(&#39;e2&#39;)(() =&gt; log(&#39;hey&#39;))</code>, 此时的返回值是一个需要接受存储中心 <code>eventMap</code> 为参数的一个新函数，这里需要注意<br>我们要对所有的addEventListener进行整合最终传入同一个map对象作为唯一存储对象，下面我们要写一个compose函数</p>\n<h4 id=\"functional-compose\"><a href=\"#functional-compose\" class=\"headerlink\" title=\"functional compose\"></a>functional compose</h4><p>这个compose需要接受函数的集合（函数即为<code>addEventListener(&#39;e2&#39;)(() =&gt; log(&#39;hey&#39;))</code>的返回值的函数）作为参数，使用数组最强大的reduce方法对传入的函数进行批处理调用即可，如果大家熟悉redux里面的compose函数，其实都是一样的，都是处理一组函数集合的集中调用（类似的还有之前的一篇博客 <a href=\"https://rollawaypoint.github.io/2019/02/22/writeSomething/koa2OnionModel/#%E4%B8%89%E6%AD%A5%E5%AE%8C%E6%88%90%E5%B0%81%E8%A3%85\">十行代码实现Koa2洋葱模型</a> 中的compose函数）， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = (...fns)</span><br><span class=\"line\">  =&gt; fns.reduceRight((f, g)</span><br><span class=\"line\">    =&gt; (...args)</span><br><span class=\"line\">      =&gt; f(g(...args)))</span><br></pre></td></tr></table></figure></p>\n<p>至此，所有的封装基本已经完成了，使用函数式的封装，保护函数状态的单一性，下面进行测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> addEventListeners = compose(</span><br><span class=\"line\">  addEventListener(<span class=\"string\">'e2'</span>)(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> log(<span class=\"string\">'hey'</span>)),</span><br><span class=\"line\">  addEventListener(<span class=\"string\">'e2'</span>)(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> log(<span class=\"string\">'hi'</span>))</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> m = addEventListeners(<span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>())</span><br><span class=\"line\">dispatch(<span class=\"string\">'e2'</span>)(m)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// hey</span></span><br><span class=\"line\"><span class=\"comment\">// hi</span></span><br></pre></td></tr></table></figure>\n<p><strong>end</strong></p>"},{"title":"小岛经济学","date":"2019-03-27T08:53:00.000Z","_content":"读小岛经济学，简单了解经济学概念\n<!-- more -->\n\n这本书的作者是美国经济学家彼得.D.希夫和安德鲁.J.希夫。本书的价值有人形象地用一个等式比喻为：《小岛经济学》=《经济学原理》+《经济学概论》+《国富论》。它让沉闷枯燥的经济学变得如此通俗易懂，上至90岁下至9岁都喜欢的不得了，这本书告诉我们：经济学本身并不复杂，是经济学家们的解释太复杂了。\n\n故事发生在一个小岛上，这个小岛上有三个人——艾伯、贝克和查理，这座小岛地处热带，却不是天堂。这里的人们生活艰苦，没有任何奢侈品，而且食物种类极少，他们的菜单上只有一道菜：鱼。然而由于他们的生产力的低下，没有任何工具捕鱼，靠着双手捕鱼每天只能捕捞一条鱼，正好满足自己的需求。然而他们三个人也有自己的梦想，想提自己的生活水平。某天夜里，艾伯突发奇想，他想到了做一个捕鱼器提高捕鱼效率，说干就干。第二天他没有去捕鱼，忍受着饥饿和贝克与查理的嘲笑然后织完了渔网。通过自我牺牲，他创造了资本——渔网。从此，艾伯每天可以捕两条鱼，他的生产力从而翻了一倍。而他的消费水平还是每天一条鱼，这时他的时间就非常充裕，他可以用这些时间做很多其他的事情。\n![pic](./economy_1.png)","source":"_posts/about/HowAnEconomyGrowsAndWhyItCrashes.md","raw":"---\ntitle: 小岛经济学\ntags:\n  - 经济学\ndate: 2019-03-27 16:53:00\ncategories: 经济学\n---\n读小岛经济学，简单了解经济学概念\n<!-- more -->\n\n这本书的作者是美国经济学家彼得.D.希夫和安德鲁.J.希夫。本书的价值有人形象地用一个等式比喻为：《小岛经济学》=《经济学原理》+《经济学概论》+《国富论》。它让沉闷枯燥的经济学变得如此通俗易懂，上至90岁下至9岁都喜欢的不得了，这本书告诉我们：经济学本身并不复杂，是经济学家们的解释太复杂了。\n\n故事发生在一个小岛上，这个小岛上有三个人——艾伯、贝克和查理，这座小岛地处热带，却不是天堂。这里的人们生活艰苦，没有任何奢侈品，而且食物种类极少，他们的菜单上只有一道菜：鱼。然而由于他们的生产力的低下，没有任何工具捕鱼，靠着双手捕鱼每天只能捕捞一条鱼，正好满足自己的需求。然而他们三个人也有自己的梦想，想提自己的生活水平。某天夜里，艾伯突发奇想，他想到了做一个捕鱼器提高捕鱼效率，说干就干。第二天他没有去捕鱼，忍受着饥饿和贝克与查理的嘲笑然后织完了渔网。通过自我牺牲，他创造了资本——渔网。从此，艾伯每天可以捕两条鱼，他的生产力从而翻了一倍。而他的消费水平还是每天一条鱼，这时他的时间就非常充裕，他可以用这些时间做很多其他的事情。\n![pic](./economy_1.png)","slug":"about/HowAnEconomyGrowsAndWhyItCrashes","published":1,"updated":"2019-03-27T08:59:14.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtqz9mf00000lova9ssz2ak9","content":"<p>读小岛经济学，简单了解经济学概念<br><a id=\"more\"></a></p>\n<p>这本书的作者是美国经济学家彼得.D.希夫和安德鲁.J.希夫。本书的价值有人形象地用一个等式比喻为：《小岛经济学》=《经济学原理》+《经济学概论》+《国富论》。它让沉闷枯燥的经济学变得如此通俗易懂，上至90岁下至9岁都喜欢的不得了，这本书告诉我们：经济学本身并不复杂，是经济学家们的解释太复杂了。</p>\n<p>故事发生在一个小岛上，这个小岛上有三个人——艾伯、贝克和查理，这座小岛地处热带，却不是天堂。这里的人们生活艰苦，没有任何奢侈品，而且食物种类极少，他们的菜单上只有一道菜：鱼。然而由于他们的生产力的低下，没有任何工具捕鱼，靠着双手捕鱼每天只能捕捞一条鱼，正好满足自己的需求。然而他们三个人也有自己的梦想，想提自己的生活水平。某天夜里，艾伯突发奇想，他想到了做一个捕鱼器提高捕鱼效率，说干就干。第二天他没有去捕鱼，忍受着饥饿和贝克与查理的嘲笑然后织完了渔网。通过自我牺牲，他创造了资本——渔网。从此，艾伯每天可以捕两条鱼，他的生产力从而翻了一倍。而他的消费水平还是每天一条鱼，这时他的时间就非常充裕，他可以用这些时间做很多其他的事情。<br><img src=\"/2019/03/27/about/HowAnEconomyGrowsAndWhyItCrashes/./economy_1.png\" alt=\"pic\"></p>\n","site":{"data":{}},"excerpt":"<p>读小岛经济学，简单了解经济学概念<br></p>","more":"<p></p>\n<p>这本书的作者是美国经济学家彼得.D.希夫和安德鲁.J.希夫。本书的价值有人形象地用一个等式比喻为：《小岛经济学》=《经济学原理》+《经济学概论》+《国富论》。它让沉闷枯燥的经济学变得如此通俗易懂，上至90岁下至9岁都喜欢的不得了，这本书告诉我们：经济学本身并不复杂，是经济学家们的解释太复杂了。</p>\n<p>故事发生在一个小岛上，这个小岛上有三个人——艾伯、贝克和查理，这座小岛地处热带，却不是天堂。这里的人们生活艰苦，没有任何奢侈品，而且食物种类极少，他们的菜单上只有一道菜：鱼。然而由于他们的生产力的低下，没有任何工具捕鱼，靠着双手捕鱼每天只能捕捞一条鱼，正好满足自己的需求。然而他们三个人也有自己的梦想，想提自己的生活水平。某天夜里，艾伯突发奇想，他想到了做一个捕鱼器提高捕鱼效率，说干就干。第二天他没有去捕鱼，忍受着饥饿和贝克与查理的嘲笑然后织完了渔网。通过自我牺牲，他创造了资本——渔网。从此，艾伯每天可以捕两条鱼，他的生产力从而翻了一倍。而他的消费水平还是每天一条鱼，这时他的时间就非常充裕，他可以用这些时间做很多其他的事情。<br><img src=\"/2019/03/27/about/HowAnEconomyGrowsAndWhyItCrashes/./economy_1.png\" alt=\"pic\"></p>"}],"PostAsset":[{"_id":"source/_posts/writeSomething/koa2OnionModel/onion.png","slug":"onion.png","post":"cjtbdahhv000qzk484wd8kra9","modified":0,"renderable":0},{"_id":"source/_posts/writeSomething/PayAttentionToThoseJs/virturedom.png","slug":"virturedom.png","post":"cjtbdahhn000dzk48lmh3g8dq","modified":0,"renderable":0},{"_id":"source/_posts/about/HowAnEconomyGrowsAndWhyItCrashes/economy_1.png","slug":"economy_1.png","post":"cjtqz9mf00000lova9ssz2ak9","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cjtbdahhd0003zk48n1cqrsck","category_id":"cjtbdahhh0005zk48u4099627","_id":"cjtbdahhq000gzk4866ofmncj"},{"post_id":"cjtbdahhf0004zk48v4ekxchs","category_id":"cjtbdahhh0005zk48u4099627","_id":"cjtbdahhu000mzk48o7kbm3m7"},{"post_id":"cjtbdahhj0007zk48mprsie1g","category_id":"cjtbdahhh0005zk48u4099627","_id":"cjtbdahhw000rzk48z2v5fvdd"},{"post_id":"cjtbdahhu000pzk48e4phf52v","category_id":"cjtbdahhu000lzk48toq7ffpy","_id":"cjtbdahhx000uzk48hr2moeue"},{"post_id":"cjtbdahhk0008zk4868mkq012","category_id":"cjtbdahhu000lzk48toq7ffpy","_id":"cjtbdahhx000xzk4897z0uduh"},{"post_id":"cjtbdahhk0009zk4849nguxy2","category_id":"cjtbdahhw000szk48j5wpp191","_id":"cjtbdahhy0011zk48fid1kbkk"},{"post_id":"cjtbdahhn000dzk48lmh3g8dq","category_id":"cjtbdahhw000szk48j5wpp191","_id":"cjtbdahhy0013zk48djyojhbq"},{"post_id":"cjtbdahhp000ezk48vqzgtull","category_id":"cjtbdahhx0010zk48pi6u0x35","_id":"cjtbdahhz0018zk48ljcm5jw3"},{"post_id":"cjtbdahhr000jzk484gzrh4ib","category_id":"cjtbdahhu000lzk48toq7ffpy","_id":"cjtbdahi0001dzk484xp1eprt"},{"post_id":"cjtbdahht000kzk48o7ugb0nl","category_id":"cjtbdahhw000szk48j5wpp191","_id":"cjtbdahi0001fzk484sxakd2r"},{"post_id":"cjtbdahhv000qzk484wd8kra9","category_id":"cjtbdahhx0010zk48pi6u0x35","_id":"cjtbdahi0001hzk4813g1au63"},{"post_id":"cjtcsssju0000cy4801w2r2jy","category_id":"cjtbdahhu000lzk48toq7ffpy","_id":"cjtcsssk70002cy48spp0c2yo"},{"post_id":"cjtqz9mf00000lova9ssz2ak9","category_id":"cjtqz9mf80001lovap7zd6jp5","_id":"cjtqz9mfc0004lova0vryqsul"}],"PostTag":[{"post_id":"cjtbdahhd0003zk48n1cqrsck","tag_id":"cjtbdahhi0006zk48vxqqy48x","_id":"cjtbdahhn000czk480ktxaal5"},{"post_id":"cjtbdahhf0004zk48v4ekxchs","tag_id":"cjtbdahhi0006zk48vxqqy48x","_id":"cjtbdahhr000izk481dcw7p4p"},{"post_id":"cjtbdahhj0007zk48mprsie1g","tag_id":"cjtbdahhi0006zk48vxqqy48x","_id":"cjtbdahhu000ozk48snz6gi30"},{"post_id":"cjtbdahhk0008zk4868mkq012","tag_id":"cjtbdahhu000nzk48ak74emhj","_id":"cjtbdahhx000yzk48xyuflxo4"},{"post_id":"cjtbdahhk0008zk4868mkq012","tag_id":"cjtbdahhw000tzk48l5wjsxho","_id":"cjtbdahhx000zzk48nvs8l226"},{"post_id":"cjtbdahhk0009zk4849nguxy2","tag_id":"cjtbdahhx000wzk48a0atmupe","_id":"cjtbdahhy0016zk48j3t0xp9v"},{"post_id":"cjtbdahhk0009zk4849nguxy2","tag_id":"cjtbdahhy0012zk48q8vlfwza","_id":"cjtbdahhz0019zk48q8hz0j1o"},{"post_id":"cjtbdahhn000dzk48lmh3g8dq","tag_id":"cjtbdahhy0015zk4863xvbrlw","_id":"cjtbdahhz001bzk4896e11ih1"},{"post_id":"cjtbdahhp000ezk48vqzgtull","tag_id":"cjtbdahhz001azk483w8h9dpj","_id":"cjtbdahi1001jzk48yuoofnoy"},{"post_id":"cjtbdahhp000ezk48vqzgtull","tag_id":"cjtbdahi0001ezk48ylvtb501","_id":"cjtbdahi1001kzk48l7w8pyx6"},{"post_id":"cjtbdahhp000ezk48vqzgtull","tag_id":"cjtbdahi0001gzk48bzfxpgq4","_id":"cjtbdahi1001mzk4833s0n6au"},{"post_id":"cjtbdahhr000jzk484gzrh4ib","tag_id":"cjtbdahhu000nzk48ak74emhj","_id":"cjtbdahi2001pzk482pmckfsy"},{"post_id":"cjtbdahhr000jzk484gzrh4ib","tag_id":"cjtbdahi1001lzk48i4xatjsc","_id":"cjtbdahi2001qzk482b2wqygk"},{"post_id":"cjtbdahhr000jzk484gzrh4ib","tag_id":"cjtbdahi1001nzk48474k8aad","_id":"cjtbdahi2001szk48w9p0ytqn"},{"post_id":"cjtbdahht000kzk48o7ugb0nl","tag_id":"cjtbdahi2001ozk489au0rsa8","_id":"cjtbdahi2001tzk48ippxtam6"},{"post_id":"cjtbdahhu000pzk48e4phf52v","tag_id":"cjtbdahi2001rzk48q53rcvvc","_id":"cjtbdahi3001vzk48ldvmqqmg"},{"post_id":"cjtbdahhu000pzk48e4phf52v","tag_id":"cjtbdahhu000nzk48ak74emhj","_id":"cjtbdahi3001wzk482davjh4j"},{"post_id":"cjtbdahhv000qzk484wd8kra9","tag_id":"cjtbdahi2001uzk48ad6idty3","_id":"cjtbdahi3001zzk48ok138w8x"},{"post_id":"cjtbdahhv000qzk484wd8kra9","tag_id":"cjtbdahi3001xzk48dnqxjcok","_id":"cjtbdahi30020zk48ay14p5g9"},{"post_id":"cjtbdahhv000qzk484wd8kra9","tag_id":"cjtbdahi3001yzk48vub1xopo","_id":"cjtbdahi30021zk48acchjebr"},{"post_id":"cjtcsssju0000cy4801w2r2jy","tag_id":"cjtcsssk20001cy48h4307typ","_id":"cjtcsssk90003cy48aeudjw0i"},{"post_id":"cjtcsssju0000cy4801w2r2jy","tag_id":"cjtjtlmff000000vart3pkmtx","_id":"cjtjtlmfl000100valn0if9tv"},{"post_id":"cjtqz9mf00000lova9ssz2ak9","tag_id":"cjtqz9mfa0002lovaubp34h3z","_id":"cjtqz9mfb0003lovasiwr0sn6"}],"Tag":[{"name":"当我在扯淡","_id":"cjtbdahhi0006zk48vxqqy48x"},{"name":"算法","_id":"cjtbdahhu000nzk48ak74emhj"},{"name":"算法复杂度","_id":"cjtbdahhw000tzk48l5wjsxho"},{"name":"事件循环","_id":"cjtbdahhx000wzk48a0atmupe"},{"name":"任务队列","_id":"cjtbdahhy0012zk48q8vlfwza"},{"name":"你应该知道的","_id":"cjtbdahhy0015zk4863xvbrlw"},{"name":"微信小程序","_id":"cjtbdahhz001azk483w8h9dpj"},{"name":"mpvue","_id":"cjtbdahi0001ezk48ylvtb501"},{"name":"路由","_id":"cjtbdahi0001gzk48bzfxpgq4"},{"name":"动态规划","_id":"cjtbdahi1001lzk48i4xatjsc"},{"name":"递归","_id":"cjtbdahi1001nzk48474k8aad"},{"name":"interview","_id":"cjtbdahi2001ozk489au0rsa8"},{"name":"设计模式","_id":"cjtbdahi2001rzk48q53rcvvc"},{"name":"封装","_id":"cjtbdahi2001uzk48ad6idty3"},{"name":"koa","_id":"cjtbdahi3001xzk48dnqxjcok"},{"name":"洋葱模型","_id":"cjtbdahi3001yzk48vub1xopo"},{"name":"函数式编程","_id":"cjtcsssk20001cy48h4307typ"},{"name":"event emitter","_id":"cjtjtlmff000000vart3pkmtx"},{"name":"经济学","_id":"cjtqz9mfa0002lovaubp34h3z"}]}}