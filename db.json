{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/archer/source/CNAME","path":"CNAME","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/logo-36.png","path":"assets/logo-36.png","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/logo-64.png","path":"assets/logo-64.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/logo-48.png","path":"assets/logo-48.png","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/images/bg_post.png","path":"images/bg_post.png","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/wechat.png","path":"img/wechat.png","modified":0,"renderable":0},{"_id":"themes/archer/source/images/wechat.png","path":"images/wechat.png","modified":0,"renderable":1},{"_id":"themes/archer/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/images/bg_site.jpg","path":"images/bg_site.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550808959469},{"_id":"source/.DS_Store","hash":"add71aca0b02e042780de4a8e2ed80576d985452","modified":1550835606376},{"_id":"themes/archer/.DS_Store","hash":"4e15ba49a799d94b130c2b5413f1289de3d41ca6","modified":1550812864070},{"_id":"source/manifest.json","hash":"77bf0e97fabb77a4b3157589567da236006500c2","modified":1550744372310},{"_id":"themes/archer/README.md","hash":"fa398e05b0318ae4a657256e6ec6738791358d4f","modified":1549801924000},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1549801924000},{"_id":"themes/archer/_config.yml","hash":"29b663ccc6c2010891ebca7471abe1bafbf50981","modified":1550832200112},{"_id":"source/404.md","hash":"577791aa24ecec4b33d17acca505d4e0849bfc02","modified":1549801924000},{"_id":"themes/archer/gulpfile.js","hash":"88e2615c21ca95ae7bcdba499e50a54aebcd9f56","modified":1549801924000},{"_id":"themes/archer/package.json","hash":"80a1d936e347e61d9a41a4303ee32dc236017242","modified":1549801924000},{"_id":"themes/archer/webpack.config.js","hash":"d20b6350c50e2981484cb9356a3e21a2124bcd72","modified":1549801924000},{"_id":"themes/archer/webpack.prod.js","hash":"48de76cfa6274895801d3afc89ecbf04ee182a1c","modified":1549801924000},{"_id":"themes/archer/source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550809083470},{"_id":"source/_posts/.DS_Store","hash":"f16bc7e20c140961937b569d1d3375ac5bdb307d","modified":1550835606375},{"_id":"source/about/index.md","hash":"fb3569b1e15f42215a1a6c95a020ed1ac07ae250","modified":1550821550127},{"_id":"themes/archer/docs/README-en.md","hash":"ebd8845724cc9c524f1bdc617567bec2223abed6","modified":1549801924000},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"effc2bc9e0cecfd228b19283337ff29649ea5985","modified":1549801924000},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"0bb09c3c9d5f56820cb84e3316f60352b731d70c","modified":1549801924000},{"_id":"themes/archer/layout/404.ejs","hash":"879641b1b5e49c43f2e096cad281f7d74df05127","modified":1549801924000},{"_id":"themes/archer/layout/about.ejs","hash":"06019d835c0a51fed8aa086d1dfcf368f9921b42","modified":1549801924000},{"_id":"themes/archer/layout/index.ejs","hash":"716ba4a30860e36077dfdfffa02c1cd60301d8a3","modified":1549801924000},{"_id":"themes/archer/layout/layout.ejs","hash":"6573c53b013e8ea12607fad7d3d8bd0236664176","modified":1549801924000},{"_id":"themes/archer/layout/post.ejs","hash":"f8ae54b82a472319b2673c8312b5e779395f2f07","modified":1549801924000},{"_id":"themes/archer/layout/site-meta.ejs","hash":"1a200814c7ef027582ab9e4972726ef4a3347aed","modified":1549801924000},{"_id":"themes/archer/source/.DS_Store","hash":"116f15e722432867e3266273721ca892b740c5d6","modified":1550832447671},{"_id":"source/_posts/do something/关于小程序路由封装.md","hash":"16eb64c00b1d839a7f21d39546d052c145a69c28","modified":1550819743006},{"_id":"source/_posts/do something/动态规划和递归：从虎羊草开始.md","hash":"8425a46bbd5cf4093ee91198ef94b15e71a1897f","modified":1550809144943},{"_id":"source/_posts/do something/十行代码实现Koa2洋葱模型.md","hash":"6cf7683cc83d13fe2d93088f595938817f007126","modified":1550838072456},{"_id":"source/_posts/do something/.DS_Store","hash":"e6f93de9acddf64dd562a95b71bc5100758206d4","modified":1550835611378},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"457d2c8efcbdd08eccc5ea14c7e89f151a5a4088","modified":1550824601490},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"efde86772642dff2bb777556775b516f0cdc6e99","modified":1550823882959},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"2f5f9073378f628a9124792b5301c1540bc5a264","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"12e28693dc53cab5f6fd389f15ea0f811c9c37e9","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"20044d7e2740a690181149d137b9aef8b9860b4d","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"2aea84cb43f4479131620b3c3dfd7cebe9be36ba","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"d2a8ae42792ffd391f591dbcda3bdbc6fddebe02","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"418559ab11726f69621c3a58cd21903adff1e48e","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"2d068432031b3bebf9438c775370a2d1b4492d6b","modified":1549801924000},{"_id":"themes/archer/layout/_partial/google-adsense.ejs","hash":"8d86c7decc6f39bc6eef13feafe4a1a820f7374b","modified":1549801924000},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"cd0d34a811dc4666980d57c00d70dd82bd5450eb","modified":1549801924000},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1549801924000},{"_id":"themes/archer/source/assets/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550809961832},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1549801924000},{"_id":"themes/archer/source/assets/favicon.ico","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/css/mobile.css","hash":"0b7ac34da7d703064423480fc0526d91fa5716bc","modified":1549801924000},{"_id":"themes/archer/source/assets/logo-36.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/css/style.css","hash":"9b9e9ab4195f4f22bd52895ebedfa51b2182cab0","modified":1549801924000},{"_id":"themes/archer/source/assets/logo-64.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/assets/logo-48.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1549801924000},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1549801924000},{"_id":"themes/archer/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550832464601},{"_id":"themes/archer/source/images/favicon.ico","hash":"6484806109ed1950f6700639a86b96c6681d6f9e","modified":1547608978327},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1549801924000},{"_id":"themes/archer/source/scripts/main.js","hash":"258b08f308c2a78f6cc0a81cf353994da771966a","modified":1549801924000},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1549801924000},{"_id":"themes/archer/src/js/browser.js","hash":"03017b1e89b59346e681464c7609593c9aafa54c","modified":1549801924000},{"_id":"themes/archer/src/js/fancybox.js","hash":"0ce36efa325767c0ee7d5e5dfa174c68dd606e72","modified":1549801924000},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1549801924000},{"_id":"themes/archer/src/js/initSidebar.js","hash":"522aba19524b49efd323a2199f6eaa7396f1bd48","modified":1549801924000},{"_id":"themes/archer/src/js/init.js","hash":"989dea03ce93962b6a52818ee770ca3891679322","modified":1549801924000},{"_id":"themes/archer/src/js/main.js","hash":"58329fe74df0d4411d9486ebfc4c5fbc457f073f","modified":1549801924000},{"_id":"themes/archer/src/js/mobile.js","hash":"3c826a4385dc58ee878e5ea9bf3a25fac5d2b307","modified":1549801924000},{"_id":"themes/archer/src/js/scroll.js","hash":"11ae5ca33f6f84897ef4a01697a624770bea2025","modified":1549801924000},{"_id":"themes/archer/src/js/search.js","hash":"af9bdbff06987fdca8340ea49ccd91e993b9be53","modified":1549801924000},{"_id":"themes/archer/src/js/share.js","hash":"dff48b27ac212c4ea8e0c4c5ee323862c06c2882","modified":1549801924000},{"_id":"themes/archer/src/js/sidebar.js","hash":"8707392554fe813e33be84e9c64d30cb733dd0b4","modified":1549801924000},{"_id":"themes/archer/src/js/tag.js","hash":"156547cad5230c899cac12d3d29e60f5a103b7c4","modified":1549801924000},{"_id":"themes/archer/src/js/util.js","hash":"1c244b8def678df797ab3c049a03998db4f9dabb","modified":1549801924000},{"_id":"themes/archer/src/js/toc.js","hash":"2a01f07f302ccea3d36787571e34fd070ac42797","modified":1549801924000},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"27d5380e6a190071c0877a3651f3d877b91e03a1","modified":1549801924000},{"_id":"themes/archer/src/scss/_common.scss","hash":"71aa8bf9d5c66a432fd32b96a0953d53fcb533d2","modified":1549801924000},{"_id":"themes/archer/src/scss/style.scss","hash":"2d959b9c6a3a5b70df1bfa4ba0a6b8b758454e74","modified":1549801924000},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"b33d0d7e2e2807f50735f43e742f3c33471d38f7","modified":1549801924000},{"_id":"themes/archer/src/scss/_variables.scss","hash":"edd9e3dd34837f9c4e5f45eee8dc051b4caa8d28","modified":1549801924000},{"_id":"themes/archer/src/scss/mobile.scss","hash":"76a65f93c8bbcd5bc5fb7fca55919a12e7543a2b","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549801924000},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1549801924000},{"_id":"themes/archer/source/images/bg_post.png","hash":"dacb8dbf91978317e1fc0925137167f3f76285e2","modified":1507789973000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1549801924000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1549801924000},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1549801924000},{"_id":"themes/archer/package-lock.json","hash":"229960bd92beff7974f422f7cb2025ae610a2191","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"7691642fb9375607e0ac988a7420999e242cb2c9","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cadd97820a23d01d8b7e2f19a86e5290cef5a8a6","modified":1550824477536},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"794647a8a4ac9e1d01d74c07717175a141b1e01c","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"b27469f19f35ec2037c7bce736a12e9dfb5e360b","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"6bf59f01235c87cbca1555e4e027139de06688c2","modified":1550824322941},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"731d3980ac665d96dc6a40d31c2f8b86a221a8bb","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"790d76f2667377db78a7d04bad8d629e47e7aab0","modified":1549801924000},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"291cc0a4a444a93b93c32e2c39383c70e36e46de","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"daa78b17a773bca569f1c8ca2c916495ca138da6","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"147214469c4909eb94943599883f9fa0f3cc090d","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"2d38af7cb5aabc0af99de239bd180c516ec4c56c","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"d6e1a192cac5dcf365ce1a52df4f23feafeeb849","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"64a721c19c8c4d5b2b07d6aedcde1565be734e6d","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"8a74f79686e327b0566ea606fd7625eb57daf898","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"75776d8b85c8d2edc27eb7ed60d7c371f5109da0","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"97171c34f9b0676cf9113a1d637955415770f89b","modified":1549801924000},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"65efbfbaec7d09120ba62fee6e4643e6108098f6","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"73caccbe2634ff84e386d58e7f6ecd52d5ca2151","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"dbd7f802f3812f7e15c12885e495296f3697c580","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"eaff5b3e942e461109cdb6fd52f1d124b5a11951","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"e69b62df7c36d938cc4cf8e1fdcbc7109be41119","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"1229364f7c3484cc2ada6f118c859e3fd1dd9129","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"9f7a3877adccbfaf66ad574dbe2c8dc85fbf2f5a","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"fe42459805e4caa303df08964184548c33507d23","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a25960d1d9f501e50cb1fe86328dbc65faa29d22","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"9226a04dd9ea8389f88ced34962f1f55192d7a1a","modified":1549801924000},{"_id":"source/_posts/do something/十行代码实现Koa2洋葱模型/onion.png","hash":"64ed5f85efbca9cda0ecb5737edf3430f044f733","modified":1550835653175},{"_id":"source/img/wechat.png","hash":"1bb6520ad81686d563b56db149c38a54f33ed0b8","modified":1550820441456},{"_id":"themes/archer/source/images/wechat.png","hash":"1bb6520ad81686d563b56db149c38a54f33ed0b8","modified":1550820441456},{"_id":"themes/archer/source/images/avatar.jpg","hash":"67187d3e3c0a8e3bb673fc8de590a16b30695575","modified":1550832392563},{"_id":"themes/archer/source/images/bg_site.jpg","hash":"958660a9659be7b1c58eb60c8abf6d4ff0dfc88c","modified":1546938271109},{"_id":"public/manifest.json","hash":"a23c85880d1c222879e8646ecdc177eaf7cecdaa","modified":1550838109848},{"_id":"public/atom.xml","hash":"00c456ad0d6a5ed8884b116e1dc6dbdd691248ff","modified":1550838109848},{"_id":"public/content.json","hash":"e02299c3c92d4ad79a14b3832b88320d8abe30ce","modified":1550838110153},{"_id":"public/post-sitemap.xml","hash":"3e5bf9c99779a3e4be34d26aab4037111befec52","modified":1550838110154},{"_id":"public/page-sitemap.xml","hash":"abd51844712b5bd943330b0271f704932ef4a5bd","modified":1550838110158},{"_id":"public/category-sitemap.xml","hash":"cd34758ecf51665134f44c736b39f9fcd5c02c33","modified":1550838110158},{"_id":"public/tag-sitemap.xml","hash":"c2e544f1a8a0083a1d9020ee18eb505ff5aa77c2","modified":1550838110158},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1550838110158},{"_id":"public/sitemap.xml","hash":"5839a5f59b6986bb898e9c08824514f086640301","modified":1550838110158},{"_id":"public/404.html","hash":"c88f5311962bfa525234aabc3aba6a865cf658e6","modified":1550838110164},{"_id":"public/about/index.html","hash":"13d001bcb7f2a3a125b138bcc944eb2f759d32da","modified":1550838110164},{"_id":"public/2019/02/22/do something/十行代码实现Koa2洋葱模型/index.html","hash":"eeef7c7a51b325e655c0e57a85015091251c1dd5","modified":1550838110164},{"_id":"public/2019/02/21/do something/动态规划和递归：从虎羊草开始/index.html","hash":"1a83e715c797acda21e0614c1d65ca2ac6228ff5","modified":1550838110164},{"_id":"public/2018/12/09/do something/关于小程序路由封装/index.html","hash":"31485d932f16a8cc5373d9e969dc33a9d047e8e0","modified":1550838110164},{"_id":"public/archives/index.html","hash":"ceac911bbb78d115163ca722a6cc3456d9bdcb85","modified":1550838110164},{"_id":"public/archives/2018/index.html","hash":"4788e053c1db7d8fc867d41cd16405c87dccf821","modified":1550838110164},{"_id":"public/archives/2018/12/index.html","hash":"4788e053c1db7d8fc867d41cd16405c87dccf821","modified":1550838110164},{"_id":"public/archives/2019/index.html","hash":"a6a24d80f40406b6957cdd7de104feece5f54381","modified":1550838110165},{"_id":"public/archives/2019/02/index.html","hash":"a6a24d80f40406b6957cdd7de104feece5f54381","modified":1550838110165},{"_id":"public/categories/封装/index.html","hash":"ca693d431a53bca25596d3ee06aa82962fc61b43","modified":1550838110165},{"_id":"public/categories/算法/index.html","hash":"0b23543634c1f95c654cc272488745a914b64efa","modified":1550838110165},{"_id":"public/index.html","hash":"5b7032142f977ce3e54fdb613e88946cc0eeeb12","modified":1550838110165},{"_id":"public/tags/封装/index.html","hash":"ca693d431a53bca25596d3ee06aa82962fc61b43","modified":1550838110165},{"_id":"public/tags/mpvue/index.html","hash":"4788e053c1db7d8fc867d41cd16405c87dccf821","modified":1550838110165},{"_id":"public/tags/微信小程序/index.html","hash":"4788e053c1db7d8fc867d41cd16405c87dccf821","modified":1550838110165},{"_id":"public/tags/路由/index.html","hash":"4788e053c1db7d8fc867d41cd16405c87dccf821","modified":1550838110165},{"_id":"public/tags/算法/index.html","hash":"0b23543634c1f95c654cc272488745a914b64efa","modified":1550838110165},{"_id":"public/tags/递归/index.html","hash":"0b23543634c1f95c654cc272488745a914b64efa","modified":1550838110165},{"_id":"public/tags/动态规划/index.html","hash":"0b23543634c1f95c654cc272488745a914b64efa","modified":1550838110165},{"_id":"public/tags/尾递归/index.html","hash":"0b23543634c1f95c654cc272488745a914b64efa","modified":1550838110165},{"_id":"public/tags/koa/index.html","hash":"3c0729c999e5707829d3227dcb25fc10f385426d","modified":1550838110165},{"_id":"public/tags/洋葱模型/index.html","hash":"3c0729c999e5707829d3227dcb25fc10f385426d","modified":1550838110165},{"_id":"public/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550838110166},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1550838110169},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1550838110169},{"_id":"public/assets/favicon.ico","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1550838110169},{"_id":"public/assets/logo-36.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1550838110169},{"_id":"public/assets/logo-64.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1550838110169},{"_id":"public/assets/logo-48.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1550838110169},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1550838110169},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1550838110170},{"_id":"public/images/favicon.ico","hash":"6484806109ed1950f6700639a86b96c6681d6f9e","modified":1550838110170},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"fb0ff0949c9179447690e049aaced1ee0615941b","modified":1550838110170},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1550838110173},{"_id":"public/images/bg_post.png","hash":"dacb8dbf91978317e1fc0925137167f3f76285e2","modified":1550838110174},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1550838110175},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1550838110175},{"_id":"public/css/mobile.css","hash":"0b7ac34da7d703064423480fc0526d91fa5716bc","modified":1550838110180},{"_id":"public/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1550838110180},{"_id":"public/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1550838110180},{"_id":"public/css/style.css","hash":"9b9e9ab4195f4f22bd52895ebedfa51b2182cab0","modified":1550838110180},{"_id":"public/scripts/main.js","hash":"258b08f308c2a78f6cc0a81cf353994da771966a","modified":1550838110180},{"_id":"public/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1550838110180},{"_id":"public/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1550838110180},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"5244731131a647d230c1d80731171191adc7e2a8","modified":1550838110181},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"001e6cc7c8f14dd9c544942410cea2dda5fe5387","modified":1550838110181},{"_id":"public/2019/02/22/do something/十行代码实现Koa2洋葱模型/onion.png","hash":"64ed5f85efbca9cda0ecb5737edf3430f044f733","modified":1550838110185},{"_id":"public/assets/algolia/algoliasearch.js","hash":"f0e3215b0553fcc11715d655e35cbc8dea9bae85","modified":1550838110187},{"_id":"public/img/wechat.png","hash":"1bb6520ad81686d563b56db149c38a54f33ed0b8","modified":1550838110207},{"_id":"public/images/wechat.png","hash":"1bb6520ad81686d563b56db149c38a54f33ed0b8","modified":1550838110210},{"_id":"public/images/avatar.jpg","hash":"67187d3e3c0a8e3bb673fc8de590a16b30695575","modified":1550838110220},{"_id":"public/images/bg_site.jpg","hash":"958660a9659be7b1c58eb60c8abf6d4ff0dfc88c","modified":1550838110227}],"Category":[{"name":"封装","_id":"cjsg0yvmr00056a488lu0drk0"},{"name":"算法","_id":"cjsg0yvmu00086a485wsdfp6i"}],"Data":[],"Page":[{"_content":"{\n    \"dir\": \"auto\",\n    \"lang\": \"zh\",\n    \"name\": \"kwok io\",\n    \"scope\": \"/\",\n    \"display\": \"standalone\",\n    \"start_url\": \"/\",\n    \"short_name\": \"kwok io\",\n    \"theme_color\": \"transparent\",\n    \"description\": \"- kwok io\",\n    \"orientation\": \"any\",\n    \"background_color\": \"transparent\",\n    \"related_applications\": [],\n    \"prefer_related_applications\": false,\n    \"gcm_sender_id\": \"482941778795\",\n    \"gcm_sender_id_comment\": \"Do not change the GCM Sender ID\",\n    \"icons\": [{\n      \"src\": \"/assets/logo-32.png\",\n      \"sizes\": \"32x32\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"/assets/logo-48.png\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/png\"\n    },\n    {\n        \"src\": \"/assets/logo-64.png\",\n        \"sizes\": \"64x64\",\n        \"type\": \"image/png\"\n      }\n    ]\n  }","source":"manifest.json","raw":"{\n    \"dir\": \"auto\",\n    \"lang\": \"zh\",\n    \"name\": \"kwok io\",\n    \"scope\": \"/\",\n    \"display\": \"standalone\",\n    \"start_url\": \"/\",\n    \"short_name\": \"kwok io\",\n    \"theme_color\": \"transparent\",\n    \"description\": \"- kwok io\",\n    \"orientation\": \"any\",\n    \"background_color\": \"transparent\",\n    \"related_applications\": [],\n    \"prefer_related_applications\": false,\n    \"gcm_sender_id\": \"482941778795\",\n    \"gcm_sender_id_comment\": \"Do not change the GCM Sender ID\",\n    \"icons\": [{\n      \"src\": \"/assets/logo-32.png\",\n      \"sizes\": \"32x32\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"/assets/logo-48.png\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/png\"\n    },\n    {\n        \"src\": \"/assets/logo-64.png\",\n        \"sizes\": \"64x64\",\n        \"type\": \"image/png\"\n      }\n    ]\n  }","date":"2019-02-21T10:19:32.310Z","updated":"2019-02-21T10:19:32.310Z","path":"manifest.json","layout":"false","title":"","comments":1,"_id":"cjsg0yvlv00006a487z748cy7","content":"{\"dir\":\"auto\",\"lang\":\"zh\",\"name\":\"kwok io\",\"scope\":\"/\",\"display\":\"standalone\",\"start_url\":\"/\",\"short_name\":\"kwok io\",\"theme_color\":\"transparent\",\"description\":\"- kwok io\",\"orientation\":\"any\",\"background_color\":\"transparent\",\"related_applications\":[],\"prefer_related_applications\":false,\"gcm_sender_id\":\"482941778795\",\"gcm_sender_id_comment\":\"Do not change the GCM Sender ID\",\"icons\":[{\"src\":\"/assets/logo-32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-64.png\",\"sizes\":\"64x64\",\"type\":\"image/png\"}]}","site":{"data":{}},"excerpt":"","more":"{\"dir\":\"auto\",\"lang\":\"zh\",\"name\":\"kwok io\",\"scope\":\"/\",\"display\":\"standalone\",\"start_url\":\"/\",\"short_name\":\"kwok io\",\"theme_color\":\"transparent\",\"description\":\"- kwok io\",\"orientation\":\"any\",\"background_color\":\"transparent\",\"related_applications\":[],\"prefer_related_applications\":false,\"gcm_sender_id\":\"482941778795\",\"gcm_sender_id_comment\":\"Do not change the GCM Sender ID\",\"icons\":[{\"src\":\"/assets/logo-32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-64.png\",\"sizes\":\"64x64\",\"type\":\"image/png\"}]}"},{"layout":"404","title":"[404]","description":"May the Force be with you :&#41;","_content":"","source":"404.md","raw":"---\nlayout: 404\ntitle: \"[404]\"\ndescription: \"May the Force be with you :&#41;\"\n---","date":"2019-02-21T09:46:42.749Z","updated":"2019-02-10T12:32:04.000Z","path":"404.html","comments":1,"_id":"cjsg0yvlw00016a482k9jkt5u","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"chris kwok","layout":"about","_content":"hi\n\nhere is chris kwok\n\nas a front-end coder\n\nin shanghai\n\n","source":"about/index.md","raw":"---\ntitle: chris kwok\nlayout: about\n---\nhi\n\nhere is chris kwok\n\nas a front-end coder\n\nin shanghai\n\n","date":"2019-02-22T07:45:50.127Z","updated":"2019-02-22T07:45:50.127Z","path":"about/index.html","comments":1,"_id":"cjsg0yvm800026a48uic9foum","content":"<p>hi</p>\n<p>here is chris kwok</p>\n<p>as a front-end coder</p>\n<p>in shanghai</p>\n","site":{"data":{}},"excerpt":"","more":"<p>hi</p>\n<p>here is chris kwok</p>\n<p>as a front-end coder</p>\n<p>in shanghai</p>\n"}],"Post":[{"title":"小程序的路由封装","date":"2018-12-09T08:00:00.000Z","_content":"\n# 小程序路由封装\n\n基于 `mpvue` 小程序的路由封装\n\n[toc]\n\n## \b基本使用\n\n组件内使用方法：\n```js\n\n  // 不携带路由参数\n  this.$router.push('/home/page/index')\n  // 携带路由参数\n  this.$router.push({\n    path: '/home/page/index',\n    query: {\n      //\n    },\n    reLaunch: true, // 调用wx.reLaunch\n    isTab: true // 调用wx.switchTag\n  })\n\n  // 读取当前页面路由参数\n\n  \bconst { query } = this.$route\n\n```\n组件外部使用只需要引入router.js内部导出的push\b方法即可\n\n\n## \b封装起步\n\n分为两点切入：\n  1. 了解\b微信提供的api\n  2. \b自己的需求\n\n总结为以下几点：\n\n- 对微信小程序的 `switchTab、reLaunch、navigateTo、redirectTo` 二次封装，\b对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 `this.$router.push` 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 `this.$route.query` 读取。\n\n- 路由默认跳转为 `wx.navigateTo` \b静态跳转，调用其他跳转方式需传递相应参数\n\n* \b封装的跳转优先级：\n```\n    wx.switchTab >> wx.reLaunch >> wx.navigateTo\n```\n\n- 路由拥有拦截器，分为全局拦截和针对指定页面根据 `path` 拦截。\n\n_注意： 路由不支持指定 `wx.redireactTo` 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈\b仅支持十层）_\n\n\n下面我会由不同的需求以问答方式\b一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题\n\n\n### 如何完成基本跳转功能\n\n_需求：页面内使用 `this.$router.push` 方法跳转页面_\n\n首先就是新建 `index.js` 自定义一个最基本的 `push` 方法用来跳转页面\n\n``` js\n  // location 为路由传参\n  function push(location) {\n\n    const params = { url: location.path }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n\n然后为了让我们可以在页面中使用这个方法需要将 `push` 方法挂载在页面的实例上, 同时使用插件式调用在 `index.js` 文件中导出 `install` 方法\n\n``` js\n  // 导出\n  export default {\n    install(Vue) {\n\n      const _router = {\n        mode: 'history',\n        push\n      }\n      // 定义描述符getter（也可直接赋值value）\n      const $router = {\n        get() {\n          return _router\n        }\n      }\n      // 挂载 (各\b凭喜好也可以直接赋值在prototype\b上）\n      Object.defineProperty(Vue.prototype, '$router', $router)\n    }\n  }\n```\n\n接下来在项目入口文件注入上面 `index.js` 文件并执行 `Vue.use`\n\n``` js\n  import Vue from 'vue'\n  import router from './index.js'\n  \n  Vue.use(router) \n```\n\n即可在任意页面使用 `this.$router.push` 方法并传入相应跳转方式和路径\n\n这里存在一个问题： \b项目跳转为了更美观主要使用 `wx.navigateTo`， \b而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释\n\n### 页面之间如何读写参数\n\n_需求： 页面内跳转通过路由参数 `query` 字段传参， 通过 `this.$route.query` 读取参数_\n\n所以我们需要一个能够简单解析 `push` \b方法参数的功能型函数 `parseUrl`，里面包括将所传的 `query` 字段以地址栏参数形式拼接在 `path` 后面的一个 `stringifyQuery` 函数\n\n``` js\n  function parseUrl(location) {\n    const { path, query } = location\n    const queryStr = stringifyQuery(query)\n\n    return `${path}${queryStr}`\n  }\n\n  \bfunction stringifyQuery(obj) {\n    const res = obj\n      ? Object.keys(obj)\n          .filter(Boolean)\n          .map(key => {\n            let val = obj[key]\n\n            if ([Array, Object].includes(val.constructor)) {\n              val = JSON.stringify(obj[key])\n            }\n            return `${key}=${val}`\n          })\n          \n          .join('&')\n      : null\n\n    return res ? `?${res}` : ''\n  }\n```\n\n把 `parseUrl` 方法添加到上面的 `push` 方法，同时参数内部是支持小程序路由跳转过程的`success`, `fail`, `complete` 钩子的 \n\n``` js\n  // location 为路由传参\n  function push(location) {\n    // others 为用户可能传递的 `success`, `fail`, `complete`\n    const { path, query, ...others } = location\n\n    const url = parseUrl({ path, query })\n\n    const params = { url, ...others }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n以上路由传参并解析部分已经完成，接下来读取参数的控制\b需要定义一个 `$route` 对象与前面的 `$router` 一致挂载页面实例上\n\n这一层读mpvue的实例创建一个 `parseRoute` 函数简单处理一下数据即可\n\n此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0\n以下同时简单处理一下\n\n``` js\n  function parseRoute($mp) {\n    // $mp 为mpvue实例root上挂载的对象\n    const _mp = $mp || {}\n    const path = _mp.page && _mp.page.route\n    const parseQuery = {}\n    const tempQuery = _mp.query\n\n    for (let k in tempQuery) {\n      let cur = tempQuery[k]\n\n      try {\n        // 解决长整型丢失精度\n        const transfer = JSON.parse(tempQuery[k])\n\n        if (!(typeof transfer === 'number')) {\n          cur = transfer\n        }\n      } catch (e) {}\n\n      parseQuery[k] = cur\n    }\n\n    return {\n      parseQuery\n    }\n  }\n```\n\n最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 `onShow` 钩子上\n\n``` js\n  const _route = {}\n\n  Vue.mixin({\n    onShow() {\n      const { $mp } = this.$root\n\n      _route = parseRoute($mp)\n    }\n  })\n\n  const $route = {\n    get() {\n      return _route\n    }\n  }\n\n  Object.defineProperty(Vue.prototype, '$route', $route)\n```\n以上便完成路由参数的读写\n\n### \b解决上面提出的小程序堆栈限制\b问题\n\n小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 `wx.redirectTo` 即可（其他时间项目中仅使用 `navigateTo` 即可）\n\n首先需要一个全局变量记录堆栈长度(\b微信提供一个getCurrentPages的方法)， 同时更改 `push` 方法\n\n``` js\n  // 当前页面堆栈长度\n  let pageStackLen = 0\n  // 堆栈限制\n  const maxStackLen = 10\n\n  function push(location, success, ...ohters) {\n    pageStackLen = getCurrentPages().length + 1\n\n    const url = parseUrl(location)\n\n    // 包装跳转成功的回调\n    const _success = function() {\n      pageStackLen = getCurrentPages().length + 1\n\n      success && success()\n    }\n\n    const params = { url, success: _success, ...ohters}\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n      pageStackLen = 1\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n\n      pageStackLen = 1\n    } else {\n      if (pageStackLen >= maxStackLen) {\n        wx.redirectTo(params)\n        return\n      }\n      wx.navigateTo(params)\n    }\n  }\n```\n以上基本解决小程序堆栈限制问题\n\n### 完善路由跳转功能\n\n现在对路由的跳转做一些基本辅助功能的支持\b `go`、 `back`, `replace` 等方法\n\n``` js\n  function replace(location, ...others) {\n    const url = parseUrl(location)\n\n    wx.redirectTo({\n      url,\n      ...others\n    })\n  }\n\n  function go(delta) {\n    wx.navigateBack({\n      delta\n    })\n  }\n\n  function back() {\n    wx.navigateBack()\n  }\n```\n\n将这些挂到 `$router` 对象\n\n``` js\n  const _router = {\n    mode: 'history',\n    push,\n    replace,\n    go,\n    back\n  }\n\n  const $router = {\n    get() {\n      return _router\n    }\n  }\n\n```\n\n此外还有我们不需要\b页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传\b基本路径自动补齐, \b单独导出 `push` 方法方便组件外部调用等优化\n\n\b最后我们还差路由拦截器功能的实现\n\n### 路由拦截器\n\n需求： 对象形式配置自己路由规则\n  - `[triggerAll]`： \b所有路由跳转均会触发\n  - `[triggerMatch]`： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发\n\n参数介绍：\n- `config`: 携带当前路由跳转信息（路由参数）\n- `to`: \b控制跳转（调用 `to()` ）\n\n\n\b使用方式：\n\n``` js\nexport default {\n  triggerAll(config, to) {\n    console.log(config, 'enter interceptor')\n    to()\n  },\n  triggerMatch: {\n    '/home/pages/categoryList': [\n      (config, to) => {\n        if (/*flag*/) {\n          console.log(1)\n          to()\n        }\n      }\n    ]\n  }\n}\n```\n\n本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的\n\n新建 `interceptor.js`\n\n首先引入之前的路由方便在实例上调用，定义 `triggerMatch` 的对象存储存入的函数 `key` 为当前路由的路径，\b`value` 为 中间件函数组成的数组\n\n关键： 将 `push` 方法当做单独的一个中间件并放在所有中间件的最后执行\n\n``` js\n  // 引入\n  import router from './index.js'\n  // 挂载\n  Vue.use(router)\n  // 存匹配指定路由的业务函数\n  let matchMiddlewares = {}\n\n```\n接下来要构建一个处理推入规则的\b业务函数（中间件）的 `compose` 函数\n\n\b\b这个函数的作用主要分为两个：\n - \b依次派发推入拦截器的\b业务函数\n - 控制下一次派发的开始\n\n``` js\n  const compose = middlewares => (...args) => {\n    function dispatch(i) {\n      return !middlewares[i]\n        ? Promise.resolve('no arguments')\n        : Promise.resolve(\n            middlewares[i](...args, function() {\n              // 派发下个调用\n              // 此处即是拦截器中第二个实参 to 方法的函数体\n              // 调动 to() 即开启下一次派发\n              return dispatch(++i)\n            })\n          )\n    }\n    // 开启调用\n    return dispatch(0)\n  }\n```\n\n\b创建一个函数 `getMatchMiddlewares` 用来根据指定键值读取 `matchMiddlewares` 中中间件函数数组\n\n```js\n  function getMatchMiddlewares(path) {\n    return matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []\n  }\n```\n\n\n路由同样使用 `Vue.use` 方法注册，这里导出 \b`install` 方法, 在里面统一所有中间件函数\n\n``` js\n  // 包装 push\n  let $push\n\n  function pushMiddware(...args) {\n    $push(...args)\n  }\n\n  export default {\n    install(Vue, { triggerAll, triggerMatch }) {\n      // 存储原 push 函数\n      $push = Vue.prototype.$router.push\n      // 接收传入的匹配函数\n      matchMiddlewares = Object.assign({}, triggerMatch)\n      \n      // 重新赋值\n      Vue.prototype.$router.push = (...args) => {\n        // 合并\n        compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(\n          ...args\n        )\n      }\n    }\n  }\n\n\n```\n\n之后在入口文件中引入即可\n\n``` js\n  import Vue from 'vue'\n  import interceptor from './interceptor.js'\n\n  Vue.use(interceptor)\n```\n\n至此便完成了路由的所有功能的基本封装\n\n详细代码可以查看 [小程序路由](http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router)\n\n此篇文章已经发布在 [http://doc.yupaopao.com](http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857)\n\n## 总结\n路由\b基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步。\n\n开放、真实！peace.\n","source":"_posts/do something/关于小程序路由封装.md","raw":"---\ntitle: 小程序的路由封装\ntags:\n  - 封装\n  - 微信小程序\n  - mpvue\n  - 路由\ndate: 2018-12-09 16:00:00\ncategories: 封装\n---\n\n# 小程序路由封装\n\n基于 `mpvue` 小程序的路由封装\n\n[toc]\n\n## \b基本使用\n\n组件内使用方法：\n```js\n\n  // 不携带路由参数\n  this.$router.push('/home/page/index')\n  // 携带路由参数\n  this.$router.push({\n    path: '/home/page/index',\n    query: {\n      //\n    },\n    reLaunch: true, // 调用wx.reLaunch\n    isTab: true // 调用wx.switchTag\n  })\n\n  // 读取当前页面路由参数\n\n  \bconst { query } = this.$route\n\n```\n组件外部使用只需要引入router.js内部导出的push\b方法即可\n\n\n## \b封装起步\n\n分为两点切入：\n  1. 了解\b微信提供的api\n  2. \b自己的需求\n\n总结为以下几点：\n\n- 对微信小程序的 `switchTab、reLaunch、navigateTo、redirectTo` 二次封装，\b对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 `this.$router.push` 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 `this.$route.query` 读取。\n\n- 路由默认跳转为 `wx.navigateTo` \b静态跳转，调用其他跳转方式需传递相应参数\n\n* \b封装的跳转优先级：\n```\n    wx.switchTab >> wx.reLaunch >> wx.navigateTo\n```\n\n- 路由拥有拦截器，分为全局拦截和针对指定页面根据 `path` 拦截。\n\n_注意： 路由不支持指定 `wx.redireactTo` 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈\b仅支持十层）_\n\n\n下面我会由不同的需求以问答方式\b一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题\n\n\n### 如何完成基本跳转功能\n\n_需求：页面内使用 `this.$router.push` 方法跳转页面_\n\n首先就是新建 `index.js` 自定义一个最基本的 `push` 方法用来跳转页面\n\n``` js\n  // location 为路由传参\n  function push(location) {\n\n    const params = { url: location.path }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n\n然后为了让我们可以在页面中使用这个方法需要将 `push` 方法挂载在页面的实例上, 同时使用插件式调用在 `index.js` 文件中导出 `install` 方法\n\n``` js\n  // 导出\n  export default {\n    install(Vue) {\n\n      const _router = {\n        mode: 'history',\n        push\n      }\n      // 定义描述符getter（也可直接赋值value）\n      const $router = {\n        get() {\n          return _router\n        }\n      }\n      // 挂载 (各\b凭喜好也可以直接赋值在prototype\b上）\n      Object.defineProperty(Vue.prototype, '$router', $router)\n    }\n  }\n```\n\n接下来在项目入口文件注入上面 `index.js` 文件并执行 `Vue.use`\n\n``` js\n  import Vue from 'vue'\n  import router from './index.js'\n  \n  Vue.use(router) \n```\n\n即可在任意页面使用 `this.$router.push` 方法并传入相应跳转方式和路径\n\n这里存在一个问题： \b项目跳转为了更美观主要使用 `wx.navigateTo`， \b而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释\n\n### 页面之间如何读写参数\n\n_需求： 页面内跳转通过路由参数 `query` 字段传参， 通过 `this.$route.query` 读取参数_\n\n所以我们需要一个能够简单解析 `push` \b方法参数的功能型函数 `parseUrl`，里面包括将所传的 `query` 字段以地址栏参数形式拼接在 `path` 后面的一个 `stringifyQuery` 函数\n\n``` js\n  function parseUrl(location) {\n    const { path, query } = location\n    const queryStr = stringifyQuery(query)\n\n    return `${path}${queryStr}`\n  }\n\n  \bfunction stringifyQuery(obj) {\n    const res = obj\n      ? Object.keys(obj)\n          .filter(Boolean)\n          .map(key => {\n            let val = obj[key]\n\n            if ([Array, Object].includes(val.constructor)) {\n              val = JSON.stringify(obj[key])\n            }\n            return `${key}=${val}`\n          })\n          \n          .join('&')\n      : null\n\n    return res ? `?${res}` : ''\n  }\n```\n\n把 `parseUrl` 方法添加到上面的 `push` 方法，同时参数内部是支持小程序路由跳转过程的`success`, `fail`, `complete` 钩子的 \n\n``` js\n  // location 为路由传参\n  function push(location) {\n    // others 为用户可能传递的 `success`, `fail`, `complete`\n    const { path, query, ...others } = location\n\n    const url = parseUrl({ path, query })\n\n    const params = { url, ...others }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n以上路由传参并解析部分已经完成，接下来读取参数的控制\b需要定义一个 `$route` 对象与前面的 `$router` 一致挂载页面实例上\n\n这一层读mpvue的实例创建一个 `parseRoute` 函数简单处理一下数据即可\n\n此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0\n以下同时简单处理一下\n\n``` js\n  function parseRoute($mp) {\n    // $mp 为mpvue实例root上挂载的对象\n    const _mp = $mp || {}\n    const path = _mp.page && _mp.page.route\n    const parseQuery = {}\n    const tempQuery = _mp.query\n\n    for (let k in tempQuery) {\n      let cur = tempQuery[k]\n\n      try {\n        // 解决长整型丢失精度\n        const transfer = JSON.parse(tempQuery[k])\n\n        if (!(typeof transfer === 'number')) {\n          cur = transfer\n        }\n      } catch (e) {}\n\n      parseQuery[k] = cur\n    }\n\n    return {\n      parseQuery\n    }\n  }\n```\n\n最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 `onShow` 钩子上\n\n``` js\n  const _route = {}\n\n  Vue.mixin({\n    onShow() {\n      const { $mp } = this.$root\n\n      _route = parseRoute($mp)\n    }\n  })\n\n  const $route = {\n    get() {\n      return _route\n    }\n  }\n\n  Object.defineProperty(Vue.prototype, '$route', $route)\n```\n以上便完成路由参数的读写\n\n### \b解决上面提出的小程序堆栈限制\b问题\n\n小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 `wx.redirectTo` 即可（其他时间项目中仅使用 `navigateTo` 即可）\n\n首先需要一个全局变量记录堆栈长度(\b微信提供一个getCurrentPages的方法)， 同时更改 `push` 方法\n\n``` js\n  // 当前页面堆栈长度\n  let pageStackLen = 0\n  // 堆栈限制\n  const maxStackLen = 10\n\n  function push(location, success, ...ohters) {\n    pageStackLen = getCurrentPages().length + 1\n\n    const url = parseUrl(location)\n\n    // 包装跳转成功的回调\n    const _success = function() {\n      pageStackLen = getCurrentPages().length + 1\n\n      success && success()\n    }\n\n    const params = { url, success: _success, ...ohters}\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n      pageStackLen = 1\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n\n      pageStackLen = 1\n    } else {\n      if (pageStackLen >= maxStackLen) {\n        wx.redirectTo(params)\n        return\n      }\n      wx.navigateTo(params)\n    }\n  }\n```\n以上基本解决小程序堆栈限制问题\n\n### 完善路由跳转功能\n\n现在对路由的跳转做一些基本辅助功能的支持\b `go`、 `back`, `replace` 等方法\n\n``` js\n  function replace(location, ...others) {\n    const url = parseUrl(location)\n\n    wx.redirectTo({\n      url,\n      ...others\n    })\n  }\n\n  function go(delta) {\n    wx.navigateBack({\n      delta\n    })\n  }\n\n  function back() {\n    wx.navigateBack()\n  }\n```\n\n将这些挂到 `$router` 对象\n\n``` js\n  const _router = {\n    mode: 'history',\n    push,\n    replace,\n    go,\n    back\n  }\n\n  const $router = {\n    get() {\n      return _router\n    }\n  }\n\n```\n\n此外还有我们不需要\b页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传\b基本路径自动补齐, \b单独导出 `push` 方法方便组件外部调用等优化\n\n\b最后我们还差路由拦截器功能的实现\n\n### 路由拦截器\n\n需求： 对象形式配置自己路由规则\n  - `[triggerAll]`： \b所有路由跳转均会触发\n  - `[triggerMatch]`： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发\n\n参数介绍：\n- `config`: 携带当前路由跳转信息（路由参数）\n- `to`: \b控制跳转（调用 `to()` ）\n\n\n\b使用方式：\n\n``` js\nexport default {\n  triggerAll(config, to) {\n    console.log(config, 'enter interceptor')\n    to()\n  },\n  triggerMatch: {\n    '/home/pages/categoryList': [\n      (config, to) => {\n        if (/*flag*/) {\n          console.log(1)\n          to()\n        }\n      }\n    ]\n  }\n}\n```\n\n本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的\n\n新建 `interceptor.js`\n\n首先引入之前的路由方便在实例上调用，定义 `triggerMatch` 的对象存储存入的函数 `key` 为当前路由的路径，\b`value` 为 中间件函数组成的数组\n\n关键： 将 `push` 方法当做单独的一个中间件并放在所有中间件的最后执行\n\n``` js\n  // 引入\n  import router from './index.js'\n  // 挂载\n  Vue.use(router)\n  // 存匹配指定路由的业务函数\n  let matchMiddlewares = {}\n\n```\n接下来要构建一个处理推入规则的\b业务函数（中间件）的 `compose` 函数\n\n\b\b这个函数的作用主要分为两个：\n - \b依次派发推入拦截器的\b业务函数\n - 控制下一次派发的开始\n\n``` js\n  const compose = middlewares => (...args) => {\n    function dispatch(i) {\n      return !middlewares[i]\n        ? Promise.resolve('no arguments')\n        : Promise.resolve(\n            middlewares[i](...args, function() {\n              // 派发下个调用\n              // 此处即是拦截器中第二个实参 to 方法的函数体\n              // 调动 to() 即开启下一次派发\n              return dispatch(++i)\n            })\n          )\n    }\n    // 开启调用\n    return dispatch(0)\n  }\n```\n\n\b创建一个函数 `getMatchMiddlewares` 用来根据指定键值读取 `matchMiddlewares` 中中间件函数数组\n\n```js\n  function getMatchMiddlewares(path) {\n    return matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []\n  }\n```\n\n\n路由同样使用 `Vue.use` 方法注册，这里导出 \b`install` 方法, 在里面统一所有中间件函数\n\n``` js\n  // 包装 push\n  let $push\n\n  function pushMiddware(...args) {\n    $push(...args)\n  }\n\n  export default {\n    install(Vue, { triggerAll, triggerMatch }) {\n      // 存储原 push 函数\n      $push = Vue.prototype.$router.push\n      // 接收传入的匹配函数\n      matchMiddlewares = Object.assign({}, triggerMatch)\n      \n      // 重新赋值\n      Vue.prototype.$router.push = (...args) => {\n        // 合并\n        compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(\n          ...args\n        )\n      }\n    }\n  }\n\n\n```\n\n之后在入口文件中引入即可\n\n``` js\n  import Vue from 'vue'\n  import interceptor from './interceptor.js'\n\n  Vue.use(interceptor)\n```\n\n至此便完成了路由的所有功能的基本封装\n\n详细代码可以查看 [小程序路由](http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router)\n\n此篇文章已经发布在 [http://doc.yupaopao.com](http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857)\n\n## 总结\n路由\b基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步。\n\n开放、真实！peace.\n","slug":"do something/关于小程序路由封装","published":1,"updated":"2019-02-22T07:15:43.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsg0yvmn00036a48v96qg46t","content":"<h1 id=\"小程序路由封装\"><a href=\"#小程序路由封装\" class=\"headerlink\" title=\"小程序路由封装\"></a>小程序路由封装</h1><p>基于 <code>mpvue</code> 小程序的路由封装</p>\n<p>[toc]</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"\b基本使用\"></a>\b基本使用</h2><p>组件内使用方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/home/page/index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/home/page/index'</span>,</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reLaunch: <span class=\"literal\">true</span>, <span class=\"comment\">// 调用wx.reLaunch</span></span><br><span class=\"line\">  isTab: <span class=\"literal\">true</span> <span class=\"comment\">// 调用wx.switchTag</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取当前页面路由参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\b<span class=\"keyword\">const</span> &#123; query &#125; = <span class=\"keyword\">this</span>.$route</span><br></pre></td></tr></table></figure></p>\n<p>组件外部使用只需要引入router.js内部导出的push\b方法即可</p>\n<h2 id=\"封装起步\"><a href=\"#封装起步\" class=\"headerlink\" title=\"\b封装起步\"></a>\b封装起步</h2><p>分为两点切入：</p>\n<ol>\n<li>了解\b微信提供的api</li>\n<li>\b自己的需求</li>\n</ol>\n<p>总结为以下几点：</p>\n<ul>\n<li><p>对微信小程序的 <code>switchTab、reLaunch、navigateTo、redirectTo</code> 二次封装，\b对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 <code>this.$router.push</code> 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 <code>this.$route.query</code> 读取。</p>\n</li>\n<li><p>路由默认跳转为 <code>wx.navigateTo</code> \b静态跳转，调用其他跳转方式需传递相应参数</p>\n</li>\n</ul>\n<ul>\n<li>\b封装的跳转优先级：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.switchTab &gt;&gt; wx.reLaunch &gt;&gt; wx.navigateTo</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>路由拥有拦截器，分为全局拦截和针对指定页面根据 <code>path</code> 拦截。</li>\n</ul>\n<p><em>注意： 路由不支持指定 <code>wx.redireactTo</code> 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈\b仅支持十层）</em></p>\n<p>下面我会由不同的需求以问答方式\b一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题</p>\n<h3 id=\"如何完成基本跳转功能\"><a href=\"#如何完成基本跳转功能\" class=\"headerlink\" title=\"如何完成基本跳转功能\"></a>如何完成基本跳转功能</h3><p><em>需求：页面内使用 <code>this.$router.push</code> 方法跳转页面</em></p>\n<p>首先就是新建 <code>index.js</code> 自定义一个最基本的 <code>push</code> 方法用来跳转页面</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; <span class=\"attr\">url</span>: location.path &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后为了让我们可以在页面中使用这个方法需要将 <code>push</code> 方法挂载在页面的实例上, 同时使用插件式调用在 <code>index.js</code> 文件中导出 <code>install</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">      mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">      push</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义描述符getter（也可直接赋值value）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载 (各\b凭喜好也可以直接赋值在prototype\b上）</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$router'</span>, $router)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在项目入口文件注入上面 <code>index.js</code> 文件并执行 <code>Vue.use</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(router)</span><br></pre></td></tr></table></figure>\n<p>即可在任意页面使用 <code>this.$router.push</code> 方法并传入相应跳转方式和路径</p>\n<p>这里存在一个问题： \b项目跳转为了更美观主要使用 <code>wx.navigateTo</code>， \b而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释</p>\n<h3 id=\"页面之间如何读写参数\"><a href=\"#页面之间如何读写参数\" class=\"headerlink\" title=\"页面之间如何读写参数\"></a>页面之间如何读写参数</h3><p><em>需求： 页面内跳转通过路由参数 <code>query</code> 字段传参， 通过 <code>this.$route.query</code> 读取参数</em></p>\n<p>所以我们需要一个能够简单解析 <code>push</code> \b方法参数的功能型函数 <code>parseUrl</code>，里面包括将所传的 <code>query</code> 字段以地址栏参数形式拼接在 <code>path</code> 后面的一个 <code>stringifyQuery</code> 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseUrl</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query &#125; = location</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queryStr = stringifyQuery(query)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;path&#125;</span><span class=\"subst\">$&#123;queryStr&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\b<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringifyQuery</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = obj</span><br><span class=\"line\">    ? <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">        .filter(<span class=\"built_in\">Boolean</span>)</span><br><span class=\"line\">        .map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> val = obj[key]</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ([<span class=\"built_in\">Array</span>, <span class=\"built_in\">Object</span>].includes(val.constructor)) &#123;</span><br><span class=\"line\">            val = <span class=\"built_in\">JSON</span>.stringify(obj[key])</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;val&#125;</span>`</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        .join(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? <span class=\"string\">`?<span class=\"subst\">$&#123;res&#125;</span>`</span> : <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 <code>parseUrl</code> 方法添加到上面的 <code>push</code> 方法，同时参数内部是支持小程序路由跳转过程的<code>success</code>, <code>fail</code>, <code>complete</code> 钩子的 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// others 为用户可能传递的 `success`, `fail`, `complete`</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query, ...others &#125; = location</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(&#123; path, query &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, ...others &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上路由传参并解析部分已经完成，接下来读取参数的控制\b需要定义一个 <code>$route</code> 对象与前面的 <code>$router</code> 一致挂载页面实例上</p>\n<p>这一层读mpvue的实例创建一个 <code>parseRoute</code> 函数简单处理一下数据即可</p>\n<p>此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0<br>以下同时简单处理一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseRoute</span>(<span class=\"params\">$mp</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $mp 为mpvue实例root上挂载的对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _mp = $mp || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = _mp.page &amp;&amp; _mp.page.route</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parseQuery = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tempQuery = _mp.query</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> tempQuery) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cur = tempQuery[k]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 解决长整型丢失精度</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> transfer = <span class=\"built_in\">JSON</span>.parse(tempQuery[k])</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(<span class=\"keyword\">typeof</span> transfer === <span class=\"string\">'number'</span>)) &#123;</span><br><span class=\"line\">        cur = transfer</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parseQuery[k] = cur</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    parseQuery</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 <code>onShow</code> 钩子上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _route = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.mixin(&#123;</span><br><span class=\"line\">  onShow() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; $mp &#125; = <span class=\"keyword\">this</span>.$root</span><br><span class=\"line\"></span><br><span class=\"line\">    _route = parseRoute($mp)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $route = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _route</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$route'</span>, $route)</span><br></pre></td></tr></table></figure>\n<p>以上便完成路由参数的读写</p>\n<h3 id=\"解决上面提出的小程序堆栈限制问题\"><a href=\"#解决上面提出的小程序堆栈限制问题\" class=\"headerlink\" title=\"\b解决上面提出的小程序堆栈限制\b问题\"></a>\b解决上面提出的小程序堆栈限制\b问题</h3><p>小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 <code>wx.redirectTo</code> 即可（其他时间项目中仅使用 <code>navigateTo</code> 即可）</p>\n<p>首先需要一个全局变量记录堆栈长度(\b微信提供一个getCurrentPages的方法)， 同时更改 <code>push</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前页面堆栈长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pageStackLen = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 堆栈限制</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxStackLen = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location, success, ...ohters</span>) </span>&#123;</span><br><span class=\"line\">  pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 包装跳转成功的回调</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _success = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    success &amp;&amp; success()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, <span class=\"attr\">success</span>: _success, ...ohters&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pageStackLen &gt;= maxStackLen) &#123;</span><br><span class=\"line\">      wx.redirectTo(params)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上基本解决小程序堆栈限制问题</p>\n<h3 id=\"完善路由跳转功能\"><a href=\"#完善路由跳转功能\" class=\"headerlink\" title=\"完善路由跳转功能\"></a>完善路由跳转功能</h3><p>现在对路由的跳转做一些基本辅助功能的支持\b <code>go</code>、 <code>back</code>, <code>replace</code> 等方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">location, ...others</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  wx.redirectTo(&#123;</span><br><span class=\"line\">    url,</span><br><span class=\"line\">    ...others</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">delta</span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack(&#123;</span><br><span class=\"line\">    delta</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">back</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这些挂到 <code>$router</code> 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">  push,</span><br><span class=\"line\">  replace,</span><br><span class=\"line\">  go,</span><br><span class=\"line\">  back</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有我们不需要\b页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传\b基本路径自动补齐, \b单独导出 <code>push</code> 方法方便组件外部调用等优化</p>\n<p>\b最后我们还差路由拦截器功能的实现</p>\n<h3 id=\"路由拦截器\"><a href=\"#路由拦截器\" class=\"headerlink\" title=\"路由拦截器\"></a>路由拦截器</h3><p>需求： 对象形式配置自己路由规则</p>\n<ul>\n<li><code>[triggerAll]</code>： \b所有路由跳转均会触发</li>\n<li><code>[triggerMatch]</code>： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发</li>\n</ul>\n<p>参数介绍：</p>\n<ul>\n<li><code>config</code>: 携带当前路由跳转信息（路由参数）</li>\n<li><code>to</code>: \b控制跳转（调用 <code>to()</code> ）</li>\n</ul>\n<p>\b使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  triggerAll(config, to) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(config, <span class=\"string\">'enter interceptor'</span>)</span><br><span class=\"line\">    to()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  triggerMatch: &#123;</span><br><span class=\"line\">    <span class=\"string\">'/home/pages/categoryList'</span>: [</span><br><span class=\"line\">      (config, to) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*flag*/</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">          to()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的</p>\n<p>新建 <code>interceptor.js</code></p>\n<p>首先引入之前的路由方便在实例上调用，定义 <code>triggerMatch</code> 的对象存储存入的函数 <code>key</code> 为当前路由的路径，\b<code>value</code> 为 中间件函数组成的数组</p>\n<p>关键： 将 <code>push</code> 方法当做单独的一个中间件并放在所有中间件的最后执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 挂载</span></span><br><span class=\"line\">Vue.use(router)</span><br><span class=\"line\"><span class=\"comment\">// 存匹配指定路由的业务函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> matchMiddlewares = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来要构建一个处理推入规则的\b业务函数（中间件）的 <code>compose</code> 函数</p>\n<p>\b\b这个函数的作用主要分为两个：</p>\n<ul>\n<li>\b依次派发推入拦截器的\b业务函数</li>\n<li>控制下一次派发的开始</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !middlewares[i]</span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'no arguments'</span>)</span><br><span class=\"line\">      : <span class=\"built_in\">Promise</span>.resolve(</span><br><span class=\"line\">          middlewares[i](...args, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 派发下个调用</span></span><br><span class=\"line\">            <span class=\"comment\">// 此处即是拦截器中第二个实参 to 方法的函数体</span></span><br><span class=\"line\">            <span class=\"comment\">// 调动 to() 即开启下一次派发</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatch(++i)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 开启调用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>\b创建一个函数 <code>getMatchMiddlewares</code> 用来根据指定键值读取 <code>matchMiddlewares</code> 中中间件函数数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMatchMiddlewares</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路由同样使用 <code>Vue.use</code> 方法注册，这里导出 \b<code>install</code> 方法, 在里面统一所有中间件函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包装 push</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> $push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushMiddware</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  $push(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue, &#123; triggerAll, triggerMatch &#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储原 push 函数</span></span><br><span class=\"line\">    $push = Vue.prototype.$router.push</span><br><span class=\"line\">    <span class=\"comment\">// 接收传入的匹配函数</span></span><br><span class=\"line\">    matchMiddlewares = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, triggerMatch)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">    Vue.prototype.$router.push = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 合并</span></span><br><span class=\"line\">      compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(</span><br><span class=\"line\">        ...args</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后在入口文件中引入即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> interceptor <span class=\"keyword\">from</span> <span class=\"string\">'./interceptor.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(interceptor)</span><br></pre></td></tr></table></figure>\n<p>至此便完成了路由的所有功能的基本封装</p>\n<p>详细代码可以查看 <a href=\"http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router\" target=\"_blank\" rel=\"noopener\">小程序路由</a></p>\n<p>此篇文章已经发布在 <a href=\"http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857\" target=\"_blank\" rel=\"noopener\">http://doc.yupaopao.com</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>路由\b基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步。</p>\n<p>开放、真实！peace.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"小程序路由封装\"><a href=\"#小程序路由封装\" class=\"headerlink\" title=\"小程序路由封装\"></a>小程序路由封装</h1><p>基于 <code>mpvue</code> 小程序的路由封装</p>\n<p>[toc]</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"\b基本使用\"></a>\b基本使用</h2><p>组件内使用方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/home/page/index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/home/page/index'</span>,</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reLaunch: <span class=\"literal\">true</span>, <span class=\"comment\">// 调用wx.reLaunch</span></span><br><span class=\"line\">  isTab: <span class=\"literal\">true</span> <span class=\"comment\">// 调用wx.switchTag</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取当前页面路由参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\b<span class=\"keyword\">const</span> &#123; query &#125; = <span class=\"keyword\">this</span>.$route</span><br></pre></td></tr></table></figure></p>\n<p>组件外部使用只需要引入router.js内部导出的push\b方法即可</p>\n<h2 id=\"封装起步\"><a href=\"#封装起步\" class=\"headerlink\" title=\"\b封装起步\"></a>\b封装起步</h2><p>分为两点切入：</p>\n<ol>\n<li>了解\b微信提供的api</li>\n<li>\b自己的需求</li>\n</ol>\n<p>总结为以下几点：</p>\n<ul>\n<li><p>对微信小程序的 <code>switchTab、reLaunch、navigateTo、redirectTo</code> 二次封装，\b对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 <code>this.$router.push</code> 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 <code>this.$route.query</code> 读取。</p>\n</li>\n<li><p>路由默认跳转为 <code>wx.navigateTo</code> \b静态跳转，调用其他跳转方式需传递相应参数</p>\n</li>\n</ul>\n<ul>\n<li>\b封装的跳转优先级：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.switchTab &gt;&gt; wx.reLaunch &gt;&gt; wx.navigateTo</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>路由拥有拦截器，分为全局拦截和针对指定页面根据 <code>path</code> 拦截。</li>\n</ul>\n<p><em>注意： 路由不支持指定 <code>wx.redireactTo</code> 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈\b仅支持十层）</em></p>\n<p>下面我会由不同的需求以问答方式\b一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题</p>\n<h3 id=\"如何完成基本跳转功能\"><a href=\"#如何完成基本跳转功能\" class=\"headerlink\" title=\"如何完成基本跳转功能\"></a>如何完成基本跳转功能</h3><p><em>需求：页面内使用 <code>this.$router.push</code> 方法跳转页面</em></p>\n<p>首先就是新建 <code>index.js</code> 自定义一个最基本的 <code>push</code> 方法用来跳转页面</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; <span class=\"attr\">url</span>: location.path &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后为了让我们可以在页面中使用这个方法需要将 <code>push</code> 方法挂载在页面的实例上, 同时使用插件式调用在 <code>index.js</code> 文件中导出 <code>install</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">      mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">      push</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义描述符getter（也可直接赋值value）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载 (各\b凭喜好也可以直接赋值在prototype\b上）</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$router'</span>, $router)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在项目入口文件注入上面 <code>index.js</code> 文件并执行 <code>Vue.use</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(router)</span><br></pre></td></tr></table></figure>\n<p>即可在任意页面使用 <code>this.$router.push</code> 方法并传入相应跳转方式和路径</p>\n<p>这里存在一个问题： \b项目跳转为了更美观主要使用 <code>wx.navigateTo</code>， \b而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释</p>\n<h3 id=\"页面之间如何读写参数\"><a href=\"#页面之间如何读写参数\" class=\"headerlink\" title=\"页面之间如何读写参数\"></a>页面之间如何读写参数</h3><p><em>需求： 页面内跳转通过路由参数 <code>query</code> 字段传参， 通过 <code>this.$route.query</code> 读取参数</em></p>\n<p>所以我们需要一个能够简单解析 <code>push</code> \b方法参数的功能型函数 <code>parseUrl</code>，里面包括将所传的 <code>query</code> 字段以地址栏参数形式拼接在 <code>path</code> 后面的一个 <code>stringifyQuery</code> 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseUrl</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query &#125; = location</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queryStr = stringifyQuery(query)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;path&#125;</span><span class=\"subst\">$&#123;queryStr&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\b<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringifyQuery</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = obj</span><br><span class=\"line\">    ? <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">        .filter(<span class=\"built_in\">Boolean</span>)</span><br><span class=\"line\">        .map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> val = obj[key]</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ([<span class=\"built_in\">Array</span>, <span class=\"built_in\">Object</span>].includes(val.constructor)) &#123;</span><br><span class=\"line\">            val = <span class=\"built_in\">JSON</span>.stringify(obj[key])</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;val&#125;</span>`</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        .join(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? <span class=\"string\">`?<span class=\"subst\">$&#123;res&#125;</span>`</span> : <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 <code>parseUrl</code> 方法添加到上面的 <code>push</code> 方法，同时参数内部是支持小程序路由跳转过程的<code>success</code>, <code>fail</code>, <code>complete</code> 钩子的 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// others 为用户可能传递的 `success`, `fail`, `complete`</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query, ...others &#125; = location</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(&#123; path, query &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, ...others &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上路由传参并解析部分已经完成，接下来读取参数的控制\b需要定义一个 <code>$route</code> 对象与前面的 <code>$router</code> 一致挂载页面实例上</p>\n<p>这一层读mpvue的实例创建一个 <code>parseRoute</code> 函数简单处理一下数据即可</p>\n<p>此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0<br>以下同时简单处理一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseRoute</span>(<span class=\"params\">$mp</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $mp 为mpvue实例root上挂载的对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _mp = $mp || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = _mp.page &amp;&amp; _mp.page.route</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parseQuery = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tempQuery = _mp.query</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> tempQuery) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cur = tempQuery[k]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 解决长整型丢失精度</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> transfer = <span class=\"built_in\">JSON</span>.parse(tempQuery[k])</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(<span class=\"keyword\">typeof</span> transfer === <span class=\"string\">'number'</span>)) &#123;</span><br><span class=\"line\">        cur = transfer</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parseQuery[k] = cur</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    parseQuery</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 <code>onShow</code> 钩子上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _route = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.mixin(&#123;</span><br><span class=\"line\">  onShow() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; $mp &#125; = <span class=\"keyword\">this</span>.$root</span><br><span class=\"line\"></span><br><span class=\"line\">    _route = parseRoute($mp)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $route = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _route</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$route'</span>, $route)</span><br></pre></td></tr></table></figure>\n<p>以上便完成路由参数的读写</p>\n<h3 id=\"解决上面提出的小程序堆栈限制问题\"><a href=\"#解决上面提出的小程序堆栈限制问题\" class=\"headerlink\" title=\"\b解决上面提出的小程序堆栈限制\b问题\"></a>\b解决上面提出的小程序堆栈限制\b问题</h3><p>小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 <code>wx.redirectTo</code> 即可（其他时间项目中仅使用 <code>navigateTo</code> 即可）</p>\n<p>首先需要一个全局变量记录堆栈长度(\b微信提供一个getCurrentPages的方法)， 同时更改 <code>push</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前页面堆栈长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pageStackLen = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 堆栈限制</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxStackLen = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location, success, ...ohters</span>) </span>&#123;</span><br><span class=\"line\">  pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 包装跳转成功的回调</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _success = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    success &amp;&amp; success()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, <span class=\"attr\">success</span>: _success, ...ohters&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pageStackLen &gt;= maxStackLen) &#123;</span><br><span class=\"line\">      wx.redirectTo(params)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上基本解决小程序堆栈限制问题</p>\n<h3 id=\"完善路由跳转功能\"><a href=\"#完善路由跳转功能\" class=\"headerlink\" title=\"完善路由跳转功能\"></a>完善路由跳转功能</h3><p>现在对路由的跳转做一些基本辅助功能的支持\b <code>go</code>、 <code>back</code>, <code>replace</code> 等方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">location, ...others</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  wx.redirectTo(&#123;</span><br><span class=\"line\">    url,</span><br><span class=\"line\">    ...others</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">delta</span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack(&#123;</span><br><span class=\"line\">    delta</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">back</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这些挂到 <code>$router</code> 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">  push,</span><br><span class=\"line\">  replace,</span><br><span class=\"line\">  go,</span><br><span class=\"line\">  back</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有我们不需要\b页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传\b基本路径自动补齐, \b单独导出 <code>push</code> 方法方便组件外部调用等优化</p>\n<p>\b最后我们还差路由拦截器功能的实现</p>\n<h3 id=\"路由拦截器\"><a href=\"#路由拦截器\" class=\"headerlink\" title=\"路由拦截器\"></a>路由拦截器</h3><p>需求： 对象形式配置自己路由规则</p>\n<ul>\n<li><code>[triggerAll]</code>： \b所有路由跳转均会触发</li>\n<li><code>[triggerMatch]</code>： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发</li>\n</ul>\n<p>参数介绍：</p>\n<ul>\n<li><code>config</code>: 携带当前路由跳转信息（路由参数）</li>\n<li><code>to</code>: \b控制跳转（调用 <code>to()</code> ）</li>\n</ul>\n<p>\b使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  triggerAll(config, to) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(config, <span class=\"string\">'enter interceptor'</span>)</span><br><span class=\"line\">    to()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  triggerMatch: &#123;</span><br><span class=\"line\">    <span class=\"string\">'/home/pages/categoryList'</span>: [</span><br><span class=\"line\">      (config, to) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*flag*/</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">          to()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的</p>\n<p>新建 <code>interceptor.js</code></p>\n<p>首先引入之前的路由方便在实例上调用，定义 <code>triggerMatch</code> 的对象存储存入的函数 <code>key</code> 为当前路由的路径，\b<code>value</code> 为 中间件函数组成的数组</p>\n<p>关键： 将 <code>push</code> 方法当做单独的一个中间件并放在所有中间件的最后执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 挂载</span></span><br><span class=\"line\">Vue.use(router)</span><br><span class=\"line\"><span class=\"comment\">// 存匹配指定路由的业务函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> matchMiddlewares = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来要构建一个处理推入规则的\b业务函数（中间件）的 <code>compose</code> 函数</p>\n<p>\b\b这个函数的作用主要分为两个：</p>\n<ul>\n<li>\b依次派发推入拦截器的\b业务函数</li>\n<li>控制下一次派发的开始</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !middlewares[i]</span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'no arguments'</span>)</span><br><span class=\"line\">      : <span class=\"built_in\">Promise</span>.resolve(</span><br><span class=\"line\">          middlewares[i](...args, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 派发下个调用</span></span><br><span class=\"line\">            <span class=\"comment\">// 此处即是拦截器中第二个实参 to 方法的函数体</span></span><br><span class=\"line\">            <span class=\"comment\">// 调动 to() 即开启下一次派发</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatch(++i)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 开启调用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>\b创建一个函数 <code>getMatchMiddlewares</code> 用来根据指定键值读取 <code>matchMiddlewares</code> 中中间件函数数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMatchMiddlewares</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路由同样使用 <code>Vue.use</code> 方法注册，这里导出 \b<code>install</code> 方法, 在里面统一所有中间件函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包装 push</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> $push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushMiddware</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  $push(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue, &#123; triggerAll, triggerMatch &#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储原 push 函数</span></span><br><span class=\"line\">    $push = Vue.prototype.$router.push</span><br><span class=\"line\">    <span class=\"comment\">// 接收传入的匹配函数</span></span><br><span class=\"line\">    matchMiddlewares = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, triggerMatch)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">    Vue.prototype.$router.push = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 合并</span></span><br><span class=\"line\">      compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(</span><br><span class=\"line\">        ...args</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后在入口文件中引入即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> interceptor <span class=\"keyword\">from</span> <span class=\"string\">'./interceptor.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(interceptor)</span><br></pre></td></tr></table></figure>\n<p>至此便完成了路由的所有功能的基本封装</p>\n<p>详细代码可以查看 <a href=\"http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router\" target=\"_blank\" rel=\"noopener\">小程序路由</a></p>\n<p>此篇文章已经发布在 <a href=\"http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857\" target=\"_blank\" rel=\"noopener\">http://doc.yupaopao.com</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>路由\b基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步。</p>\n<p>开放、真实！peace.</p>\n"},{"title":"动态规划和递归：从虎羊草开始","date":"2019-02-21T12:36:00.000Z","_content":"# 问题：老虎会吃羊吗？🐅🐑\n\n草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）\n\n_提示:每只老虎都很聪明_\n\n## 从最基本的情况入手\n\n#### case1: 两只老虎一只羊\n\n不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃\n\n#### case2: 三只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case1\n\n#### case3: 四只老虎一只羊\n\n不吃：一只老虎吃完羊后情景变为case2会被吃\n\n#### case4: 五只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case3\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃\n\n引出课题 `Dynamic Programming`\n\n# Dynamic Programming\n\n> 简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念\n\n- 最优子结构\n- 边界\n- 状态转移公式\n\n下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题\n\n_Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........这个数列从第3项开始，每一项都等于前两项之和_\n\n在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）因此可以直接写出以下代码：\n``` js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  return fn(n-1) + fn(n-2)\n}\n```\n运行结果如下：\n``` js\nconsole.log(\n  `第1项${fn(1)}`,\n  `第2项${fn(2)}`,\n  `第3项${fn(3)}`,\n  `第4项${fn(4)}`,\n  `第5项${fn(5)}`,\n  `第6项${fn(6)}`,\n  `第7项${fn(7)}`\n)\n// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13\n```\n\n现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念\n\n1. 最优子结构：若想求得第 `m` 项的值，那么只需要去求得第 `m-1` 和 `m-2` 的值即可，那么 `fn(m-1) + fn(m-2) === f(m)` 等式成立\n2. 边界: 即范围\n3. 状态转移公式：`f(m) = fn(m-1) + fn(m-2)`\n\n上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？\n具象化来看： 求得f(5) = ？\n - f(5)依赖 f(4)和f(3)\n - f(4)依赖 f(3)和f(2)\n - f(3)依赖 f(2)和f(1)\n\n显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：\n\n```js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  let m = 1, m_1 = 1, result\n\n  for(let i = 3; i <= n; i++){\n    result = m + m_1\n    m_1 = m\n    m = result\n  }\n\n  return result\n}\n```\n\n结果和上面是一致的但是性能就会有非常大的提升了\n\n# 既然上面提到了递归我们就再来说说递归\n_递归： 程序调用自身的编程技巧称为递归（recursion）_\n\n那么上面 `return fn(n-1) + fn(n-2)` 就是一个最普通的递归\n\n这里再引入一个尾递归的概念：就是函数在尾部调用自身\n\n那下面来简单说说为什么上面递归的写法性能会那么差\n\n调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存\n\n将上面方法改用尾递归的写法：\n```js\nfunction fn(n, m_1 = 1, m = 1) {  \n  if (n === 1 || n === 2) return m\n\n  return fn(n - 1, m, m + m_1)\n}\n```\n此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍\n\n当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈\n\n# summary\n\ndraven：好好看 好好学\n\n\n","source":"_posts/do something/动态规划和递归：从虎羊草开始.md","raw":"---\ntitle: 动态规划和递归：从虎羊草开始\ntags:\n  - 算法\n  - 动态规划\n  - 递归\n  - 尾递归\ndate: 2019-02-21 20:36:00\ncategories: 算法\n---\n# 问题：老虎会吃羊吗？🐅🐑\n\n草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）\n\n_提示:每只老虎都很聪明_\n\n## 从最基本的情况入手\n\n#### case1: 两只老虎一只羊\n\n不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃\n\n#### case2: 三只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case1\n\n#### case3: 四只老虎一只羊\n\n不吃：一只老虎吃完羊后情景变为case2会被吃\n\n#### case4: 五只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case3\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃\n\n引出课题 `Dynamic Programming`\n\n# Dynamic Programming\n\n> 简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念\n\n- 最优子结构\n- 边界\n- 状态转移公式\n\n下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题\n\n_Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........这个数列从第3项开始，每一项都等于前两项之和_\n\n在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）因此可以直接写出以下代码：\n``` js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  return fn(n-1) + fn(n-2)\n}\n```\n运行结果如下：\n``` js\nconsole.log(\n  `第1项${fn(1)}`,\n  `第2项${fn(2)}`,\n  `第3项${fn(3)}`,\n  `第4项${fn(4)}`,\n  `第5项${fn(5)}`,\n  `第6项${fn(6)}`,\n  `第7项${fn(7)}`\n)\n// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13\n```\n\n现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念\n\n1. 最优子结构：若想求得第 `m` 项的值，那么只需要去求得第 `m-1` 和 `m-2` 的值即可，那么 `fn(m-1) + fn(m-2) === f(m)` 等式成立\n2. 边界: 即范围\n3. 状态转移公式：`f(m) = fn(m-1) + fn(m-2)`\n\n上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？\n具象化来看： 求得f(5) = ？\n - f(5)依赖 f(4)和f(3)\n - f(4)依赖 f(3)和f(2)\n - f(3)依赖 f(2)和f(1)\n\n显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：\n\n```js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  let m = 1, m_1 = 1, result\n\n  for(let i = 3; i <= n; i++){\n    result = m + m_1\n    m_1 = m\n    m = result\n  }\n\n  return result\n}\n```\n\n结果和上面是一致的但是性能就会有非常大的提升了\n\n# 既然上面提到了递归我们就再来说说递归\n_递归： 程序调用自身的编程技巧称为递归（recursion）_\n\n那么上面 `return fn(n-1) + fn(n-2)` 就是一个最普通的递归\n\n这里再引入一个尾递归的概念：就是函数在尾部调用自身\n\n那下面来简单说说为什么上面递归的写法性能会那么差\n\n调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存\n\n将上面方法改用尾递归的写法：\n```js\nfunction fn(n, m_1 = 1, m = 1) {  \n  if (n === 1 || n === 2) return m\n\n  return fn(n - 1, m, m + m_1)\n}\n```\n此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍\n\n当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈\n\n# summary\n\ndraven：好好看 好好学\n\n\n","slug":"do something/动态规划和递归：从虎羊草开始","published":1,"updated":"2019-02-22T04:19:04.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsg0yvmp00046a484rzholdw","content":"<h1 id=\"问题：老虎会吃羊吗？🐅🐑\"><a href=\"#问题：老虎会吃羊吗？🐅🐑\" class=\"headerlink\" title=\"问题：老虎会吃羊吗？🐅🐑\"></a>问题：老虎会吃羊吗？🐅🐑</h1><p>草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）</p>\n<p><em>提示:每只老虎都很聪明</em></p>\n<h2 id=\"从最基本的情况入手\"><a href=\"#从最基本的情况入手\" class=\"headerlink\" title=\"从最基本的情况入手\"></a>从最基本的情况入手</h2><h4 id=\"case1-两只老虎一只羊\"><a href=\"#case1-两只老虎一只羊\" class=\"headerlink\" title=\"case1: 两只老虎一只羊\"></a>case1: 两只老虎一只羊</h4><p>不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃</p>\n<h4 id=\"case2-三只老虎一只羊\"><a href=\"#case2-三只老虎一只羊\" class=\"headerlink\" title=\"case2: 三只老虎一只羊\"></a>case2: 三只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case1</p>\n<h4 id=\"case3-四只老虎一只羊\"><a href=\"#case3-四只老虎一只羊\" class=\"headerlink\" title=\"case3: 四只老虎一只羊\"></a>case3: 四只老虎一只羊</h4><p>不吃：一只老虎吃完羊后情景变为case2会被吃</p>\n<h4 id=\"case4-五只老虎一只羊\"><a href=\"#case4-五只老虎一只羊\" class=\"headerlink\" title=\"case4: 五只老虎一只羊\"></a>case4: 五只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case3</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃</p>\n<p>引出课题 <code>Dynamic Programming</code></p>\n<h1 id=\"Dynamic-Programming\"><a href=\"#Dynamic-Programming\" class=\"headerlink\" title=\"Dynamic Programming\"></a>Dynamic Programming</h1><blockquote>\n<p>简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念</p>\n</blockquote>\n<ul>\n<li>最优子结构</li>\n<li>边界</li>\n<li>状态转移公式</li>\n</ul>\n<p>下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题</p>\n<p><em>Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..这个数列从第3项开始，每一项都等于前两项之和</em></p>\n<p>在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）因此可以直接写出以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n<span class=\"number\">-1</span>) + fn(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第1项<span class=\"subst\">$&#123;fn(<span class=\"number\">1</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第2项<span class=\"subst\">$&#123;fn(<span class=\"number\">2</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第3项<span class=\"subst\">$&#123;fn(<span class=\"number\">3</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第4项<span class=\"subst\">$&#123;fn(<span class=\"number\">4</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第5项<span class=\"subst\">$&#123;fn(<span class=\"number\">5</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第6项<span class=\"subst\">$&#123;fn(<span class=\"number\">6</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第7项<span class=\"subst\">$&#123;fn(<span class=\"number\">7</span>)&#125;</span>`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13</span></span><br></pre></td></tr></table></figure></p>\n<p>现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念</p>\n<ol>\n<li>最优子结构：若想求得第 <code>m</code> 项的值，那么只需要去求得第 <code>m-1</code> 和 <code>m-2</code> 的值即可，那么 <code>fn(m-1) + fn(m-2) === f(m)</code> 等式成立</li>\n<li>边界: 即范围</li>\n<li>状态转移公式：<code>f(m) = fn(m-1) + fn(m-2)</code></li>\n</ol>\n<p>上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？<br>具象化来看： 求得f(5) = ？</p>\n<ul>\n<li>f(5)依赖 f(4)和f(3)</li>\n<li>f(4)依赖 f(3)和f(2)</li>\n<li>f(3)依赖 f(2)和f(1)</li>\n</ul>\n<p>显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>, m_1 = <span class=\"number\">1</span>, result</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">    result = m + m_1</span><br><span class=\"line\">    m_1 = m</span><br><span class=\"line\">    m = result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果和上面是一致的但是性能就会有非常大的提升了</p>\n<h1 id=\"既然上面提到了递归我们就再来说说递归\"><a href=\"#既然上面提到了递归我们就再来说说递归\" class=\"headerlink\" title=\"既然上面提到了递归我们就再来说说递归\"></a>既然上面提到了递归我们就再来说说递归</h1><p><em>递归： 程序调用自身的编程技巧称为递归（recursion）</em></p>\n<p>那么上面 <code>return fn(n-1) + fn(n-2)</code> 就是一个最普通的递归</p>\n<p>这里再引入一个尾递归的概念：就是函数在尾部调用自身</p>\n<p>那下面来简单说说为什么上面递归的写法性能会那么差</p>\n<p>调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存</p>\n<p>将上面方法改用尾递归的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n, m_1 = <span class=\"number\">1</span>, m = <span class=\"number\">1</span></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> m</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n - <span class=\"number\">1</span>, m, m + m_1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍</p>\n<p>当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>draven：好好看 好好学</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题：老虎会吃羊吗？🐅🐑\"><a href=\"#问题：老虎会吃羊吗？🐅🐑\" class=\"headerlink\" title=\"问题：老虎会吃羊吗？🐅🐑\"></a>问题：老虎会吃羊吗？🐅🐑</h1><p>草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）</p>\n<p><em>提示:每只老虎都很聪明</em></p>\n<h2 id=\"从最基本的情况入手\"><a href=\"#从最基本的情况入手\" class=\"headerlink\" title=\"从最基本的情况入手\"></a>从最基本的情况入手</h2><h4 id=\"case1-两只老虎一只羊\"><a href=\"#case1-两只老虎一只羊\" class=\"headerlink\" title=\"case1: 两只老虎一只羊\"></a>case1: 两只老虎一只羊</h4><p>不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃</p>\n<h4 id=\"case2-三只老虎一只羊\"><a href=\"#case2-三只老虎一只羊\" class=\"headerlink\" title=\"case2: 三只老虎一只羊\"></a>case2: 三只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case1</p>\n<h4 id=\"case3-四只老虎一只羊\"><a href=\"#case3-四只老虎一只羊\" class=\"headerlink\" title=\"case3: 四只老虎一只羊\"></a>case3: 四只老虎一只羊</h4><p>不吃：一只老虎吃完羊后情景变为case2会被吃</p>\n<h4 id=\"case4-五只老虎一只羊\"><a href=\"#case4-五只老虎一只羊\" class=\"headerlink\" title=\"case4: 五只老虎一只羊\"></a>case4: 五只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case3</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃</p>\n<p>引出课题 <code>Dynamic Programming</code></p>\n<h1 id=\"Dynamic-Programming\"><a href=\"#Dynamic-Programming\" class=\"headerlink\" title=\"Dynamic Programming\"></a>Dynamic Programming</h1><blockquote>\n<p>简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念</p>\n</blockquote>\n<ul>\n<li>最优子结构</li>\n<li>边界</li>\n<li>状态转移公式</li>\n</ul>\n<p>下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题</p>\n<p><em>Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..这个数列从第3项开始，每一项都等于前两项之和</em></p>\n<p>在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）因此可以直接写出以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n<span class=\"number\">-1</span>) + fn(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第1项<span class=\"subst\">$&#123;fn(<span class=\"number\">1</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第2项<span class=\"subst\">$&#123;fn(<span class=\"number\">2</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第3项<span class=\"subst\">$&#123;fn(<span class=\"number\">3</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第4项<span class=\"subst\">$&#123;fn(<span class=\"number\">4</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第5项<span class=\"subst\">$&#123;fn(<span class=\"number\">5</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第6项<span class=\"subst\">$&#123;fn(<span class=\"number\">6</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第7项<span class=\"subst\">$&#123;fn(<span class=\"number\">7</span>)&#125;</span>`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13</span></span><br></pre></td></tr></table></figure></p>\n<p>现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念</p>\n<ol>\n<li>最优子结构：若想求得第 <code>m</code> 项的值，那么只需要去求得第 <code>m-1</code> 和 <code>m-2</code> 的值即可，那么 <code>fn(m-1) + fn(m-2) === f(m)</code> 等式成立</li>\n<li>边界: 即范围</li>\n<li>状态转移公式：<code>f(m) = fn(m-1) + fn(m-2)</code></li>\n</ol>\n<p>上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？<br>具象化来看： 求得f(5) = ？</p>\n<ul>\n<li>f(5)依赖 f(4)和f(3)</li>\n<li>f(4)依赖 f(3)和f(2)</li>\n<li>f(3)依赖 f(2)和f(1)</li>\n</ul>\n<p>显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>, m_1 = <span class=\"number\">1</span>, result</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">    result = m + m_1</span><br><span class=\"line\">    m_1 = m</span><br><span class=\"line\">    m = result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果和上面是一致的但是性能就会有非常大的提升了</p>\n<h1 id=\"既然上面提到了递归我们就再来说说递归\"><a href=\"#既然上面提到了递归我们就再来说说递归\" class=\"headerlink\" title=\"既然上面提到了递归我们就再来说说递归\"></a>既然上面提到了递归我们就再来说说递归</h1><p><em>递归： 程序调用自身的编程技巧称为递归（recursion）</em></p>\n<p>那么上面 <code>return fn(n-1) + fn(n-2)</code> 就是一个最普通的递归</p>\n<p>这里再引入一个尾递归的概念：就是函数在尾部调用自身</p>\n<p>那下面来简单说说为什么上面递归的写法性能会那么差</p>\n<p>调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存</p>\n<p>将上面方法改用尾递归的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n, m_1 = <span class=\"number\">1</span>, m = <span class=\"number\">1</span></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> m</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n - <span class=\"number\">1</span>, m, m + m_1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍</p>\n<p>当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>draven：好好看 好好学</p>\n"},{"title":"十行代码实现Koa2洋葱模型","date":"2019-02-22T11:00:00.000Z","_content":"\n\n# 十行代码实现Koa2洋葱模型\n\n#### 先用一张图形象诠释洋葱模型\n![avatar](/onion.png)\n\nkoa2上独特的中间件流程控制，是一个典型的洋葱模型\n\n# 先展示一下koa2的运行demo\n```js\nconst Koa = require('koa2')\n\nconst app = new Koa()\n\napp.use(async (ctx, next)=>{\n    console.log(1, ' start')\n    await next()\n    console.log(1, ' end')\n})\n\napp.use(async (ctx, next) => {\n    console.log(2, ' start')\n    await next()\n    console.log(2, ' end')\n})\napp.use(async (ctx, next) => {\n    console.log(3, ' start')\n    await next()\n    console.log(3, ' end')\n})\n\napp.listen(3000)\n```\n输出结果：\n```bash\n1 start\n2 start\n3 start\n3 end\n2 end\n1 end\n```\n\n展现如上图洋葱式的输出结果\n\n# 归纳得出结论\n\n接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：\n- 首先变为最简case：只有两个中间件函数\n- 那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 `1 start -> 2 start -> 2 end -> 1 end` 的结果\n- 同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n和之前的一篇 [动态规划和递归：从虎羊草开始](http://localhost:4000/2019/02/21/do%20something/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E9%80%92%E5%BD%92%EF%BC%9A%E4%BB%8E%E8%99%8E%E7%BE%8A%E8%8D%89%E5%BC%80%E5%A7%8B/#%E4%BB%8E%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%83%85%E5%86%B5%E5%85%A5%E6%89%8B) 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码\n\n# 三步完成基本封装\n\n第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n```\n\n第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -> 2 -> 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：\n```js\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n```\n\n第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：\n```js\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n```\n\n以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试\n\n# 测试封装的代码\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n\nconst app = new App\n\napp.use(async function m1(next) {\n  console.log('m1')\n  await next()\n  console.log('m1 end')\n})\n\napp.use(async function m2(next) {\n  console.log('m2')\n  await next()\n  console.log('m2 end')\n})\n\napp.use(async function m3(next) {\n  console.log('m3')\n  await next()\n  console.log('m3 end')\n})\n\n\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n\ncompose(app.middleware)()\n\n// output:\n// m1\n// m2\n// m3\n// m3 end\n// m2 end\n// m1 end\n```\n\n达到预期结果ahhhhh💐\n\n# summary\n\n当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2","source":"_posts/do something/十行代码实现Koa2洋葱模型.md","raw":"---\ntitle: 十行代码实现Koa2洋葱模型\ntags:\n  - 封装\n  - koa\n  - 洋葱模型\ndate: 2019-02-22 19:00:00\ncategories: 封装\n---\n\n\n# 十行代码实现Koa2洋葱模型\n\n#### 先用一张图形象诠释洋葱模型\n![avatar](/onion.png)\n\nkoa2上独特的中间件流程控制，是一个典型的洋葱模型\n\n# 先展示一下koa2的运行demo\n```js\nconst Koa = require('koa2')\n\nconst app = new Koa()\n\napp.use(async (ctx, next)=>{\n    console.log(1, ' start')\n    await next()\n    console.log(1, ' end')\n})\n\napp.use(async (ctx, next) => {\n    console.log(2, ' start')\n    await next()\n    console.log(2, ' end')\n})\napp.use(async (ctx, next) => {\n    console.log(3, ' start')\n    await next()\n    console.log(3, ' end')\n})\n\napp.listen(3000)\n```\n输出结果：\n```bash\n1 start\n2 start\n3 start\n3 end\n2 end\n1 end\n```\n\n展现如上图洋葱式的输出结果\n\n# 归纳得出结论\n\n接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：\n- 首先变为最简case：只有两个中间件函数\n- 那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 `1 start -> 2 start -> 2 end -> 1 end` 的结果\n- 同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n和之前的一篇 [动态规划和递归：从虎羊草开始](http://localhost:4000/2019/02/21/do%20something/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E9%80%92%E5%BD%92%EF%BC%9A%E4%BB%8E%E8%99%8E%E7%BE%8A%E8%8D%89%E5%BC%80%E5%A7%8B/#%E4%BB%8E%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%83%85%E5%86%B5%E5%85%A5%E6%89%8B) 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码\n\n# 三步完成基本封装\n\n第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n```\n\n第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -> 2 -> 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：\n```js\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n```\n\n第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：\n```js\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n```\n\n以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试\n\n# 测试封装的代码\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n\nconst app = new App\n\napp.use(async function m1(next) {\n  console.log('m1')\n  await next()\n  console.log('m1 end')\n})\n\napp.use(async function m2(next) {\n  console.log('m2')\n  await next()\n  console.log('m2 end')\n})\n\napp.use(async function m3(next) {\n  console.log('m3')\n  await next()\n  console.log('m3 end')\n})\n\n\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n\ncompose(app.middleware)()\n\n// output:\n// m1\n// m2\n// m3\n// m3 end\n// m2 end\n// m1 end\n```\n\n达到预期结果ahhhhh💐\n\n# summary\n\n当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2","slug":"do something/十行代码实现Koa2洋葱模型","published":1,"updated":"2019-02-22T12:21:12.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsg0yvmt00076a486cvsf1fo","content":"<h1 id=\"十行代码实现Koa2洋葱模型\"><a href=\"#十行代码实现Koa2洋葱模型\" class=\"headerlink\" title=\"十行代码实现Koa2洋葱模型\"></a>十行代码实现Koa2洋葱模型</h1><h4 id=\"先用一张图形象诠释洋葱模型\"><a href=\"#先用一张图形象诠释洋葱模型\" class=\"headerlink\" title=\"先用一张图形象诠释洋葱模型\"></a>先用一张图形象诠释洋葱模型</h4><p><img src=\"/2019/02/22/do something/十行代码实现Koa2洋葱模型/onion.png\" alt=\"avatar\"></p>\n<p>koa2上独特的中间件流程控制，是一个典型的洋葱模型</p>\n<h1 id=\"先展示一下koa2的运行demo\"><a href=\"#先展示一下koa2的运行demo\" class=\"headerlink\" title=\"先展示一下koa2的运行demo\"></a>先展示一下koa2的运行demo</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 start</span><br><span class=\"line\">2 start</span><br><span class=\"line\">3 start</span><br><span class=\"line\">3 end</span><br><span class=\"line\">2 end</span><br><span class=\"line\">1 end</span><br></pre></td></tr></table></figure></p>\n<p>展现如上图洋葱式的输出结果</p>\n<h1 id=\"归纳得出结论\"><a href=\"#归纳得出结论\" class=\"headerlink\" title=\"归纳得出结论\"></a>归纳得出结论</h1><p>接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：</p>\n<ul>\n<li>首先变为最简case：只有两个中间件函数</li>\n<li>那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 <code>1 start -&gt; 2 start -&gt; 2 end -&gt; 1 end</code> 的结果</li>\n<li>同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调</li>\n</ul>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.<br>和之前的一篇 <a href=\"http://localhost:4000/2019/02/21/do%20something/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E9%80%92%E5%BD%92%EF%BC%9A%E4%BB%8E%E8%99%8E%E7%BE%8A%E8%8D%89%E5%BC%80%E5%A7%8B/#%E4%BB%8E%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%83%85%E5%86%B5%E5%85%A5%E6%89%8B\" target=\"_blank\" rel=\"noopener\">动态规划和递归：从虎羊草开始</a> 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码</p>\n<h1 id=\"三步完成基本封装\"><a href=\"#三步完成基本封装\" class=\"headerlink\" title=\"三步完成基本封装\"></a>三步完成基本封装</h1><p>第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -&gt; 2 -&gt; 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></p>\n<p>第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试</p>\n<h1 id=\"测试封装的代码\"><a href=\"#测试封装的代码\" class=\"headerlink\" title=\"测试封装的代码\"></a>测试封装的代码</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> App</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m3</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br><span class=\"line\"></span><br><span class=\"line\">compose(app.middleware)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// m1</span></span><br><span class=\"line\"><span class=\"comment\">// m2</span></span><br><span class=\"line\"><span class=\"comment\">// m3</span></span><br><span class=\"line\"><span class=\"comment\">// m3 end</span></span><br><span class=\"line\"><span class=\"comment\">// m2 end</span></span><br><span class=\"line\"><span class=\"comment\">// m1 end</span></span><br></pre></td></tr></table></figure>\n<p>达到预期结果ahhhhh💐</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"十行代码实现Koa2洋葱模型\"><a href=\"#十行代码实现Koa2洋葱模型\" class=\"headerlink\" title=\"十行代码实现Koa2洋葱模型\"></a>十行代码实现Koa2洋葱模型</h1><h4 id=\"先用一张图形象诠释洋葱模型\"><a href=\"#先用一张图形象诠释洋葱模型\" class=\"headerlink\" title=\"先用一张图形象诠释洋葱模型\"></a>先用一张图形象诠释洋葱模型</h4><p><img src=\"/2019/02/22/do something/十行代码实现Koa2洋葱模型/onion.png\" alt=\"avatar\"></p>\n<p>koa2上独特的中间件流程控制，是一个典型的洋葱模型</p>\n<h1 id=\"先展示一下koa2的运行demo\"><a href=\"#先展示一下koa2的运行demo\" class=\"headerlink\" title=\"先展示一下koa2的运行demo\"></a>先展示一下koa2的运行demo</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 start</span><br><span class=\"line\">2 start</span><br><span class=\"line\">3 start</span><br><span class=\"line\">3 end</span><br><span class=\"line\">2 end</span><br><span class=\"line\">1 end</span><br></pre></td></tr></table></figure></p>\n<p>展现如上图洋葱式的输出结果</p>\n<h1 id=\"归纳得出结论\"><a href=\"#归纳得出结论\" class=\"headerlink\" title=\"归纳得出结论\"></a>归纳得出结论</h1><p>接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：</p>\n<ul>\n<li>首先变为最简case：只有两个中间件函数</li>\n<li>那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 <code>1 start -&gt; 2 start -&gt; 2 end -&gt; 1 end</code> 的结果</li>\n<li>同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调</li>\n</ul>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.<br>和之前的一篇 <a href=\"http://localhost:4000/2019/02/21/do%20something/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E9%80%92%E5%BD%92%EF%BC%9A%E4%BB%8E%E8%99%8E%E7%BE%8A%E8%8D%89%E5%BC%80%E5%A7%8B/#%E4%BB%8E%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%83%85%E5%86%B5%E5%85%A5%E6%89%8B\" target=\"_blank\" rel=\"noopener\">动态规划和递归：从虎羊草开始</a> 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码</p>\n<h1 id=\"三步完成基本封装\"><a href=\"#三步完成基本封装\" class=\"headerlink\" title=\"三步完成基本封装\"></a>三步完成基本封装</h1><p>第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -&gt; 2 -&gt; 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></p>\n<p>第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试</p>\n<h1 id=\"测试封装的代码\"><a href=\"#测试封装的代码\" class=\"headerlink\" title=\"测试封装的代码\"></a>测试封装的代码</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> App</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m3</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br><span class=\"line\"></span><br><span class=\"line\">compose(app.middleware)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// m1</span></span><br><span class=\"line\"><span class=\"comment\">// m2</span></span><br><span class=\"line\"><span class=\"comment\">// m3</span></span><br><span class=\"line\"><span class=\"comment\">// m3 end</span></span><br><span class=\"line\"><span class=\"comment\">// m2 end</span></span><br><span class=\"line\"><span class=\"comment\">// m1 end</span></span><br></pre></td></tr></table></figure>\n<p>达到预期结果ahhhhh💐</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2</p>\n"}],"PostAsset":[{"_id":"source/_posts/do something/十行代码实现Koa2洋葱模型/onion.png","slug":"onion.png","post":"cjsg0yvmt00076a486cvsf1fo","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjsg0yvmn00036a48v96qg46t","category_id":"cjsg0yvmr00056a488lu0drk0","_id":"cjsg0yvmv000a6a48nx900fsr"},{"post_id":"cjsg0yvmp00046a484rzholdw","category_id":"cjsg0yvmu00086a485wsdfp6i","_id":"cjsg0yvmw000d6a48m4qwrc9s"},{"post_id":"cjsg0yvmt00076a486cvsf1fo","category_id":"cjsg0yvmr00056a488lu0drk0","_id":"cjsg0yvmx000f6a480ogok7mi"}],"PostTag":[{"post_id":"cjsg0yvmn00036a48v96qg46t","tag_id":"cjsg0yvmt00066a48biupuz8q","_id":"cjsg0yvmx000h6a4808y0s4ss"},{"post_id":"cjsg0yvmn00036a48v96qg46t","tag_id":"cjsg0yvmu00096a482m2032di","_id":"cjsg0yvmx000i6a48wmedp8jk"},{"post_id":"cjsg0yvmn00036a48v96qg46t","tag_id":"cjsg0yvmv000c6a48uvymoaaw","_id":"cjsg0yvmy000k6a484uiyabi6"},{"post_id":"cjsg0yvmn00036a48v96qg46t","tag_id":"cjsg0yvmw000e6a48a9fu3aav","_id":"cjsg0yvmy000l6a48s196yefh"},{"post_id":"cjsg0yvmp00046a484rzholdw","tag_id":"cjsg0yvmx000g6a48436k2diw","_id":"cjsg0yvmz000p6a48vi2v80e1"},{"post_id":"cjsg0yvmp00046a484rzholdw","tag_id":"cjsg0yvmx000j6a48nhez23jq","_id":"cjsg0yvmz000q6a48bttrs86j"},{"post_id":"cjsg0yvmp00046a484rzholdw","tag_id":"cjsg0yvmy000m6a4839cps1ko","_id":"cjsg0yvmz000s6a48q2g4epja"},{"post_id":"cjsg0yvmp00046a484rzholdw","tag_id":"cjsg0yvmy000n6a48wtnxye9r","_id":"cjsg0yvmz000t6a48l0w6bdy2"},{"post_id":"cjsg0yvmt00076a486cvsf1fo","tag_id":"cjsg0yvmt00066a48biupuz8q","_id":"cjsg0yvmz000v6a48roldr7c6"},{"post_id":"cjsg0yvmt00076a486cvsf1fo","tag_id":"cjsg0yvmz000r6a48fdo53g2l","_id":"cjsg0yvn0000w6a48onump1rq"},{"post_id":"cjsg0yvmt00076a486cvsf1fo","tag_id":"cjsg0yvmz000u6a485h7jjdsl","_id":"cjsg0yvn0000x6a480n8ddpq9"}],"Tag":[{"name":"封装","_id":"cjsg0yvmt00066a48biupuz8q"},{"name":"微信小程序","_id":"cjsg0yvmu00096a482m2032di"},{"name":"mpvue","_id":"cjsg0yvmv000c6a48uvymoaaw"},{"name":"路由","_id":"cjsg0yvmw000e6a48a9fu3aav"},{"name":"算法","_id":"cjsg0yvmx000g6a48436k2diw"},{"name":"动态规划","_id":"cjsg0yvmx000j6a48nhez23jq"},{"name":"递归","_id":"cjsg0yvmy000m6a4839cps1ko"},{"name":"尾递归","_id":"cjsg0yvmy000n6a48wtnxye9r"},{"name":"koa","_id":"cjsg0yvmz000r6a48fdo53g2l"},{"name":"洋葱模型","_id":"cjsg0yvmz000u6a485h7jjdsl"}]}}