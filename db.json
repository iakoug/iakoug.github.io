{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/archer/source/CNAME","path":"CNAME","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/logo-36.png","path":"assets/logo-36.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/logo-48.png","path":"assets/logo-48.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/logo-64.png","path":"assets/logo-64.png","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/images/bg_post.png","path":"images/bg_post.png","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/images/avatar1.png","path":"images/avatar1.png","modified":0,"renderable":1},{"_id":"themes/archer/source/images/wechat.png","path":"images/wechat.png","modified":0,"renderable":1},{"_id":"themes/archer/source/images/bg_site.jpg","path":"images/bg_site.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550808959469},{"_id":"themes/archer/.DS_Store","hash":"4e15ba49a799d94b130c2b5413f1289de3d41ca6","modified":1550812864070},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1549801924000},{"_id":"source/manifest.json","hash":"77bf0e97fabb77a4b3157589567da236006500c2","modified":1550744372310},{"_id":"themes/archer/_config.yml","hash":"7069fe6e9c1febfa491f4b86e05e293a1a4c6226","modified":1552209335216},{"_id":"source/.DS_Store","hash":"7a8f97280a3f1166befbf8e8d2d3f50d4a962af4","modified":1551000245177},{"_id":"source/404.md","hash":"577791aa24ecec4b33d17acca505d4e0849bfc02","modified":1549801924000},{"_id":"themes/archer/README.md","hash":"fa398e05b0318ae4a657256e6ec6738791358d4f","modified":1549801924000},{"_id":"themes/archer/gulpfile.js","hash":"88e2615c21ca95ae7bcdba499e50a54aebcd9f56","modified":1549801924000},{"_id":"themes/archer/package.json","hash":"80a1d936e347e61d9a41a4303ee32dc236017242","modified":1549801924000},{"_id":"themes/archer/webpack.config.js","hash":"d20b6350c50e2981484cb9356a3e21a2124bcd72","modified":1549801924000},{"_id":"themes/archer/webpack.prod.js","hash":"48de76cfa6274895801d3afc89ecbf04ee182a1c","modified":1549801924000},{"_id":"themes/archer/source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550809083470},{"_id":"source/_posts/.DS_Store","hash":"f16bc7e20c140961937b569d1d3375ac5bdb307d","modified":1550835606375},{"_id":"source/about/index.md","hash":"fb3569b1e15f42215a1a6c95a020ed1ac07ae250","modified":1550821550127},{"_id":"themes/archer/docs/README-en.md","hash":"ebd8845724cc9c524f1bdc617567bec2223abed6","modified":1549801924000},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"0bb09c3c9d5f56820cb84e3316f60352b731d70c","modified":1549801924000},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"effc2bc9e0cecfd228b19283337ff29649ea5985","modified":1549801924000},{"_id":"themes/archer/layout/404.ejs","hash":"879641b1b5e49c43f2e096cad281f7d74df05127","modified":1549801924000},{"_id":"themes/archer/layout/about.ejs","hash":"06019d835c0a51fed8aa086d1dfcf368f9921b42","modified":1549801924000},{"_id":"themes/archer/layout/index.ejs","hash":"716ba4a30860e36077dfdfffa02c1cd60301d8a3","modified":1549801924000},{"_id":"themes/archer/layout/site-meta.ejs","hash":"1a200814c7ef027582ab9e4972726ef4a3347aed","modified":1549801924000},{"_id":"themes/archer/layout/layout.ejs","hash":"765924b2ac7668542a41a2504cd8ee644cb67e3a","modified":1552206494097},{"_id":"themes/archer/layout/post.ejs","hash":"bf95400cec8f533c11115490a54546a74a718984","modified":1551940260207},{"_id":"themes/archer/source/.DS_Store","hash":"116f15e722432867e3266273721ca892b740c5d6","modified":1550832447671},{"_id":"source/_posts/humanbeings/IsThisInternetWinter.md","hash":"61ae6bf5572b456443ceb4bb1bdefb7d92f8a75a","modified":1551666404941},{"_id":"source/_posts/humanbeings/人生天地间 忽如远行客.md","hash":"72fdfc906560317cc390118974d773b4faae78d6","modified":1550976773596},{"_id":"source/_posts/writeSomething/.DS_Store","hash":"e6f93de9acddf64dd562a95b71bc5100758206d4","modified":1550835611378},{"_id":"source/_posts/writeSomething/dynamicProgrammingAndRecursion.md","hash":"ee33ac75835fe89d0c10b9a97de9adb7fa6ed189","modified":1550976773593},{"_id":"source/_posts/writeSomething/AlgorithmComplexity.md","hash":"12565d00bd8c36ed6ed718385382774f1003c507","modified":1551866807159},{"_id":"source/_posts/writeSomething/appletRouter.md","hash":"260db1e6f1a35c05c16bfb09ce221322d7286189","modified":1551926980609},{"_id":"source/_posts/writeSomething/EventLoop.md","hash":"ab8e1ad979154b5747e52bf5611068a7e64ee7e0","modified":1551948950419},{"_id":"source/_posts/writeSomething/koa2OnionModel.md","hash":"b6e0d2c4bcf9dc15be2e885be361493f22ae5374","modified":1550976773594},{"_id":"source/_posts/writeSomething/jsDesignPattern.md","hash":"9b274890402a387bdad10b3bec520824b97bbf0a","modified":1551774516180},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"f5a054ed072971223ca9d5737cfea05644074a7c","modified":1552207412000},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"457d2c8efcbdd08eccc5ea14c7e89f151a5a4088","modified":1550824601490},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"12e28693dc53cab5f6fd389f15ea0f811c9c37e9","modified":1549801924000},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"2f5f9073378f628a9124792b5301c1540bc5a264","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"efde86772642dff2bb777556775b516f0cdc6e99","modified":1550823882959},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"2aea84cb43f4479131620b3c3dfd7cebe9be36ba","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"d2a8ae42792ffd391f591dbcda3bdbc6fddebe02","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"2d068432031b3bebf9438c775370a2d1b4492d6b","modified":1549801924000},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"418559ab11726f69621c3a58cd21903adff1e48e","modified":1549801924000},{"_id":"themes/archer/layout/_partial/google-adsense.ejs","hash":"8d86c7decc6f39bc6eef13feafe4a1a820f7374b","modified":1549801924000},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"cd0d34a811dc4666980d57c00d70dd82bd5450eb","modified":1549801924000},{"_id":"themes/archer/src/js/browser.js","hash":"03017b1e89b59346e681464c7609593c9aafa54c","modified":1549801924000},{"_id":"themes/archer/src/js/fancybox.js","hash":"0ce36efa325767c0ee7d5e5dfa174c68dd606e72","modified":1549801924000},{"_id":"themes/archer/src/js/init.js","hash":"989dea03ce93962b6a52818ee770ca3891679322","modified":1549801924000},{"_id":"themes/archer/src/js/main.js","hash":"58329fe74df0d4411d9486ebfc4c5fbc457f073f","modified":1549801924000},{"_id":"themes/archer/src/js/initSidebar.js","hash":"522aba19524b49efd323a2199f6eaa7396f1bd48","modified":1551678880702},{"_id":"themes/archer/src/js/mobile.js","hash":"3c826a4385dc58ee878e5ea9bf3a25fac5d2b307","modified":1549801924000},{"_id":"themes/archer/src/js/search.js","hash":"af9bdbff06987fdca8340ea49ccd91e993b9be53","modified":1549801924000},{"_id":"themes/archer/src/js/share.js","hash":"dff48b27ac212c4ea8e0c4c5ee323862c06c2882","modified":1549801924000},{"_id":"themes/archer/src/js/scroll.js","hash":"11ae5ca33f6f84897ef4a01697a624770bea2025","modified":1549801924000},{"_id":"themes/archer/src/js/util.js","hash":"1c244b8def678df797ab3c049a03998db4f9dabb","modified":1549801924000},{"_id":"themes/archer/src/js/tag.js","hash":"156547cad5230c899cac12d3d29e60f5a103b7c4","modified":1549801924000},{"_id":"themes/archer/src/js/sidebar.js","hash":"ee761637d37b9b1c7934984438b38d39aeca53eb","modified":1551679019908},{"_id":"themes/archer/src/js/toc.js","hash":"2a01f07f302ccea3d36787571e34fd070ac42797","modified":1549801924000},{"_id":"themes/archer/src/scss/_common.scss","hash":"71aa8bf9d5c66a432fd32b96a0953d53fcb533d2","modified":1549801924000},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"27d5380e6a190071c0877a3651f3d877b91e03a1","modified":1549801924000},{"_id":"themes/archer/src/scss/style.scss","hash":"2d959b9c6a3a5b70df1bfa4ba0a6b8b758454e74","modified":1549801924000},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"b33d0d7e2e2807f50735f43e742f3c33471d38f7","modified":1549801924000},{"_id":"themes/archer/src/scss/_variables.scss","hash":"edd9e3dd34837f9c4e5f45eee8dc051b4caa8d28","modified":1549801924000},{"_id":"themes/archer/src/scss/mobile.scss","hash":"76a65f93c8bbcd5bc5fb7fca55919a12e7543a2b","modified":1549801924000},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1549801924000},{"_id":"themes/archer/source/assets/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550809961832},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1549801924000},{"_id":"themes/archer/source/assets/favicon.ico","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/css/mobile.css","hash":"0b7ac34da7d703064423480fc0526d91fa5716bc","modified":1549801924000},{"_id":"themes/archer/source/css/style.css","hash":"9b9e9ab4195f4f22bd52895ebedfa51b2182cab0","modified":1549801924000},{"_id":"themes/archer/source/assets/logo-36.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/assets/logo-48.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/assets/logo-64.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1541991527057},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1549801924000},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1549801924000},{"_id":"themes/archer/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550832464601},{"_id":"themes/archer/source/images/favicon.ico","hash":"6484806109ed1950f6700639a86b96c6681d6f9e","modified":1547608978327},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1549801924000},{"_id":"themes/archer/source/scripts/main.js","hash":"258b08f308c2a78f6cc0a81cf353994da771966a","modified":1549801924000},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1549801924000},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549801924000},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1549801924000},{"_id":"themes/archer/source/images/bg_post.png","hash":"dacb8dbf91978317e1fc0925137167f3f76285e2","modified":1507789973000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1549801924000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1549801924000},{"_id":"source/_posts/writeSomething/koa2OnionModel/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550838469096},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1549801924000},{"_id":"themes/archer/package-lock.json","hash":"229960bd92beff7974f422f7cb2025ae610a2191","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"b27469f19f35ec2037c7bce736a12e9dfb5e360b","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"7691642fb9375607e0ac988a7420999e242cb2c9","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"794647a8a4ac9e1d01d74c07717175a141b1e01c","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"790d76f2667377db78a7d04bad8d629e47e7aab0","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"6bf59f01235c87cbca1555e4e027139de06688c2","modified":1550824322941},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"731d3980ac665d96dc6a40d31c2f8b86a221a8bb","modified":1549801924000},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cadd97820a23d01d8b7e2f19a86e5290cef5a8a6","modified":1550824477536},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"291cc0a4a444a93b93c32e2c39383c70e36e46de","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"2d38af7cb5aabc0af99de239bd180c516ec4c56c","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"daa78b17a773bca569f1c8ca2c916495ca138da6","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"147214469c4909eb94943599883f9fa0f3cc090d","modified":1549801924000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"d6e1a192cac5dcf365ce1a52df4f23feafeeb849","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"64a721c19c8c4d5b2b07d6aedcde1565be734e6d","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"75776d8b85c8d2edc27eb7ed60d7c371f5109da0","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"8a74f79686e327b0566ea606fd7625eb57daf898","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"97171c34f9b0676cf9113a1d637955415770f89b","modified":1549801924000},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"65efbfbaec7d09120ba62fee6e4643e6108098f6","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"eaff5b3e942e461109cdb6fd52f1d124b5a11951","modified":1551678648607},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"dbd7f802f3812f7e15c12885e495296f3697c580","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"73caccbe2634ff84e386d58e7f6ecd52d5ca2151","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"9f7a3877adccbfaf66ad574dbe2c8dc85fbf2f5a","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"e69b62df7c36d938cc4cf8e1fdcbc7109be41119","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"1229364f7c3484cc2ada6f118c859e3fd1dd9129","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a25960d1d9f501e50cb1fe86328dbc65faa29d22","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"9226a04dd9ea8389f88ced34962f1f55192d7a1a","modified":1549801924000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"fe42459805e4caa303df08964184548c33507d23","modified":1549801924000},{"_id":"themes/archer/source/images/avatar1.png","hash":"dbcbcd062a1113d7c656cad3c8d7642031a0146f","modified":1551671415557},{"_id":"source/_posts/writeSomething/koa2OnionModel/onion.png","hash":"64ed5f85efbca9cda0ecb5737edf3430f044f733","modified":1550835653175},{"_id":"themes/archer/source/images/wechat.png","hash":"1bb6520ad81686d563b56db149c38a54f33ed0b8","modified":1550820441456},{"_id":"themes/archer/source/images/bg_site.jpg","hash":"958660a9659be7b1c58eb60c8abf6d4ff0dfc88c","modified":1546938271109},{"_id":"public/manifest.json","hash":"a23c85880d1c222879e8646ecdc177eaf7cecdaa","modified":1552209410553},{"_id":"public/atom.xml","hash":"ae8ab7b91943e29a045edfc3535fb39f1f3e15f4","modified":1552209410753},{"_id":"public/content.json","hash":"d5ccd36b0b6793c0a3ea9a0fcd8e515179a64d14","modified":1552209410762},{"_id":"public/post-sitemap.xml","hash":"51d640b45941d2b3abca63ef29fd010e2a552ae5","modified":1552209410762},{"_id":"public/page-sitemap.xml","hash":"7fd5759b48e2fb866ce562104b9a79d533710456","modified":1552209410762},{"_id":"public/category-sitemap.xml","hash":"7652350bdfebac44911fe69c68782f9842ef461b","modified":1552209410762},{"_id":"public/tag-sitemap.xml","hash":"4079b8e85ba93a8a37cf7a5869043b244ec642a6","modified":1552209410762},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1552209410762},{"_id":"public/sitemap.xml","hash":"cce6288f4043d10950e1c4f12ff250abdbb10fa9","modified":1552209410762},{"_id":"public/404.html","hash":"28cfab5017a14d990d2f40c62677b7b76b19d404","modified":1552209410797},{"_id":"public/about/index.html","hash":"a4297e66e9c5cbcc89b01488838f1b508dca43aa","modified":1552209410798},{"_id":"public/2019/03/07/writeSomething/EventLoop/index.html","hash":"ff77d5958f19f573afdea3caee9ef83ec17a5f95","modified":1552209410798},{"_id":"public/2019/03/06/writeSomething/AlgorithmComplexity/index.html","hash":"035d64a20fb9b7c745c28686c71c1f0405807047","modified":1552209410798},{"_id":"public/2019/02/28/humanbeings/IsThisInternetWinter/index.html","hash":"6ce911aa7908b63289642b9c0080662166bf78ab","modified":1552209410798},{"_id":"public/2019/02/24/writeSomething/jsDesignPattern/index.html","hash":"d2612b300b971e7a5bfc4404e2fdd8640f0e652c","modified":1552209410798},{"_id":"public/2019/02/22/writeSomething/koa2OnionModel/index.html","hash":"ed6b39062c5a0fcb862d2d1ebfbbb86a13b75fac","modified":1552209410798},{"_id":"public/2019/02/21/writeSomething/dynamicProgrammingAndRecursion/index.html","hash":"2a8354b5ea8ae87bbbd1a77d68ca08952208b916","modified":1552209410798},{"_id":"public/2019/01/04/humanbeings/人生天地间 忽如远行客/index.html","hash":"885a790a79c6e7524ccef75277fd9c309ad15441","modified":1552209410798},{"_id":"public/2018/12/09/writeSomething/appletRouter/index.html","hash":"3a0dc8d9a681a3b4c318f5c6db57f302b60163a7","modified":1552209410798},{"_id":"public/archives/index.html","hash":"dc7034027cdcdb20ff2f7b31161bd93c4a2a10cd","modified":1552209410798},{"_id":"public/archives/2018/index.html","hash":"172a416efc4b967a529b79fcad9d8ec18dadc5a7","modified":1552209410798},{"_id":"public/archives/2018/12/index.html","hash":"172a416efc4b967a529b79fcad9d8ec18dadc5a7","modified":1552209410798},{"_id":"public/archives/2019/index.html","hash":"b073f593ee09a0be4fba182483ea170ee24928ac","modified":1552209410799},{"_id":"public/archives/2019/01/index.html","hash":"0fb679c9a94456934d6f115863a3b7e2fbf30b4d","modified":1552209410799},{"_id":"public/archives/2019/02/index.html","hash":"8bd9c2bd67308fc2a37310e972d5bc9456857366","modified":1552209410799},{"_id":"public/archives/2019/03/index.html","hash":"0f5612e24483938f95591a0c210f672a4af47da8","modified":1552209410799},{"_id":"public/categories/当我在扯淡/index.html","hash":"28c97be7fe7a476306bce14a177e6b30ce0f0370","modified":1552209410799},{"_id":"public/categories/算法/index.html","hash":"3871129f88cd80eb7ed2a58b1cbe69501c294d6a","modified":1552209410799},{"_id":"public/categories/封装/index.html","hash":"adada831f90d64552a37613d56708654cd5bf70f","modified":1552209410799},{"_id":"public/categories/你应该知道的/index.html","hash":"6cc2436b6cc3ecd01d79d738092c48de01568bd2","modified":1552209410799},{"_id":"public/index.html","hash":"1da61aec3f60982b2e24496bbbd4836b3a1d21da","modified":1552209410799},{"_id":"public/tags/当我在扯淡/index.html","hash":"28c97be7fe7a476306bce14a177e6b30ce0f0370","modified":1552209410799},{"_id":"public/tags/算法/index.html","hash":"3871129f88cd80eb7ed2a58b1cbe69501c294d6a","modified":1552209410799},{"_id":"public/tags/算法复杂度/index.html","hash":"0da9a6a71b43ea0b68a5aa7eda54e058a33c11f7","modified":1552209410800},{"_id":"public/tags/动态规划/index.html","hash":"4e2736d6045b65d8de86606071fa2b84622b4895","modified":1552209410800},{"_id":"public/tags/递归/index.html","hash":"4e2736d6045b65d8de86606071fa2b84622b4895","modified":1552209410800},{"_id":"public/tags/尾递归/index.html","hash":"4e2736d6045b65d8de86606071fa2b84622b4895","modified":1552209410800},{"_id":"public/tags/封装/index.html","hash":"adada831f90d64552a37613d56708654cd5bf70f","modified":1552209410800},{"_id":"public/tags/微信小程序/index.html","hash":"172a416efc4b967a529b79fcad9d8ec18dadc5a7","modified":1552209410800},{"_id":"public/tags/mpvue/index.html","hash":"172a416efc4b967a529b79fcad9d8ec18dadc5a7","modified":1552209410800},{"_id":"public/tags/路由/index.html","hash":"172a416efc4b967a529b79fcad9d8ec18dadc5a7","modified":1552209410800},{"_id":"public/tags/事件循环/index.html","hash":"6cc2436b6cc3ecd01d79d738092c48de01568bd2","modified":1552209410800},{"_id":"public/tags/任务队列/index.html","hash":"6cc2436b6cc3ecd01d79d738092c48de01568bd2","modified":1552209410800},{"_id":"public/tags/koa/index.html","hash":"ed7460c560839638be5fc321b65e2d2fe8fc8f01","modified":1552209410800},{"_id":"public/tags/洋葱模型/index.html","hash":"ed7460c560839638be5fc321b65e2d2fe8fc8f01","modified":1552209410800},{"_id":"public/tags/设计模式/index.html","hash":"b91a009dcbc39f61467c71edddfc106d0684cedd","modified":1552209410801},{"_id":"public/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552209410801},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1552209410806},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1552209410806},{"_id":"public/assets/favicon.ico","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1552209410806},{"_id":"public/assets/logo-36.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1552209410806},{"_id":"public/assets/logo-48.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1552209410806},{"_id":"public/assets/logo-64.png","hash":"169c71d072fa90b44ff91ca33ffbfda72342c054","modified":1552209410806},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1552209410806},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1552209410806},{"_id":"public/images/favicon.ico","hash":"6484806109ed1950f6700639a86b96c6681d6f9e","modified":1552209410806},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"1bcf74674566a61fe954e374a231011239b8e5e9","modified":1552209410806},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1552209410810},{"_id":"public/images/bg_post.png","hash":"dacb8dbf91978317e1fc0925137167f3f76285e2","modified":1552209410811},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1552209410812},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1552209410812},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"55eaeaf5ecda250f5bed80958a05bef13886eee6","modified":1552209410812},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"422f4c3882cf8366927333081292a9bed6000124","modified":1552209410812},{"_id":"public/css/mobile.css","hash":"0b7ac34da7d703064423480fc0526d91fa5716bc","modified":1552209410816},{"_id":"public/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1552209410816},{"_id":"public/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1552209410816},{"_id":"public/css/style.css","hash":"9b9e9ab4195f4f22bd52895ebedfa51b2182cab0","modified":1552209410817},{"_id":"public/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1552209410817},{"_id":"public/scripts/main.js","hash":"258b08f308c2a78f6cc0a81cf353994da771966a","modified":1552209410817},{"_id":"public/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1552209410817},{"_id":"public/2019/02/22/writeSomething/koa2OnionModel/onion.png","hash":"64ed5f85efbca9cda0ecb5737edf3430f044f733","modified":1552209410821},{"_id":"public/assets/algolia/algoliasearch.js","hash":"f34e955c2112cc6a80b48e48dd240a10817069f9","modified":1552209410822},{"_id":"public/images/avatar1.png","hash":"dbcbcd062a1113d7c656cad3c8d7642031a0146f","modified":1552209410824},{"_id":"public/images/wechat.png","hash":"1bb6520ad81686d563b56db149c38a54f33ed0b8","modified":1552209410842},{"_id":"public/images/bg_site.jpg","hash":"958660a9659be7b1c58eb60c8abf6d4ff0dfc88c","modified":1552209410854}],"Category":[{"name":"当我在扯淡","_id":"cjt2pem160005f7481jpjq83o"},{"name":"算法","_id":"cjt2pem1g000ff748wyylqpi0"},{"name":"封装","_id":"cjt2pem1j000of748a03hpo9w"},{"name":"你应该知道的","_id":"cjt2pem1k000uf748pp8bhzn5"}],"Data":[],"Page":[{"_content":"{\n    \"dir\": \"auto\",\n    \"lang\": \"zh\",\n    \"name\": \"kwok io\",\n    \"scope\": \"/\",\n    \"display\": \"standalone\",\n    \"start_url\": \"/\",\n    \"short_name\": \"kwok io\",\n    \"theme_color\": \"transparent\",\n    \"description\": \"- kwok io\",\n    \"orientation\": \"any\",\n    \"background_color\": \"transparent\",\n    \"related_applications\": [],\n    \"prefer_related_applications\": false,\n    \"gcm_sender_id\": \"482941778795\",\n    \"gcm_sender_id_comment\": \"Do not change the GCM Sender ID\",\n    \"icons\": [{\n      \"src\": \"/assets/logo-32.png\",\n      \"sizes\": \"32x32\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"/assets/logo-48.png\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/png\"\n    },\n    {\n        \"src\": \"/assets/logo-64.png\",\n        \"sizes\": \"64x64\",\n        \"type\": \"image/png\"\n      }\n    ]\n  }","source":"manifest.json","raw":"{\n    \"dir\": \"auto\",\n    \"lang\": \"zh\",\n    \"name\": \"kwok io\",\n    \"scope\": \"/\",\n    \"display\": \"standalone\",\n    \"start_url\": \"/\",\n    \"short_name\": \"kwok io\",\n    \"theme_color\": \"transparent\",\n    \"description\": \"- kwok io\",\n    \"orientation\": \"any\",\n    \"background_color\": \"transparent\",\n    \"related_applications\": [],\n    \"prefer_related_applications\": false,\n    \"gcm_sender_id\": \"482941778795\",\n    \"gcm_sender_id_comment\": \"Do not change the GCM Sender ID\",\n    \"icons\": [{\n      \"src\": \"/assets/logo-32.png\",\n      \"sizes\": \"32x32\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"/assets/logo-48.png\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/png\"\n    },\n    {\n        \"src\": \"/assets/logo-64.png\",\n        \"sizes\": \"64x64\",\n        \"type\": \"image/png\"\n      }\n    ]\n  }","date":"2019-02-21T10:19:32.310Z","updated":"2019-02-21T10:19:32.310Z","path":"manifest.json","layout":"false","title":"","comments":1,"_id":"cjt2pem050000f7484dn4neky","content":"{\"dir\":\"auto\",\"lang\":\"zh\",\"name\":\"kwok io\",\"scope\":\"/\",\"display\":\"standalone\",\"start_url\":\"/\",\"short_name\":\"kwok io\",\"theme_color\":\"transparent\",\"description\":\"- kwok io\",\"orientation\":\"any\",\"background_color\":\"transparent\",\"related_applications\":[],\"prefer_related_applications\":false,\"gcm_sender_id\":\"482941778795\",\"gcm_sender_id_comment\":\"Do not change the GCM Sender ID\",\"icons\":[{\"src\":\"/assets/logo-32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-64.png\",\"sizes\":\"64x64\",\"type\":\"image/png\"}]}","site":{"data":{}},"excerpt":"","more":"{\"dir\":\"auto\",\"lang\":\"zh\",\"name\":\"kwok io\",\"scope\":\"/\",\"display\":\"standalone\",\"start_url\":\"/\",\"short_name\":\"kwok io\",\"theme_color\":\"transparent\",\"description\":\"- kwok io\",\"orientation\":\"any\",\"background_color\":\"transparent\",\"related_applications\":[],\"prefer_related_applications\":false,\"gcm_sender_id\":\"482941778795\",\"gcm_sender_id_comment\":\"Do not change the GCM Sender ID\",\"icons\":[{\"src\":\"/assets/logo-32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/assets/logo-64.png\",\"sizes\":\"64x64\",\"type\":\"image/png\"}]}"},{"layout":"404","title":"[404]","description":"May the Force be with you :&#41;","_content":"","source":"404.md","raw":"---\nlayout: 404\ntitle: \"[404]\"\ndescription: \"May the Force be with you :&#41;\"\n---","date":"2019-02-21T09:46:42.749Z","updated":"2019-02-10T12:32:04.000Z","path":"404.html","comments":1,"_id":"cjt2pem060001f7485o9ve8ui","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"chris kwok","layout":"about","_content":"hi\n\nhere is chris kwok\n\nas a front-end coder\n\nin shanghai\n\n","source":"about/index.md","raw":"---\ntitle: chris kwok\nlayout: about\n---\nhi\n\nhere is chris kwok\n\nas a front-end coder\n\nin shanghai\n\n","date":"2019-02-22T07:45:50.127Z","updated":"2019-02-22T07:45:50.127Z","path":"about/index.html","comments":1,"_id":"cjt2pem0j0002f748bas000cu","content":"<p>hi</p>\n<p>here is chris kwok</p>\n<p>as a front-end coder</p>\n<p>in shanghai</p>\n","site":{"data":{}},"excerpt":"","more":"<p>hi</p>\n<p>here is chris kwok</p>\n<p>as a front-end coder</p>\n<p>in shanghai</p>\n"}],"Post":[{"title":"关于互联网寒冬","date":"2019-02-28T11:14:00.000Z","_content":"\n当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽\n<!-- more -->\n\n“面了好多家没拿到一个offer”\n“唉，一直接不到面试邀请”\n“外面行情是真的差啊，大厂都在裁员”\n.\n.\n.\n# winter of internet\n\n互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说\n\n有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧\n\n没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比\n\n然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？\n\n京东执行末尾淘汰机制。如何执行？裁员35%\n\n年后回到上海，朋友告诉我沪江教育裁了整两层楼\n\n前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人\n\n我肯定是麻木了\n\n# added fuel to the fire\n\n裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？\n\n老板：“996是一个好计划，just do it”\n\n大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢\n\n要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’\n白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”\n\n还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？\n\n# I'm such a pain in the neck\n\n当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中\n\n从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立...但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：自信带来的不是知识（潜台词是无知），一个名词：达克效应\n\n这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）\n\n以前认识的一个老大私聊我：有想法吗\n\n且行且看容我想一想\n\n我是人间惆怅客\n\n# last\n\n下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”\n\nend\n","source":"_posts/humanbeings/IsThisInternetWinter.md","raw":"---\ntitle: 关于互联网寒冬\ntags:\n  - 当我在扯淡\ndate: 2019-02-28 19:14:00\ncategories: 当我在扯淡\n---\n\n当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽\n<!-- more -->\n\n“面了好多家没拿到一个offer”\n“唉，一直接不到面试邀请”\n“外面行情是真的差啊，大厂都在裁员”\n.\n.\n.\n# winter of internet\n\n互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说\n\n有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧\n\n没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比\n\n然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？\n\n京东执行末尾淘汰机制。如何执行？裁员35%\n\n年后回到上海，朋友告诉我沪江教育裁了整两层楼\n\n前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人\n\n我肯定是麻木了\n\n# added fuel to the fire\n\n裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？\n\n老板：“996是一个好计划，just do it”\n\n大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢\n\n要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’\n白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”\n\n还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？\n\n# I'm such a pain in the neck\n\n当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中\n\n从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立...但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：自信带来的不是知识（潜台词是无知），一个名词：达克效应\n\n这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）\n\n以前认识的一个老大私聊我：有想法吗\n\n且行且看容我想一想\n\n我是人间惆怅客\n\n# last\n\n下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”\n\nend\n","slug":"humanbeings/IsThisInternetWinter","published":1,"updated":"2019-03-04T02:26:44.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt2pem110003f748bjjoe18c","content":"<p>当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽<br><a id=\"more\"></a></p>\n<p>“面了好多家没拿到一个offer”<br>“唉，一直接不到面试邀请”<br>“外面行情是真的差啊，大厂都在裁员”<br>.<br>.<br>.</p>\n<h1 id=\"winter-of-internet\"><a href=\"#winter-of-internet\" class=\"headerlink\" title=\"winter of internet\"></a>winter of internet</h1><p>互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说</p>\n<p>有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧</p>\n<p>没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比</p>\n<p>然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？</p>\n<p>京东执行末尾淘汰机制。如何执行？裁员35%</p>\n<p>年后回到上海，朋友告诉我沪江教育裁了整两层楼</p>\n<p>前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人</p>\n<p>我肯定是麻木了</p>\n<h1 id=\"added-fuel-to-the-fire\"><a href=\"#added-fuel-to-the-fire\" class=\"headerlink\" title=\"added fuel to the fire\"></a>added fuel to the fire</h1><p>裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？</p>\n<p>老板：“996是一个好计划，just do it”</p>\n<p>大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢</p>\n<p>要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’<br>白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”</p>\n<p>还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？</p>\n<h1 id=\"I’m-such-a-pain-in-the-neck\"><a href=\"#I’m-such-a-pain-in-the-neck\" class=\"headerlink\" title=\"I’m such a pain in the neck\"></a>I’m such a pain in the neck</h1><p>当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中</p>\n<p>从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立…但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：自信带来的不是知识（潜台词是无知），一个名词：达克效应</p>\n<p>这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）</p>\n<p>以前认识的一个老大私聊我：有想法吗</p>\n<p>且行且看容我想一想</p>\n<p>我是人间惆怅客</p>\n<h1 id=\"last\"><a href=\"#last\" class=\"headerlink\" title=\"last\"></a>last</h1><p>下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”</p>\n<p>end</p>\n","site":{"data":{}},"excerpt":"<p>当周围的程序员都在说外面行情很差的时候，貌似这个2019年冬天的风格外的凛冽<br></p>","more":"<p></p>\n<p>“面了好多家没拿到一个offer”<br>“唉，一直接不到面试邀请”<br>“外面行情是真的差啊，大厂都在裁员”<br>.<br>.<br>.</p>\n<h1 id=\"winter-of-internet\"><a href=\"#winter-of-internet\" class=\"headerlink\" title=\"winter of internet\"></a>winter of internet</h1><p>互联网寒冬真的来了吗？当大家都在这么说的时候大概就算是了吧，至少对于很多面试不顺甚至接不到面试邀请的人来说</p>\n<p>有段时间连续面了好几个‘经理’、‘负责人’头衔的应聘人员，注意了一下竟然全是同一个公司，有一次面试我问了一下才知道，原来猩便利裁员了，当时心中不以为意，貌似这个便利店名气也不是很大，可能没有拿到后续的融资了吧</p>\n<p>没过多久便有网传阿里等大厂不再社招的新闻，公司公关肯定是要辟谣的，无非是一直渴望人才引进怎可不再招人。内心这时依然怀疑这个互联网的时代会有真正的寒冬吗？当然仔细想想也会明白，就算是寒冬彻底不招人是不可能的，但是在招人的把控上肯定非之前可比</p>\n<p>然而既然网传寒冬，怎能只有这么一些。知道美团点评整个事业部将被撤掉，点评员工或转岗或拿赔偿的时候突然发觉可能这个冬天不是在和你开玩笑，上海这座南方城市一定要让生活在这片土地上的北方人感受一下真正的寒冷。其实说到这里我突然想到鱼泡泡的CTO正是18年年末从点评空降过来，是在位者长远的战略目光吗？略微有点‘不寒而栗’？</p>\n<p>京东执行末尾淘汰机制。如何执行？裁员35%</p>\n<p>年后回到上海，朋友告诉我沪江教育裁了整两层楼</p>\n<p>前段时间又听闻滴滴上海分部要被撤掉，想了想有朋友之前在那面待过貌似规模本身也不大。emmm，我应该是麻木了，后来听说是滴滴裁员15%达2000人</p>\n<p>我肯定是麻木了</p>\n<h1 id=\"added-fuel-to-the-fire\"><a href=\"#added-fuel-to-the-fire\" class=\"headerlink\" title=\"added fuel to the fire\"></a>added fuel to the fire</h1><p>裁员？不，既然是寒冬，裁员手段也太单一了，表面裁员，对内呢？</p>\n<p>老板：“996是一个好计划，just do it”</p>\n<p>大家都知道华为等公司追求的狼性文化以及他们所实施的‘末尾淘汰机制’，菊企的员工似乎为加班而生。还有上海新兴企业 ‘拼夕夕’ 的 ‘11 12 6’ 甚至加班至凌晨三点。当然高付出也对应了高回报，进去的人没必要抱怨太多毕竟是自己的选择。很多人连门槛都摸不到呢</p>\n<p>要说到 ‘996’ 一直是最令程序员作呕的一个名词，然而己亥新年伊始，杭州某‘有赞’公司的CEO竟然在年会直接宣布‘996工作制度’<br>白鸦员工：“这是年会？这不是真的。我不听，我不听，我不听”</p>\n<p>还是 ‘996’，鱼泡泡也是万恶的‘996’，十月份的某天？前端负责人的口头通知就这样简单的向我们宣布。哦对了，他也屡屡强调了‘末尾淘汰机制’，我是不是有必要展示出‘我好怕怕哟’以示尊重呢？</p>\n<h1 id=\"I’m-such-a-pain-in-the-neck\"><a href=\"#I’m-such-a-pain-in-the-neck\" class=\"headerlink\" title=\"I’m such a pain in the neck\"></a>I’m such a pain in the neck</h1><p>当然说了这么多，虽说是寒冬，但是因为各种原因我当然也在寻找机会的大军中</p>\n<p>从小到大，从学校到社会，从朋友到同事，我收到无数评价，或褒或贬但无非有这些词：自大、自傲、虚荣、乖戾、自信、负责、独立…但是这个冬天我收到来自peter的一个新的词 ‘无知’，甚至有 ‘引经据典’。我仔细看了‘经’‘典’，一句通俗的话：自信带来的不是知识（潜台词是无知），一个名词：达克效应</p>\n<p>这两天我在休假，peter他们可能会以为我在外面试，其实没有，我只是普通的睡睡懒觉，就像之前向peter请假说的：明天我不去了，很累要睡个懒觉。我真的只是在努力当一个肥宅（下意识看看自己键盘上的骷髅手，肥不起来宅总可以哎）</p>\n<p>以前认识的一个老大私聊我：有想法吗</p>\n<p>且行且看容我想一想</p>\n<p>我是人间惆怅客</p>\n<h1 id=\"last\"><a href=\"#last\" class=\"headerlink\" title=\"last\"></a>last</h1><p>下意识的裹紧了身上的棉毛睡衣，坐在书桌前看了眼背后空调的显示屏，“见鬼，28°C怎么这么冷，‘oh，shift’”</p>\n<p>end</p>"},{"title":"人生天地间 忽如远行客","date":"2019-01-03T16:00:00.000Z","_content":"\n我是人间惆怅客\n知君何事泪纵横\n\n<!--more-->\n\n## 原来18年已经结束了\n\n已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧\n\n从途虎到鱼泡泡\n\n结识不少新朋友\n\n和 [曹少](https://github.com/kailcc) 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍\n\n感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住\n\n心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事\n\n\n依然单身，这城市太空\n\n依旧经常胡思乱想，上至宇宙下至微尘，人事物景情\n\n之后再补上吧\n\n最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛\n","source":"_posts/humanbeings/人生天地间 忽如远行客.md","raw":"---\ntitle: 人生天地间 忽如远行客\ntags:\n  - 当我在扯淡\ndate: 2019-01-04 00:00:00\ncategories: 当我在扯淡\n---\n\n我是人间惆怅客\n知君何事泪纵横\n\n<!--more-->\n\n## 原来18年已经结束了\n\n已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧\n\n从途虎到鱼泡泡\n\n结识不少新朋友\n\n和 [曹少](https://github.com/kailcc) 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍\n\n感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住\n\n心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事\n\n\n依然单身，这城市太空\n\n依旧经常胡思乱想，上至宇宙下至微尘，人事物景情\n\n之后再补上吧\n\n最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛\n","slug":"humanbeings/人生天地间 忽如远行客","published":1,"updated":"2019-02-24T02:52:53.596Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt2pem140004f748h3ne3hov","content":"<p>我是人间惆怅客<br>知君何事泪纵横</p>\n<a id=\"more\"></a>\n<h2 id=\"原来18年已经结束了\"><a href=\"#原来18年已经结束了\" class=\"headerlink\" title=\"原来18年已经结束了\"></a>原来18年已经结束了</h2><p>已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧</p>\n<p>从途虎到鱼泡泡</p>\n<p>结识不少新朋友</p>\n<p>和 <a href=\"https://github.com/kailcc\" target=\"_blank\" rel=\"noopener\">曹少</a> 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍</p>\n<p>感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住</p>\n<p>心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事</p>\n<p>依然单身，这城市太空</p>\n<p>依旧经常胡思乱想，上至宇宙下至微尘，人事物景情</p>\n<p>之后再补上吧</p>\n<p>最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛</p>\n","site":{"data":{}},"excerpt":"<p>我是人间惆怅客<br>知君何事泪纵横</p>","more":"<h2 id=\"原来18年已经结束了\"><a href=\"#原来18年已经结束了\" class=\"headerlink\" title=\"原来18年已经结束了\"></a>原来18年已经结束了</h2><p>已至己亥，时间如流水，大江东去。五味陈杂的18年，单身程序员并不是只有工作，生活三番五次给我当头棒喝。简单总结下吧</p>\n<p>从途虎到鱼泡泡</p>\n<p>结识不少新朋友</p>\n<p>和 <a href=\"https://github.com/kailcc\" target=\"_blank\" rel=\"noopener\">曹少</a> 统一阵线，当然还有更多的大都点头泛泛之交如无根浮萍</p>\n<p>感谢周围帮助过我的同事和陌生人。我是那种不可肆意忘形的人，一切在我身上仿若是守恒的，得意不久总会迎来当头棒喝，只能闷声做事吗，这个年轻人也太不潇洒了。时候未到，阅历尚浅，不是我的我还拿不住</p>\n<p>心中的戾气一直不得消减，脾性虽然相对学生时代已经内敛很多，可戾气一直在心中积聚。可能个人内心极为自私，可能对现状极其不满，可最终的结果总是由于戾气在错误的时候的时候做了错误的事</p>\n<p>依然单身，这城市太空</p>\n<p>依旧经常胡思乱想，上至宇宙下至微尘，人事物景情</p>\n<p>之后再补上吧</p>\n<p>最后希望19年觅得知音，博得佳人，赚得钱财，摆脱苦痛</p>"},{"title":"算法复杂度","date":"2019-03-06T03:15:00.000Z","_content":"算法运行的时间复杂度和空间复杂度简单理解\n<!-- more -->\n*和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师*\n\n# 算法\n**算法**（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数\n\n说个粗浅的观点：在JS中定义的函数都是算法\n\n# 算法复杂度\n针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示\n\n- 时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)\n- 空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度\n\n*算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度*\n\n***所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度***\n\n# 时间复杂度\n一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用\"O\"来表示数量级，给出算法的时间复杂度\n\nT(n)=O(f(n))\n\n它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界\n- 时间复杂度就是函数中基本操作所执行的次数\n- 一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数\n- 忽略掉常数项\n- 关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数\n- 计算时间复杂度是估算随着n的增长函数执行次数的增长趋势\n- 递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数\n\n# 空间复杂度\n算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级\n\nS(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)\n\n递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)\n\n# 基础算法\n基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主\n\n## 冒泡排序\n核心代码：\n```js\n// arr\nfor (let i = 0; i < arr.length; i++) {\n  for (let j = 0; j < arr.length; j++) {\n    if (arr[j] > arr[j+1]) {\n      let temp = arr[j+1]\n      arr[j+1] = arr[j]\n      arr[j] = temp\n    }\n  }\n}\n```\n*此处只表述最基本的情况，不优化任何代码*\n\n该冒泡算法的时间复杂度：\n从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2\n所以该冒泡排序的时间复杂度为O(n^2)\n\n该冒泡算法的空间复杂度：\n从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)\n\n## 递归\n递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢\n\n*只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了*\n\n递归demo：\n```js\nlet n = 10\n\nfunction recursion() {\n  if (n > 1)\n    n-- && recursion()\n  else\n    return 'end of the recursive'\n}\n```\n上述是一个会循环执行10次就终止的简单递归\n该递归的时间复杂度：\n设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)\n该递归的空间复杂度：\n设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)\n\n## 二分法\n二分法本质依然是使用递归不断等分，代码如下：\n\n```js\n/**\n * @description: dichotomy\n * @param {Array} arr 入参数组\n * @param {any} val match\n * @param {Number} l 索引开始\n * @param {Number} r 索引结束\n*/\nfunction dichotomy(arr, val, l, r ){\n    let mid = Math.floor((l + r) / 2);\n    let midval = arr[mid]\n\n    if (l > r) return console.log('no match')\n\n    if (midval === val) return console.log('has match, index is ', mid)\n\n    midval > val\n      ? dichotomy(arr, val, l, mid - 1)\n      : dichotomy(arr, val, mid + 1, r)\n}\n\n// 测试\nconst arr = [1, 2, 3, 4, 5]\ndichotomy(arr, 3, 0, arr.length - 1)\n\n// optput:\n// has match, index is  2\n```\n算法的执行是不断等分数组，直到无法匹配要查找的数据\n设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4...\n.\n.\n.\n第 x 等分后长度为 n/2^x\n而算法执行的最差的情况就是每个等分的长度为1，1就是临界值\n所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数\n\n所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）\n每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数\n\n\n以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌\n\n\n**end**","source":"_posts/writeSomething/AlgorithmComplexity.md","raw":"---\ntitle: 算法复杂度\ntags:\n  - 算法\n  - 算法复杂度\ndate: 2019-03-06 11:15:00\ncategories: 算法\n---\n算法运行的时间复杂度和空间复杂度简单理解\n<!-- more -->\n*和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师*\n\n# 算法\n**算法**（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数\n\n说个粗浅的观点：在JS中定义的函数都是算法\n\n# 算法复杂度\n针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示\n\n- 时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)\n- 空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度\n\n*算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度*\n\n***所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度***\n\n# 时间复杂度\n一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用\"O\"来表示数量级，给出算法的时间复杂度\n\nT(n)=O(f(n))\n\n它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界\n- 时间复杂度就是函数中基本操作所执行的次数\n- 一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数\n- 忽略掉常数项\n- 关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数\n- 计算时间复杂度是估算随着n的增长函数执行次数的增长趋势\n- 递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数\n\n# 空间复杂度\n算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级\n\nS(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)\n\n递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)\n\n# 基础算法\n基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主\n\n## 冒泡排序\n核心代码：\n```js\n// arr\nfor (let i = 0; i < arr.length; i++) {\n  for (let j = 0; j < arr.length; j++) {\n    if (arr[j] > arr[j+1]) {\n      let temp = arr[j+1]\n      arr[j+1] = arr[j]\n      arr[j] = temp\n    }\n  }\n}\n```\n*此处只表述最基本的情况，不优化任何代码*\n\n该冒泡算法的时间复杂度：\n从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2\n所以该冒泡排序的时间复杂度为O(n^2)\n\n该冒泡算法的空间复杂度：\n从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)\n\n## 递归\n递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢\n\n*只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了*\n\n递归demo：\n```js\nlet n = 10\n\nfunction recursion() {\n  if (n > 1)\n    n-- && recursion()\n  else\n    return 'end of the recursive'\n}\n```\n上述是一个会循环执行10次就终止的简单递归\n该递归的时间复杂度：\n设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)\n该递归的空间复杂度：\n设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)\n\n## 二分法\n二分法本质依然是使用递归不断等分，代码如下：\n\n```js\n/**\n * @description: dichotomy\n * @param {Array} arr 入参数组\n * @param {any} val match\n * @param {Number} l 索引开始\n * @param {Number} r 索引结束\n*/\nfunction dichotomy(arr, val, l, r ){\n    let mid = Math.floor((l + r) / 2);\n    let midval = arr[mid]\n\n    if (l > r) return console.log('no match')\n\n    if (midval === val) return console.log('has match, index is ', mid)\n\n    midval > val\n      ? dichotomy(arr, val, l, mid - 1)\n      : dichotomy(arr, val, mid + 1, r)\n}\n\n// 测试\nconst arr = [1, 2, 3, 4, 5]\ndichotomy(arr, 3, 0, arr.length - 1)\n\n// optput:\n// has match, index is  2\n```\n算法的执行是不断等分数组，直到无法匹配要查找的数据\n设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4...\n.\n.\n.\n第 x 等分后长度为 n/2^x\n而算法执行的最差的情况就是每个等分的长度为1，1就是临界值\n所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数\n\n所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）\n每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数\n\n\n以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌\n\n\n**end**","slug":"writeSomething/AlgorithmComplexity","published":1,"updated":"2019-03-06T10:06:47.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt2pem180007f74813o3qnu0","content":"<p>算法运行的时间复杂度和空间复杂度简单理解<br><a id=\"more\"></a><br><em>和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师</em></p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p><strong>算法</strong>（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数</p>\n<p>说个粗浅的观点：在JS中定义的函数都是算法</p>\n<h1 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h1><p>针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示</p>\n<ul>\n<li>时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)</li>\n<li>空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度</li>\n</ul>\n<p><em>算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度</em></p>\n<p><strong><em>所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度</em></strong></p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用”O”来表示数量级，给出算法的时间复杂度</p>\n<p>T(n)=O(f(n))</p>\n<p>它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界</p>\n<ul>\n<li>时间复杂度就是函数中基本操作所执行的次数</li>\n<li>一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数</li>\n<li>忽略掉常数项</li>\n<li>关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数</li>\n<li>计算时间复杂度是估算随着n的增长函数执行次数的增长趋势</li>\n<li>递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数</li>\n</ul>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级</p>\n<p>S(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)</p>\n<p>递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)</p>\n<h1 id=\"基础算法\"><a href=\"#基础算法\" class=\"headerlink\" title=\"基础算法\"></a>基础算法</h1><p>基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>核心代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arr</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = arr[j+<span class=\"number\">1</span>]</span><br><span class=\"line\">      arr[j+<span class=\"number\">1</span>] = arr[j]</span><br><span class=\"line\">      arr[j] = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>此处只表述最基本的情况，不优化任何代码</em></p>\n<p>该冒泡算法的时间复杂度：<br>从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2<br>所以该冒泡排序的时间复杂度为O(n^2)</p>\n<p>该冒泡算法的空间复杂度：<br>从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)</p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢</p>\n<p><em>只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了</em></p>\n<p>递归demo：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursion</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    n-- &amp;&amp; recursion()</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'end of the recursive'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述是一个会循环执行10次就终止的简单递归<br>该递归的时间复杂度：<br>设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)<br>该递归的空间复杂度：<br>设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)</p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><p>二分法本质依然是使用递归不断等分，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @description: dichotomy</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; arr 入参数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; val match</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; l 索引开始</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; r 索引结束</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dichotomy</span>(<span class=\"params\">arr, val, l, r </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor((l + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> midval = arr[mid]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'no match'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (midval === val) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'has match, index is '</span>, mid)</span><br><span class=\"line\"></span><br><span class=\"line\">    midval &gt; val</span><br><span class=\"line\">      ? dichotomy(arr, val, l, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">      : dichotomy(arr, val, mid + <span class=\"number\">1</span>, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">dichotomy(arr, <span class=\"number\">3</span>, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// optput:</span></span><br><span class=\"line\"><span class=\"comment\">// has match, index is  2</span></span><br></pre></td></tr></table></figure>\n<p>算法的执行是不断等分数组，直到无法匹配要查找的数据<br>设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4…<br>.<br>.<br>.<br>第 x 等分后长度为 n/2^x<br>而算法执行的最差的情况就是每个等分的长度为1，1就是临界值<br>所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数</p>\n<p>所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）<br>每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数</p>\n<p>以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌</p>\n<p><strong>end</strong></p>\n","site":{"data":{}},"excerpt":"<p>算法运行的时间复杂度和空间复杂度简单理解<br></p>","more":"<br><em>和同学菜鸡互啄了一番之后成功验证了大学的知识早已还给老师</em><p></p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p><strong>算法</strong>（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数</p>\n<p>说个粗浅的观点：在JS中定义的函数都是算法</p>\n<h1 id=\"算法复杂度\"><a href=\"#算法复杂度\" class=\"headerlink\" title=\"算法复杂度\"></a>算法复杂度</h1><p>针对你的程序中算法的优劣、性能好坏有个评判的标准就是算法的复杂度，主要分为时间复杂度和空间复杂度两种，使用大写字母O表示</p>\n<ul>\n<li>时间复杂度(Time complexity)：是一个函数，它定性描述该算法的运行时间。通常使用算法的最坏情况复杂度，记为 T(n)</li>\n<li>空间复杂度(Space Complexity)：是对一个算法在运行过程中临时占用存储空间大小的量度</li>\n</ul>\n<p><em>算法的运行时间其实就是计算你的算法在指定条件下执行的次数就是时间复杂度，而算法执行过程中所需要开辟辅助内存的次数则是空间复杂度</em></p>\n<p><strong><em>所以说算法运行的次数和深度分别代表时间复杂度和空间复杂度</em></strong></p>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用”O”来表示数量级，给出算法的时间复杂度</p>\n<p>T(n)=O(f(n))</p>\n<p>它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界</p>\n<ul>\n<li>时间复杂度就是函数中基本操作所执行的次数</li>\n<li>一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数</li>\n<li>忽略掉常数项</li>\n<li>关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数</li>\n<li>计算时间复杂度是估算随着n的增长函数执行次数的增长趋势</li>\n<li>递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数</li>\n</ul>\n<h1 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h1><p>算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级</p>\n<p>S(n)=O(f(n)) 若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1)</p>\n<p>递归算法的空间复杂度：递归深度 N * 每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N)</p>\n<h1 id=\"基础算法\"><a href=\"#基础算法\" class=\"headerlink\" title=\"基础算法\"></a>基础算法</h1><p>基础算法有很多，排序、递归、二分法、贪婪算法、回溯等，以下简要列举简单为主</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>核心代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arr</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = arr[j+<span class=\"number\">1</span>]</span><br><span class=\"line\">      arr[j+<span class=\"number\">1</span>] = arr[j]</span><br><span class=\"line\">      arr[j] = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em>此处只表述最基本的情况，不优化任何代码</em></p>\n<p>该冒泡算法的时间复杂度：<br>从运行次数的角度来分析，设数组长度为n，两层forloop正好组成一个 n * n 的矩阵，所以总次数为 n^2<br>所以该冒泡排序的时间复杂度为O(n^2)</p>\n<p>该冒泡算法的空间复杂度：<br>从每次开辟的内存来看该算法每次只是使用之前系统的分配的内存（存储arr），所以冒泡排序的空间复杂度为O(1)</p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归是很常见的算法，使用得当不仅可以使代码更为简洁也可带来显著性能提升（像之前博客中提过的尾递归），那么递归算法的复杂度是如何计算呢</p>\n<p><em>只考虑有终止条件的递归，死循环的递归的复杂度当然是无穷大了</em></p>\n<p>递归demo：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursion</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    n-- &amp;&amp; recursion()</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'end of the recursive'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述是一个会循环执行10次就终止的简单递归<br>该递归的时间复杂度：<br>设递归的执行次数为n，也就是上述例子的终止条件，该递归的时间复杂度即为O(n)<br>该递归的空间复杂度：<br>设递归的执行次数为n，每次递归都要开辟新的栈帧（常数级别作1）保留在调用栈中以用来存储返回信息，所以该递归的空间复杂度 n * 1 即为O(n)</p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><p>二分法本质依然是使用递归不断等分，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @description: dichotomy</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; arr 入参数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; val match</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; l 索引开始</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Number&#125; r 索引结束</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dichotomy</span>(<span class=\"params\">arr, val, l, r </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor((l + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> midval = arr[mid]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'no match'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (midval === val) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'has match, index is '</span>, mid)</span><br><span class=\"line\"></span><br><span class=\"line\">    midval &gt; val</span><br><span class=\"line\">      ? dichotomy(arr, val, l, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">      : dichotomy(arr, val, mid + <span class=\"number\">1</span>, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">dichotomy(arr, <span class=\"number\">3</span>, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// optput:</span></span><br><span class=\"line\"><span class=\"comment\">// has match, index is  2</span></span><br></pre></td></tr></table></figure>\n<p>算法的执行是不断等分数组，直到无法匹配要查找的数据<br>设数组初始长度为 n，第一次递归后长度为 n/2，第二次等分后长度为 n/4…<br>.<br>.<br>.<br>第 x 等分后长度为 n/2^x<br>而算法执行的最差的情况就是每个等分的长度为1，1就是临界值<br>所以另 n/2^x = 1 时可得到等分的次数为 x = log以2为底n的对数</p>\n<p>所以二分法的时间复杂度为log以2为底n的对数（打不出上标下标🤕）<br>每次需要的辅助空间依然是常数级别作为1，所以空间复杂度也是log以2为底n的对数</p>\n<p>以上只是对算法复杂度的简单涉猎，可能有理解不当的错误❌</p>\n<p><strong>end</strong></p>"},{"title":"动态规划和递归：从虎羊草开始","date":"2019-02-21T12:36:00.000Z","_content":"\n老虎会吃羊吗？🐅🐑\n\n<!--more-->\n\n草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）\n\n_提示:每只老虎都很聪明_\n\n# 归纳\n\n#### case1: 两只老虎一只羊\n\n不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃\n\n#### case2: 三只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case1\n\n#### case3: 四只老虎一只羊\n\n不吃：一只老虎吃完羊后情景变为case2会被吃\n\n#### case4: 五只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case3\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃\n\n引出课题 `Dynamic Programming`\n\n# Dynamic Programming\n\n> 简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念\n\n- 最优子结构\n- 边界\n- 状态转移公式\n\n下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题\n\n_Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........这个数列从第3项开始，每一项都等于前两项之和_\n\n在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）因此可以直接写出以下代码：\n``` js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  return fn(n-1) + fn(n-2)\n}\n```\n运行结果如下：\n``` js\nconsole.log(\n  `第1项${fn(1)}`,\n  `第2项${fn(2)}`,\n  `第3项${fn(3)}`,\n  `第4项${fn(4)}`,\n  `第5项${fn(5)}`,\n  `第6项${fn(6)}`,\n  `第7项${fn(7)}`\n)\n// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13\n```\n\n现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念\n\n1. 最优子结构：若想求得第 `m` 项的值，那么只需要去求得第 `m-1` 和 `m-2` 的值即可，那么 `fn(m-1) + fn(m-2) === f(m)` 等式成立\n2. 边界: 即范围\n3. 状态转移公式：`f(m) = fn(m-1) + fn(m-2)`\n\n上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？\n具象化来看： 求得f(5) = ？\n - f(5)依赖 f(4)和f(3)\n - f(4)依赖 f(3)和f(2)\n - f(3)依赖 f(2)和f(1)\n\n显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：\n\n```js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  let m = 1, m_1 = 1, result\n\n  for(let i = 3; i <= n; i++){\n    result = m + m_1\n    m_1 = m\n    m = result\n  }\n\n  return result\n}\n```\n\n结果和上面是一致的但是性能就会有非常大的提升了\n\n# 既然上面提到了递归我们就再来说说递归\n_递归： 程序调用自身的编程技巧称为递归（recursion）_\n\n那么上面 `return fn(n-1) + fn(n-2)` 就是一个最普通的递归\n\n这里再引入一个尾递归的概念：就是函数在尾部调用自身\n\n那下面来简单说说为什么上面递归的写法性能会那么差\n\n调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存\n\n将上面方法改用尾递归的写法：\n```js\nfunction fn(n, m_1 = 1, m = 1) {  \n  if (n === 1 || n === 2) return m\n\n  return fn(n - 1, m, m + m_1)\n}\n```\n此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍\n\n当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈\n\n# summary\n\ndraven：好好看 好好学\n\n\n","source":"_posts/writeSomething/dynamicProgrammingAndRecursion.md","raw":"---\ntitle: 动态规划和递归：从虎羊草开始\ntags:\n  - 算法\n  - 动态规划\n  - 递归\n  - 尾递归\ndate: 2019-02-21 20:36:00\ncategories: 算法\n---\n\n老虎会吃羊吗？🐅🐑\n\n<!--more-->\n\n草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）\n\n_提示:每只老虎都很聪明_\n\n# 归纳\n\n#### case1: 两只老虎一只羊\n\n不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃\n\n#### case2: 三只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case1\n\n#### case3: 四只老虎一只羊\n\n不吃：一只老虎吃完羊后情景变为case2会被吃\n\n#### case4: 五只老虎一只羊\n\n吃：一只老虎吃完羊后情景变为case3\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃\n\n引出课题 `Dynamic Programming`\n\n# Dynamic Programming\n\n> 简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念\n\n- 最优子结构\n- 边界\n- 状态转移公式\n\n下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题\n\n_Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........这个数列从第3项开始，每一项都等于前两项之和_\n\n在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）因此可以直接写出以下代码：\n``` js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  return fn(n-1) + fn(n-2)\n}\n```\n运行结果如下：\n``` js\nconsole.log(\n  `第1项${fn(1)}`,\n  `第2项${fn(2)}`,\n  `第3项${fn(3)}`,\n  `第4项${fn(4)}`,\n  `第5项${fn(5)}`,\n  `第6项${fn(6)}`,\n  `第7项${fn(7)}`\n)\n// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13\n```\n\n现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念\n\n1. 最优子结构：若想求得第 `m` 项的值，那么只需要去求得第 `m-1` 和 `m-2` 的值即可，那么 `fn(m-1) + fn(m-2) === f(m)` 等式成立\n2. 边界: 即范围\n3. 状态转移公式：`f(m) = fn(m-1) + fn(m-2)`\n\n上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？\n具象化来看： 求得f(5) = ？\n - f(5)依赖 f(4)和f(3)\n - f(4)依赖 f(3)和f(2)\n - f(3)依赖 f(2)和f(1)\n\n显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：\n\n```js\nfunction fn(n) {\n  if (n === 1 || n === 2){\n\t  return 1\n  }\n\n  let m = 1, m_1 = 1, result\n\n  for(let i = 3; i <= n; i++){\n    result = m + m_1\n    m_1 = m\n    m = result\n  }\n\n  return result\n}\n```\n\n结果和上面是一致的但是性能就会有非常大的提升了\n\n# 既然上面提到了递归我们就再来说说递归\n_递归： 程序调用自身的编程技巧称为递归（recursion）_\n\n那么上面 `return fn(n-1) + fn(n-2)` 就是一个最普通的递归\n\n这里再引入一个尾递归的概念：就是函数在尾部调用自身\n\n那下面来简单说说为什么上面递归的写法性能会那么差\n\n调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存\n\n将上面方法改用尾递归的写法：\n```js\nfunction fn(n, m_1 = 1, m = 1) {  \n  if (n === 1 || n === 2) return m\n\n  return fn(n - 1, m, m + m_1)\n}\n```\n此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍\n\n当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈\n\n# summary\n\ndraven：好好看 好好学\n\n\n","slug":"writeSomething/dynamicProgrammingAndRecursion","published":1,"updated":"2019-02-24T02:52:53.593Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt2pem190008f748qoh62ppu","content":"<p>老虎会吃羊吗？🐅🐑</p>\n<a id=\"more\"></a>\n<p>草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）</p>\n<p><em>提示:每只老虎都很聪明</em></p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><h4 id=\"case1-两只老虎一只羊\"><a href=\"#case1-两只老虎一只羊\" class=\"headerlink\" title=\"case1: 两只老虎一只羊\"></a>case1: 两只老虎一只羊</h4><p>不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃</p>\n<h4 id=\"case2-三只老虎一只羊\"><a href=\"#case2-三只老虎一只羊\" class=\"headerlink\" title=\"case2: 三只老虎一只羊\"></a>case2: 三只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case1</p>\n<h4 id=\"case3-四只老虎一只羊\"><a href=\"#case3-四只老虎一只羊\" class=\"headerlink\" title=\"case3: 四只老虎一只羊\"></a>case3: 四只老虎一只羊</h4><p>不吃：一只老虎吃完羊后情景变为case2会被吃</p>\n<h4 id=\"case4-五只老虎一只羊\"><a href=\"#case4-五只老虎一只羊\" class=\"headerlink\" title=\"case4: 五只老虎一只羊\"></a>case4: 五只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case3</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃</p>\n<p>引出课题 <code>Dynamic Programming</code></p>\n<h1 id=\"Dynamic-Programming\"><a href=\"#Dynamic-Programming\" class=\"headerlink\" title=\"Dynamic Programming\"></a>Dynamic Programming</h1><blockquote>\n<p>简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念</p>\n</blockquote>\n<ul>\n<li>最优子结构</li>\n<li>边界</li>\n<li>状态转移公式</li>\n</ul>\n<p>下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题</p>\n<p><em>Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..这个数列从第3项开始，每一项都等于前两项之和</em></p>\n<p>在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）因此可以直接写出以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n<span class=\"number\">-1</span>) + fn(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第1项<span class=\"subst\">$&#123;fn(<span class=\"number\">1</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第2项<span class=\"subst\">$&#123;fn(<span class=\"number\">2</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第3项<span class=\"subst\">$&#123;fn(<span class=\"number\">3</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第4项<span class=\"subst\">$&#123;fn(<span class=\"number\">4</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第5项<span class=\"subst\">$&#123;fn(<span class=\"number\">5</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第6项<span class=\"subst\">$&#123;fn(<span class=\"number\">6</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第7项<span class=\"subst\">$&#123;fn(<span class=\"number\">7</span>)&#125;</span>`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13</span></span><br></pre></td></tr></table></figure></p>\n<p>现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念</p>\n<ol>\n<li>最优子结构：若想求得第 <code>m</code> 项的值，那么只需要去求得第 <code>m-1</code> 和 <code>m-2</code> 的值即可，那么 <code>fn(m-1) + fn(m-2) === f(m)</code> 等式成立</li>\n<li>边界: 即范围</li>\n<li>状态转移公式：<code>f(m) = fn(m-1) + fn(m-2)</code></li>\n</ol>\n<p>上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？<br>具象化来看： 求得f(5) = ？</p>\n<ul>\n<li>f(5)依赖 f(4)和f(3)</li>\n<li>f(4)依赖 f(3)和f(2)</li>\n<li>f(3)依赖 f(2)和f(1)</li>\n</ul>\n<p>显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>, m_1 = <span class=\"number\">1</span>, result</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">    result = m + m_1</span><br><span class=\"line\">    m_1 = m</span><br><span class=\"line\">    m = result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果和上面是一致的但是性能就会有非常大的提升了</p>\n<h1 id=\"既然上面提到了递归我们就再来说说递归\"><a href=\"#既然上面提到了递归我们就再来说说递归\" class=\"headerlink\" title=\"既然上面提到了递归我们就再来说说递归\"></a>既然上面提到了递归我们就再来说说递归</h1><p><em>递归： 程序调用自身的编程技巧称为递归（recursion）</em></p>\n<p>那么上面 <code>return fn(n-1) + fn(n-2)</code> 就是一个最普通的递归</p>\n<p>这里再引入一个尾递归的概念：就是函数在尾部调用自身</p>\n<p>那下面来简单说说为什么上面递归的写法性能会那么差</p>\n<p>调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存</p>\n<p>将上面方法改用尾递归的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n, m_1 = <span class=\"number\">1</span>, m = <span class=\"number\">1</span></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> m</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n - <span class=\"number\">1</span>, m, m + m_1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍</p>\n<p>当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>draven：好好看 好好学</p>\n","site":{"data":{}},"excerpt":"<p>老虎会吃羊吗？🐅🐑</p>","more":"<p>草原上有 1000 只老虎和 1 只羊，老虎吃羊，羊吃草，但是老虎吃完羊会变成羊（一只羊只能被一只老虎吃）</p>\n<p><em>提示:每只老虎都很聪明</em></p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><h4 id=\"case1-两只老虎一只羊\"><a href=\"#case1-两只老虎一只羊\" class=\"headerlink\" title=\"case1: 两只老虎一只羊\"></a>case1: 两只老虎一只羊</h4><p>不吃：一只老虎吃完羊后变为羊会被剩下的老虎吃</p>\n<h4 id=\"case2-三只老虎一只羊\"><a href=\"#case2-三只老虎一只羊\" class=\"headerlink\" title=\"case2: 三只老虎一只羊\"></a>case2: 三只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case1</p>\n<h4 id=\"case3-四只老虎一只羊\"><a href=\"#case3-四只老虎一只羊\" class=\"headerlink\" title=\"case3: 四只老虎一只羊\"></a>case3: 四只老虎一只羊</h4><p>不吃：一只老虎吃完羊后情景变为case2会被吃</p>\n<h4 id=\"case4-五只老虎一只羊\"><a href=\"#case4-五只老虎一只羊\" class=\"headerlink\" title=\"case4: 五只老虎一只羊\"></a>case4: 五只老虎一只羊</h4><p>吃：一只老虎吃完羊后情景变为case3</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>由最基本的归纳法可以判断只有一只羊的时候，偶数只老虎情况下不吃，而奇数只老虎情况下可以吃</p>\n<p>引出课题 <code>Dynamic Programming</code></p>\n<h1 id=\"Dynamic-Programming\"><a href=\"#Dynamic-Programming\" class=\"headerlink\" title=\"Dynamic Programming\"></a>Dynamic Programming</h1><blockquote>\n<p>简单的理解就是从最基本的的情况入手逐渐将整个问题解决，动态规划主要包含以下三种概念</p>\n</blockquote>\n<ul>\n<li>最优子结构</li>\n<li>边界</li>\n<li>状态转移公式</li>\n</ul>\n<p>下面用常见的斐波那契数列（黄金分割数列、兔子数列）来具象化问题</p>\n<p><em>Fibonacci：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..这个数列从第3项开始，每一项都等于前两项之和</em></p>\n<p>在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）因此可以直接写出以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n<span class=\"number\">-1</span>) + fn(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第1项<span class=\"subst\">$&#123;fn(<span class=\"number\">1</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第2项<span class=\"subst\">$&#123;fn(<span class=\"number\">2</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第3项<span class=\"subst\">$&#123;fn(<span class=\"number\">3</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第4项<span class=\"subst\">$&#123;fn(<span class=\"number\">4</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第5项<span class=\"subst\">$&#123;fn(<span class=\"number\">5</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第6项<span class=\"subst\">$&#123;fn(<span class=\"number\">6</span>)&#125;</span>`</span>,</span><br><span class=\"line\">  <span class=\"string\">`第7项<span class=\"subst\">$&#123;fn(<span class=\"number\">7</span>)&#125;</span>`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// VM455:1 第1项1 第2项1 第3项2 第4项3 第5项5 第6项8 第7项13</span></span><br></pre></td></tr></table></figure></p>\n<p>现在根据斐波那契数列来解释上面提出的三个动态规划相关的概念</p>\n<ol>\n<li>最优子结构：若想求得第 <code>m</code> 项的值，那么只需要去求得第 <code>m-1</code> 和 <code>m-2</code> 的值即可，那么 <code>fn(m-1) + fn(m-2) === f(m)</code> 等式成立</li>\n<li>边界: 即范围</li>\n<li>状态转移公式：<code>f(m) = fn(m-1) + fn(m-2)</code></li>\n</ol>\n<p>上面的方法其实看起来就是一个最简单的递归，但是性能会有很大的问题，为什么呢？<br>具象化来看： 求得f(5) = ？</p>\n<ul>\n<li>f(5)依赖 f(4)和f(3)</li>\n<li>f(4)依赖 f(3)和f(2)</li>\n<li>f(3)依赖 f(2)和f(1)</li>\n</ul>\n<p>显然上面的计算有着大量的重复操作，既然所有的结果都是基于f(1)和f(2), 那么从f(1)和f(2)的计算开始就避免了重复的计算，也是就动态规划的思想， 代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>, m_1 = <span class=\"number\">1</span>, result</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">    result = m + m_1</span><br><span class=\"line\">    m_1 = m</span><br><span class=\"line\">    m = result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果和上面是一致的但是性能就会有非常大的提升了</p>\n<h1 id=\"既然上面提到了递归我们就再来说说递归\"><a href=\"#既然上面提到了递归我们就再来说说递归\" class=\"headerlink\" title=\"既然上面提到了递归我们就再来说说递归\"></a>既然上面提到了递归我们就再来说说递归</h1><p><em>递归： 程序调用自身的编程技巧称为递归（recursion）</em></p>\n<p>那么上面 <code>return fn(n-1) + fn(n-2)</code> 就是一个最普通的递归</p>\n<p>这里再引入一个尾递归的概念：就是函数在尾部调用自身</p>\n<p>那下面来简单说说为什么上面递归的写法性能会那么差</p>\n<p>调用栈随着n的增加而线性增加很容易造成内存堆栈溢出。这是因为这种递归操作中，同时保存了大量的栈帧，调用栈非常长，消耗了巨大的内存</p>\n<p>将上面方法改用尾递归的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n, m_1 = <span class=\"number\">1</span>, m = <span class=\"number\">1</span></span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> m</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(n - <span class=\"number\">1</span>, m, m + m_1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时fn每次递归仅仅更新自己的调用栈，性能得到大幅提升👍</p>\n<p>当然所有的递归都可以用循环来实现，不就避免了堆栈溢出的可能了吗 啊哈哈哈哈哈哈</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>draven：好好看 好好学</p>"},{"title":"小程序的路由封装","date":"2018-12-09T08:00:00.000Z","_content":"\n基于 `mpvue` 小程序的路由封装\n\n<!--more-->\n\n[toc]\n\n## 基本使用\n\n组件内使用方法：\n```js\n\n  // 不携带路由参数\n  this.$router.push('/home/page/index')\n  // 携带路由参数\n  this.$router.push({\n    path: '/home/page/index',\n    query: {\n      //\n    },\n    reLaunch: true, // 调用wx.reLaunch\n    isTab: true // 调用wx.switchTag\n  })\n\n  // 读取当前页面路由参数\n\n  const { query } = this.$route\n\n```\n组件外部使用只需要引入router.js内部导出的push方法即可\n\n\n## 封装起步\n\n分为两点切入：\n  1. 了解微信提供的api\n  2. 自己的需求\n\n总结为以下几点：\n\n- 对微信小程序的 `switchTab、reLaunch、navigateTo、redirectTo` 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 `this.$router.push` 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 `this.$route.query` 读取。\n\n- 路由默认跳转为 `wx.navigateTo` 静态跳转，调用其他跳转方式需传递相应参数\n\n* 封装的跳转优先级：\n```\n    wx.switchTab >> wx.reLaunch >> wx.navigateTo\n```\n\n- 路由拥有拦截器，分为全局拦截和针对指定页面根据 `path` 拦截。\n\n_注意： 路由不支持指定 `wx.redireactTo` 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）_\n\n\n下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题\n\n\n### 如何完成基本跳转功能\n\n_需求：页面内使用 `this.$router.push` 方法跳转页面_\n\n首先就是新建 `index.js` 自定义一个最基本的 `push` 方法用来跳转页面\n\n``` js\n  // location 为路由传参\n  function push(location) {\n\n    const params = { url: location.path }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n\n然后为了让我们可以在页面中使用这个方法需要将 `push` 方法挂载在页面的实例上, 同时使用插件式调用在 `index.js` 文件中导出 `install` 方法\n\n``` js\n  // 导出\n  export default {\n    install(Vue) {\n\n      const _router = {\n        mode: 'history',\n        push\n      }\n      // 定义描述符getter（也可直接赋值value）\n      const $router = {\n        get() {\n          return _router\n        }\n      }\n      // 挂载 (各凭喜好也可以直接赋值在prototype上）\n      Object.defineProperty(Vue.prototype, '$router', $router)\n    }\n  }\n```\n\n接下来在项目入口文件注入上面 `index.js` 文件并执行 `Vue.use`\n\n``` js\n  import Vue from 'vue'\n  import router from './index.js'\n  \n  Vue.use(router) \n```\n\n即可在任意页面使用 `this.$router.push` 方法并传入相应跳转方式和路径\n\n这里存在一个问题： 项目跳转为了更美观主要使用 `wx.navigateTo`， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释\n\n### 页面之间如何读写参数\n\n_需求： 页面内跳转通过路由参数 `query` 字段传参， 通过 `this.$route.query` 读取参数_\n\n所以我们需要一个能够简单解析 `push` 方法参数的功能型函数 `parseUrl`，里面包括将所传的 `query` 字段以地址栏参数形式拼接在 `path` 后面的一个 `stringifyQuery` 函数\n\n``` js\n  function parseUrl(location) {\n    const { path, query } = location\n    const queryStr = stringifyQuery(query)\n\n    return `${path}${queryStr}`\n  }\n\n  function stringifyQuery(obj) {\n    const res = obj\n      ? Object.keys(obj)\n          .filter(Boolean)\n          .map(key => {\n            let val = obj[key]\n\n            if ([Array, Object].includes(val.constructor)) {\n              val = JSON.stringify(obj[key])\n            }\n            return `${key}=${val}`\n          })\n          \n          .join('&')\n      : null\n\n    return res ? `?${res}` : ''\n  }\n```\n\n把 `parseUrl` 方法添加到上面的 `push` 方法，同时参数内部是支持小程序路由跳转过程的`success`, `fail`, `complete` 钩子的 \n\n``` js\n  // location 为路由传参\n  function push(location) {\n    // others 为用户可能传递的 `success`, `fail`, `complete`\n    const { path, query, ...others } = location\n\n    const url = parseUrl({ path, query })\n\n    const params = { url, ...others }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 `$route` 对象与前面的 `$router` 一致挂载页面实例上\n\n这一层读mpvue的实例创建一个 `parseRoute` 函数简单处理一下数据即可\n\n此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0\n以下同时简单处理一下\n\n``` js\n  function parseRoute($mp) {\n    // $mp 为mpvue实例root上挂载的对象\n    const _mp = $mp || {}\n    const path = _mp.page && _mp.page.route\n    const parseQuery = {}\n    const tempQuery = _mp.query\n\n    for (let k in tempQuery) {\n      let cur = tempQuery[k]\n\n      try {\n        // 解决长整型丢失精度\n        const transfer = JSON.parse(tempQuery[k])\n\n        if (!(typeof transfer === 'number')) {\n          cur = transfer\n        }\n      } catch (e) {}\n\n      parseQuery[k] = cur\n    }\n\n    return {\n      parseQuery\n    }\n  }\n```\n\n最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 `onShow` 钩子上\n\n``` js\n  const _route = {}\n\n  Vue.mixin({\n    onShow() {\n      const { $mp } = this.$root\n\n      _route = parseRoute($mp)\n    }\n  })\n\n  const $route = {\n    get() {\n      return _route\n    }\n  }\n\n  Object.defineProperty(Vue.prototype, '$route', $route)\n```\n以上便完成路由参数的读写\n\n### 解决上面提出的小程序堆栈限制问题\n\n小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 `wx.redirectTo` 即可（其他时间项目中仅使用 `navigateTo` 即可）\n\n首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 `push` 方法\n\n``` js\n  // 当前页面堆栈长度\n  let pageStackLen = 0\n  // 堆栈限制\n  const maxStackLen = 10\n\n  function push(location, success, ...ohters) {\n    pageStackLen = getCurrentPages().length + 1\n\n    const url = parseUrl(location)\n\n    // 包装跳转成功的回调\n    const _success = function() {\n      pageStackLen = getCurrentPages().length + 1\n\n      success && success()\n    }\n\n    const params = { url, success: _success, ...ohters}\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n      pageStackLen = 1\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n\n      pageStackLen = 1\n    } else {\n      if (pageStackLen >= maxStackLen) {\n        wx.redirectTo(params)\n        return\n      }\n      wx.navigateTo(params)\n    }\n  }\n```\n以上基本解决小程序堆栈限制问题\n\n### 完善路由跳转功能\n\n现在对路由的跳转做一些基本辅助功能的支持 `go`、 `back`, `replace` 等方法\n\n``` js\n  function replace(location, ...others) {\n    const url = parseUrl(location)\n\n    wx.redirectTo({\n      url,\n      ...others\n    })\n  }\n\n  function go(delta) {\n    wx.navigateBack({\n      delta\n    })\n  }\n\n  function back() {\n    wx.navigateBack()\n  }\n```\n\n将这些挂到 `$router` 对象\n\n``` js\n  const _router = {\n    mode: 'history',\n    push,\n    replace,\n    go,\n    back\n  }\n\n  const $router = {\n    get() {\n      return _router\n    }\n  }\n\n```\n\n此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 `push` 方法方便组件外部调用等优化\n\n最后我们还差路由拦截器功能的实现\n\n### 路由拦截器\n\n需求： 对象形式配置自己路由规则\n  - `[triggerAll]`： 所有路由跳转均会触发\n  - `[triggerMatch]`： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发\n\n参数介绍：\n- `config`: 携带当前路由跳转信息（路由参数）\n- `to`: 控制跳转（调用 `to()` ）\n\n\n使用方式：\n\n``` js\nexport default {\n  triggerAll(config, to) {\n    console.log(config, 'enter interceptor')\n    to()\n  },\n  triggerMatch: {\n    '/home/pages/categoryList': [\n      (config, to) => {\n        if (/*flag*/) {\n          console.log(1)\n          to()\n        }\n      }\n    ]\n  }\n}\n```\n\n本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的\n\n新建 `interceptor.js`\n\n首先引入之前的路由方便在实例上调用，定义 `triggerMatch` 的对象存储存入的函数 `key` 为当前路由的路径，`value` 为 中间件函数组成的数组\n\n关键： 将 `push` 方法当做单独的一个中间件并放在所有中间件的最后执行\n\n``` js\n  // 引入\n  import router from './index.js'\n  // 挂载\n  Vue.use(router)\n  // 存匹配指定路由的业务函数\n  let matchMiddlewares = {}\n\n```\n接下来要构建一个处理推入规则的业务函数（中间件）的 `compose` 函数\n\n这个函数的作用主要分为两个：\n - 依次派发推入拦截器的业务函数\n - 控制下一次派发的开始\n\n``` js\n  const compose = middlewares => (...args) => {\n    function dispatch(i) {\n      return !middlewares[i]\n        ? Promise.resolve('no arguments')\n        : Promise.resolve(\n            middlewares[i](...args, function() {\n              // 派发下个调用\n              // 此处即是拦截器中第二个实参 to 方法的函数体\n              // 调动 to() 即开启下一次派发\n              return dispatch(++i)\n            })\n          )\n    }\n    // 开启调用\n    return dispatch(0)\n  }\n```\n\n创建一个函数 `getMatchMiddlewares` 用来根据指定键值读取 `matchMiddlewares` 中中间件函数数组\n\n```js\n  function getMatchMiddlewares(path) {\n    return matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []\n  }\n```\n\n\n路由同样使用 `Vue.use` 方法注册，这里导出 `install` 方法, 在里面统一所有中间件函数\n\n``` js\n  // 包装 push\n  let $push\n\n  function pushMiddware(...args) {\n    $push(...args)\n  }\n\n  export default {\n    install(Vue, { triggerAll, triggerMatch }) {\n      // 存储原 push 函数\n      $push = Vue.prototype.$router.push\n      // 接收传入的匹配函数\n      matchMiddlewares = Object.assign({}, triggerMatch)\n      \n      // 重新赋值\n      Vue.prototype.$router.push = (...args) => {\n        // 合并\n        compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(\n          ...args\n        )\n      }\n    }\n  }\n\n\n```\n\n之后在入口文件中引入即可\n\n``` js\n  import Vue from 'vue'\n  import interceptor from './interceptor.js'\n\n  Vue.use(interceptor)\n```\n\n至此便完成了路由的所有功能的基本封装\n\n详细代码可以查看 [小程序路由](http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router)\n\n此篇文章已经发布在 [http://doc.yupaopao.com](http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857)\n\n## 总结\n路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步\n\n## 最后\npo一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：\n\n![比心小程序](https://yphoto.eryufm.cn/gh_3192acdd1484_258.jpg)","source":"_posts/writeSomething/appletRouter.md","raw":"---\ntitle: 小程序的路由封装\ntags:\n  - 封装\n  - 微信小程序\n  - mpvue\n  - 路由\ndate: 2018-12-09 16:00:00\ncategories: 封装\n---\n\n基于 `mpvue` 小程序的路由封装\n\n<!--more-->\n\n[toc]\n\n## 基本使用\n\n组件内使用方法：\n```js\n\n  // 不携带路由参数\n  this.$router.push('/home/page/index')\n  // 携带路由参数\n  this.$router.push({\n    path: '/home/page/index',\n    query: {\n      //\n    },\n    reLaunch: true, // 调用wx.reLaunch\n    isTab: true // 调用wx.switchTag\n  })\n\n  // 读取当前页面路由参数\n\n  const { query } = this.$route\n\n```\n组件外部使用只需要引入router.js内部导出的push方法即可\n\n\n## 封装起步\n\n分为两点切入：\n  1. 了解微信提供的api\n  2. 自己的需求\n\n总结为以下几点：\n\n- 对微信小程序的 `switchTab、reLaunch、navigateTo、redirectTo` 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 `this.$router.push` 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 `this.$route.query` 读取。\n\n- 路由默认跳转为 `wx.navigateTo` 静态跳转，调用其他跳转方式需传递相应参数\n\n* 封装的跳转优先级：\n```\n    wx.switchTab >> wx.reLaunch >> wx.navigateTo\n```\n\n- 路由拥有拦截器，分为全局拦截和针对指定页面根据 `path` 拦截。\n\n_注意： 路由不支持指定 `wx.redireactTo` 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）_\n\n\n下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题\n\n\n### 如何完成基本跳转功能\n\n_需求：页面内使用 `this.$router.push` 方法跳转页面_\n\n首先就是新建 `index.js` 自定义一个最基本的 `push` 方法用来跳转页面\n\n``` js\n  // location 为路由传参\n  function push(location) {\n\n    const params = { url: location.path }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n\n然后为了让我们可以在页面中使用这个方法需要将 `push` 方法挂载在页面的实例上, 同时使用插件式调用在 `index.js` 文件中导出 `install` 方法\n\n``` js\n  // 导出\n  export default {\n    install(Vue) {\n\n      const _router = {\n        mode: 'history',\n        push\n      }\n      // 定义描述符getter（也可直接赋值value）\n      const $router = {\n        get() {\n          return _router\n        }\n      }\n      // 挂载 (各凭喜好也可以直接赋值在prototype上）\n      Object.defineProperty(Vue.prototype, '$router', $router)\n    }\n  }\n```\n\n接下来在项目入口文件注入上面 `index.js` 文件并执行 `Vue.use`\n\n``` js\n  import Vue from 'vue'\n  import router from './index.js'\n  \n  Vue.use(router) \n```\n\n即可在任意页面使用 `this.$router.push` 方法并传入相应跳转方式和路径\n\n这里存在一个问题： 项目跳转为了更美观主要使用 `wx.navigateTo`， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释\n\n### 页面之间如何读写参数\n\n_需求： 页面内跳转通过路由参数 `query` 字段传参， 通过 `this.$route.query` 读取参数_\n\n所以我们需要一个能够简单解析 `push` 方法参数的功能型函数 `parseUrl`，里面包括将所传的 `query` 字段以地址栏参数形式拼接在 `path` 后面的一个 `stringifyQuery` 函数\n\n``` js\n  function parseUrl(location) {\n    const { path, query } = location\n    const queryStr = stringifyQuery(query)\n\n    return `${path}${queryStr}`\n  }\n\n  function stringifyQuery(obj) {\n    const res = obj\n      ? Object.keys(obj)\n          .filter(Boolean)\n          .map(key => {\n            let val = obj[key]\n\n            if ([Array, Object].includes(val.constructor)) {\n              val = JSON.stringify(obj[key])\n            }\n            return `${key}=${val}`\n          })\n          \n          .join('&')\n      : null\n\n    return res ? `?${res}` : ''\n  }\n```\n\n把 `parseUrl` 方法添加到上面的 `push` 方法，同时参数内部是支持小程序路由跳转过程的`success`, `fail`, `complete` 钩子的 \n\n``` js\n  // location 为路由传参\n  function push(location) {\n    // others 为用户可能传递的 `success`, `fail`, `complete`\n    const { path, query, ...others } = location\n\n    const url = parseUrl({ path, query })\n\n    const params = { url, ...others }\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n    } else if (location.redirect) {\n      wx.redirectTo(params)\n    } else {\n      wx.navigateTo(params)\n    }\n  }\n```\n以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 `$route` 对象与前面的 `$router` 一致挂载页面实例上\n\n这一层读mpvue的实例创建一个 `parseRoute` 函数简单处理一下数据即可\n\n此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0\n以下同时简单处理一下\n\n``` js\n  function parseRoute($mp) {\n    // $mp 为mpvue实例root上挂载的对象\n    const _mp = $mp || {}\n    const path = _mp.page && _mp.page.route\n    const parseQuery = {}\n    const tempQuery = _mp.query\n\n    for (let k in tempQuery) {\n      let cur = tempQuery[k]\n\n      try {\n        // 解决长整型丢失精度\n        const transfer = JSON.parse(tempQuery[k])\n\n        if (!(typeof transfer === 'number')) {\n          cur = transfer\n        }\n      } catch (e) {}\n\n      parseQuery[k] = cur\n    }\n\n    return {\n      parseQuery\n    }\n  }\n```\n\n最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 `onShow` 钩子上\n\n``` js\n  const _route = {}\n\n  Vue.mixin({\n    onShow() {\n      const { $mp } = this.$root\n\n      _route = parseRoute($mp)\n    }\n  })\n\n  const $route = {\n    get() {\n      return _route\n    }\n  }\n\n  Object.defineProperty(Vue.prototype, '$route', $route)\n```\n以上便完成路由参数的读写\n\n### 解决上面提出的小程序堆栈限制问题\n\n小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 `wx.redirectTo` 即可（其他时间项目中仅使用 `navigateTo` 即可）\n\n首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 `push` 方法\n\n``` js\n  // 当前页面堆栈长度\n  let pageStackLen = 0\n  // 堆栈限制\n  const maxStackLen = 10\n\n  function push(location, success, ...ohters) {\n    pageStackLen = getCurrentPages().length + 1\n\n    const url = parseUrl(location)\n\n    // 包装跳转成功的回调\n    const _success = function() {\n      pageStackLen = getCurrentPages().length + 1\n\n      success && success()\n    }\n\n    const params = { url, success: _success, ...ohters}\n\n    if (location.isTab) {\n      wx.switchTab(params)\n\n      pageStackLen = 1\n    } else if (location.reLaunch) {\n      wx.reLaunch(params)\n\n      pageStackLen = 1\n    } else {\n      if (pageStackLen >= maxStackLen) {\n        wx.redirectTo(params)\n        return\n      }\n      wx.navigateTo(params)\n    }\n  }\n```\n以上基本解决小程序堆栈限制问题\n\n### 完善路由跳转功能\n\n现在对路由的跳转做一些基本辅助功能的支持 `go`、 `back`, `replace` 等方法\n\n``` js\n  function replace(location, ...others) {\n    const url = parseUrl(location)\n\n    wx.redirectTo({\n      url,\n      ...others\n    })\n  }\n\n  function go(delta) {\n    wx.navigateBack({\n      delta\n    })\n  }\n\n  function back() {\n    wx.navigateBack()\n  }\n```\n\n将这些挂到 `$router` 对象\n\n``` js\n  const _router = {\n    mode: 'history',\n    push,\n    replace,\n    go,\n    back\n  }\n\n  const $router = {\n    get() {\n      return _router\n    }\n  }\n\n```\n\n此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 `push` 方法方便组件外部调用等优化\n\n最后我们还差路由拦截器功能的实现\n\n### 路由拦截器\n\n需求： 对象形式配置自己路由规则\n  - `[triggerAll]`： 所有路由跳转均会触发\n  - `[triggerMatch]`： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发\n\n参数介绍：\n- `config`: 携带当前路由跳转信息（路由参数）\n- `to`: 控制跳转（调用 `to()` ）\n\n\n使用方式：\n\n``` js\nexport default {\n  triggerAll(config, to) {\n    console.log(config, 'enter interceptor')\n    to()\n  },\n  triggerMatch: {\n    '/home/pages/categoryList': [\n      (config, to) => {\n        if (/*flag*/) {\n          console.log(1)\n          to()\n        }\n      }\n    ]\n  }\n}\n```\n\n本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的\n\n新建 `interceptor.js`\n\n首先引入之前的路由方便在实例上调用，定义 `triggerMatch` 的对象存储存入的函数 `key` 为当前路由的路径，`value` 为 中间件函数组成的数组\n\n关键： 将 `push` 方法当做单独的一个中间件并放在所有中间件的最后执行\n\n``` js\n  // 引入\n  import router from './index.js'\n  // 挂载\n  Vue.use(router)\n  // 存匹配指定路由的业务函数\n  let matchMiddlewares = {}\n\n```\n接下来要构建一个处理推入规则的业务函数（中间件）的 `compose` 函数\n\n这个函数的作用主要分为两个：\n - 依次派发推入拦截器的业务函数\n - 控制下一次派发的开始\n\n``` js\n  const compose = middlewares => (...args) => {\n    function dispatch(i) {\n      return !middlewares[i]\n        ? Promise.resolve('no arguments')\n        : Promise.resolve(\n            middlewares[i](...args, function() {\n              // 派发下个调用\n              // 此处即是拦截器中第二个实参 to 方法的函数体\n              // 调动 to() 即开启下一次派发\n              return dispatch(++i)\n            })\n          )\n    }\n    // 开启调用\n    return dispatch(0)\n  }\n```\n\n创建一个函数 `getMatchMiddlewares` 用来根据指定键值读取 `matchMiddlewares` 中中间件函数数组\n\n```js\n  function getMatchMiddlewares(path) {\n    return matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []\n  }\n```\n\n\n路由同样使用 `Vue.use` 方法注册，这里导出 `install` 方法, 在里面统一所有中间件函数\n\n``` js\n  // 包装 push\n  let $push\n\n  function pushMiddware(...args) {\n    $push(...args)\n  }\n\n  export default {\n    install(Vue, { triggerAll, triggerMatch }) {\n      // 存储原 push 函数\n      $push = Vue.prototype.$router.push\n      // 接收传入的匹配函数\n      matchMiddlewares = Object.assign({}, triggerMatch)\n      \n      // 重新赋值\n      Vue.prototype.$router.push = (...args) => {\n        // 合并\n        compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(\n          ...args\n        )\n      }\n    }\n  }\n\n\n```\n\n之后在入口文件中引入即可\n\n``` js\n  import Vue from 'vue'\n  import interceptor from './interceptor.js'\n\n  Vue.use(interceptor)\n```\n\n至此便完成了路由的所有功能的基本封装\n\n详细代码可以查看 [小程序路由](http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router)\n\n此篇文章已经发布在 [http://doc.yupaopao.com](http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857)\n\n## 总结\n路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步\n\n## 最后\npo一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：\n\n![比心小程序](https://yphoto.eryufm.cn/gh_3192acdd1484_258.jpg)","slug":"writeSomething/appletRouter","published":1,"updated":"2019-03-07T02:49:40.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt2pem1a0009f748mwhodoks","content":"<p>基于 <code>mpvue</code> 小程序的路由封装</p>\n<a id=\"more\"></a>\n<p>[toc]</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>组件内使用方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/home/page/index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/home/page/index'</span>,</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reLaunch: <span class=\"literal\">true</span>, <span class=\"comment\">// 调用wx.reLaunch</span></span><br><span class=\"line\">  isTab: <span class=\"literal\">true</span> <span class=\"comment\">// 调用wx.switchTag</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取当前页面路由参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; query &#125; = <span class=\"keyword\">this</span>.$route</span><br></pre></td></tr></table></figure></p>\n<p>组件外部使用只需要引入router.js内部导出的push方法即可</p>\n<h2 id=\"封装起步\"><a href=\"#封装起步\" class=\"headerlink\" title=\"封装起步\"></a>封装起步</h2><p>分为两点切入：</p>\n<ol>\n<li>了解微信提供的api</li>\n<li>自己的需求</li>\n</ol>\n<p>总结为以下几点：</p>\n<ul>\n<li><p>对微信小程序的 <code>switchTab、reLaunch、navigateTo、redirectTo</code> 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 <code>this.$router.push</code> 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 <code>this.$route.query</code> 读取。</p>\n</li>\n<li><p>路由默认跳转为 <code>wx.navigateTo</code> 静态跳转，调用其他跳转方式需传递相应参数</p>\n</li>\n</ul>\n<ul>\n<li>封装的跳转优先级：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.switchTab &gt;&gt; wx.reLaunch &gt;&gt; wx.navigateTo</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>路由拥有拦截器，分为全局拦截和针对指定页面根据 <code>path</code> 拦截。</li>\n</ul>\n<p><em>注意： 路由不支持指定 <code>wx.redireactTo</code> 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）</em></p>\n<p>下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题</p>\n<h3 id=\"如何完成基本跳转功能\"><a href=\"#如何完成基本跳转功能\" class=\"headerlink\" title=\"如何完成基本跳转功能\"></a>如何完成基本跳转功能</h3><p><em>需求：页面内使用 <code>this.$router.push</code> 方法跳转页面</em></p>\n<p>首先就是新建 <code>index.js</code> 自定义一个最基本的 <code>push</code> 方法用来跳转页面</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; <span class=\"attr\">url</span>: location.path &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后为了让我们可以在页面中使用这个方法需要将 <code>push</code> 方法挂载在页面的实例上, 同时使用插件式调用在 <code>index.js</code> 文件中导出 <code>install</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">      mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">      push</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义描述符getter（也可直接赋值value）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">      get() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载 (各凭喜好也可以直接赋值在prototype上）</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$router'</span>, $router)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在项目入口文件注入上面 <code>index.js</code> 文件并执行 <code>Vue.use</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(router)</span><br></pre></td></tr></table></figure>\n<p>即可在任意页面使用 <code>this.$router.push</code> 方法并传入相应跳转方式和路径</p>\n<p>这里存在一个问题： 项目跳转为了更美观主要使用 <code>wx.navigateTo</code>， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释</p>\n<h3 id=\"页面之间如何读写参数\"><a href=\"#页面之间如何读写参数\" class=\"headerlink\" title=\"页面之间如何读写参数\"></a>页面之间如何读写参数</h3><p><em>需求： 页面内跳转通过路由参数 <code>query</code> 字段传参， 通过 <code>this.$route.query</code> 读取参数</em></p>\n<p>所以我们需要一个能够简单解析 <code>push</code> 方法参数的功能型函数 <code>parseUrl</code>，里面包括将所传的 <code>query</code> 字段以地址栏参数形式拼接在 <code>path</code> 后面的一个 <code>stringifyQuery</code> 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseUrl</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query &#125; = location</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queryStr = stringifyQuery(query)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;path&#125;</span><span class=\"subst\">$&#123;queryStr&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringifyQuery</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = obj</span><br><span class=\"line\">    ? <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">        .filter(<span class=\"built_in\">Boolean</span>)</span><br><span class=\"line\">        .map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> val = obj[key]</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ([<span class=\"built_in\">Array</span>, <span class=\"built_in\">Object</span>].includes(val.constructor)) &#123;</span><br><span class=\"line\">            val = <span class=\"built_in\">JSON</span>.stringify(obj[key])</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;val&#125;</span>`</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        .join(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? <span class=\"string\">`?<span class=\"subst\">$&#123;res&#125;</span>`</span> : <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 <code>parseUrl</code> 方法添加到上面的 <code>push</code> 方法，同时参数内部是支持小程序路由跳转过程的<code>success</code>, <code>fail</code>, <code>complete</code> 钩子的 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// others 为用户可能传递的 `success`, `fail`, `complete`</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query, ...others &#125; = location</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(&#123; path, query &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, ...others &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 <code>$route</code> 对象与前面的 <code>$router</code> 一致挂载页面实例上</p>\n<p>这一层读mpvue的实例创建一个 <code>parseRoute</code> 函数简单处理一下数据即可</p>\n<p>此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0<br>以下同时简单处理一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseRoute</span>(<span class=\"params\">$mp</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $mp 为mpvue实例root上挂载的对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _mp = $mp || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = _mp.page &amp;&amp; _mp.page.route</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parseQuery = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tempQuery = _mp.query</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> tempQuery) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cur = tempQuery[k]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 解决长整型丢失精度</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> transfer = <span class=\"built_in\">JSON</span>.parse(tempQuery[k])</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(<span class=\"keyword\">typeof</span> transfer === <span class=\"string\">'number'</span>)) &#123;</span><br><span class=\"line\">        cur = transfer</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parseQuery[k] = cur</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    parseQuery</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 <code>onShow</code> 钩子上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _route = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.mixin(&#123;</span><br><span class=\"line\">  onShow() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; $mp &#125; = <span class=\"keyword\">this</span>.$root</span><br><span class=\"line\"></span><br><span class=\"line\">    _route = parseRoute($mp)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $route = &#123;</span><br><span class=\"line\">  get() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _route</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$route'</span>, $route)</span><br></pre></td></tr></table></figure>\n<p>以上便完成路由参数的读写</p>\n<h3 id=\"解决上面提出的小程序堆栈限制问题\"><a href=\"#解决上面提出的小程序堆栈限制问题\" class=\"headerlink\" title=\"解决上面提出的小程序堆栈限制问题\"></a>解决上面提出的小程序堆栈限制问题</h3><p>小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 <code>wx.redirectTo</code> 即可（其他时间项目中仅使用 <code>navigateTo</code> 即可）</p>\n<p>首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 <code>push</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前页面堆栈长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pageStackLen = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 堆栈限制</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxStackLen = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location, success, ...ohters</span>) </span>&#123;</span><br><span class=\"line\">  pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 包装跳转成功的回调</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _success = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    success &amp;&amp; success()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, <span class=\"attr\">success</span>: _success, ...ohters&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pageStackLen &gt;= maxStackLen) &#123;</span><br><span class=\"line\">      wx.redirectTo(params)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上基本解决小程序堆栈限制问题</p>\n<h3 id=\"完善路由跳转功能\"><a href=\"#完善路由跳转功能\" class=\"headerlink\" title=\"完善路由跳转功能\"></a>完善路由跳转功能</h3><p>现在对路由的跳转做一些基本辅助功能的支持 <code>go</code>、 <code>back</code>, <code>replace</code> 等方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">location, ...others</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  wx.redirectTo(&#123;</span><br><span class=\"line\">    url,</span><br><span class=\"line\">    ...others</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">delta</span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack(&#123;</span><br><span class=\"line\">    delta</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">back</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这些挂到 <code>$router</code> 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">  push,</span><br><span class=\"line\">  replace,</span><br><span class=\"line\">  go,</span><br><span class=\"line\">  back</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">  get() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 <code>push</code> 方法方便组件外部调用等优化</p>\n<p>最后我们还差路由拦截器功能的实现</p>\n<h3 id=\"路由拦截器\"><a href=\"#路由拦截器\" class=\"headerlink\" title=\"路由拦截器\"></a>路由拦截器</h3><p>需求： 对象形式配置自己路由规则</p>\n<ul>\n<li><code>[triggerAll]</code>： 所有路由跳转均会触发</li>\n<li><code>[triggerMatch]</code>： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发</li>\n</ul>\n<p>参数介绍：</p>\n<ul>\n<li><code>config</code>: 携带当前路由跳转信息（路由参数）</li>\n<li><code>to</code>: 控制跳转（调用 <code>to()</code> ）</li>\n</ul>\n<p>使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  triggerAll(config, to) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(config, <span class=\"string\">'enter interceptor'</span>)</span><br><span class=\"line\">    to()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  triggerMatch: &#123;</span><br><span class=\"line\">    <span class=\"string\">'/home/pages/categoryList'</span>: [</span><br><span class=\"line\">      (config, to) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*flag*/</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">          to()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的</p>\n<p>新建 <code>interceptor.js</code></p>\n<p>首先引入之前的路由方便在实例上调用，定义 <code>triggerMatch</code> 的对象存储存入的函数 <code>key</code> 为当前路由的路径，<code>value</code> 为 中间件函数组成的数组</p>\n<p>关键： 将 <code>push</code> 方法当做单独的一个中间件并放在所有中间件的最后执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 挂载</span></span><br><span class=\"line\">Vue.use(router)</span><br><span class=\"line\"><span class=\"comment\">// 存匹配指定路由的业务函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> matchMiddlewares = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来要构建一个处理推入规则的业务函数（中间件）的 <code>compose</code> 函数</p>\n<p>这个函数的作用主要分为两个：</p>\n<ul>\n<li>依次派发推入拦截器的业务函数</li>\n<li>控制下一次派发的开始</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !middlewares[i]</span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'no arguments'</span>)</span><br><span class=\"line\">      : <span class=\"built_in\">Promise</span>.resolve(</span><br><span class=\"line\">          middlewares[i](...args, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 派发下个调用</span></span><br><span class=\"line\">            <span class=\"comment\">// 此处即是拦截器中第二个实参 to 方法的函数体</span></span><br><span class=\"line\">            <span class=\"comment\">// 调动 to() 即开启下一次派发</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatch(++i)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 开启调用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个函数 <code>getMatchMiddlewares</code> 用来根据指定键值读取 <code>matchMiddlewares</code> 中中间件函数数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMatchMiddlewares</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路由同样使用 <code>Vue.use</code> 方法注册，这里导出 <code>install</code> 方法, 在里面统一所有中间件函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包装 push</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> $push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushMiddware</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  $push(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue, &#123; triggerAll, triggerMatch &#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储原 push 函数</span></span><br><span class=\"line\">    $push = Vue.prototype.$router.push</span><br><span class=\"line\">    <span class=\"comment\">// 接收传入的匹配函数</span></span><br><span class=\"line\">    matchMiddlewares = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, triggerMatch)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">    Vue.prototype.$router.push = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 合并</span></span><br><span class=\"line\">      compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(</span><br><span class=\"line\">        ...args</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后在入口文件中引入即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> interceptor <span class=\"keyword\">from</span> <span class=\"string\">'./interceptor.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(interceptor)</span><br></pre></td></tr></table></figure>\n<p>至此便完成了路由的所有功能的基本封装</p>\n<p>详细代码可以查看 <a href=\"http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router\" target=\"_blank\" rel=\"noopener\">小程序路由</a></p>\n<p>此篇文章已经发布在 <a href=\"http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857\" target=\"_blank\" rel=\"noopener\">http://doc.yupaopao.com</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>po一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：</p>\n<p><img src=\"https://yphoto.eryufm.cn/gh_3192acdd1484_258.jpg\" alt=\"比心小程序\"></p>\n","site":{"data":{}},"excerpt":"<p>基于 <code>mpvue</code> 小程序的路由封装</p>","more":"<p>[toc]</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>组件内使用方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/home/page/index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 携带路由参数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/home/page/index'</span>,</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reLaunch: <span class=\"literal\">true</span>, <span class=\"comment\">// 调用wx.reLaunch</span></span><br><span class=\"line\">  isTab: <span class=\"literal\">true</span> <span class=\"comment\">// 调用wx.switchTag</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取当前页面路由参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; query &#125; = <span class=\"keyword\">this</span>.$route</span><br></pre></td></tr></table></figure></p>\n<p>组件外部使用只需要引入router.js内部导出的push方法即可</p>\n<h2 id=\"封装起步\"><a href=\"#封装起步\" class=\"headerlink\" title=\"封装起步\"></a>封装起步</h2><p>分为两点切入：</p>\n<ol>\n<li>了解微信提供的api</li>\n<li>自己的需求</li>\n</ol>\n<p>总结为以下几点：</p>\n<ul>\n<li><p>对微信小程序的 <code>switchTab、reLaunch、navigateTo、redirectTo</code> 二次封装，对外暴露push方法，同时将路由实例挂载在vue上，组件内部通过 <code>this.$router.push</code> 调用，组件外部可使用对外暴露的push方法进行页面跳转。页面内数据通过路由参数传递通过 <code>this.$route.query</code> 读取。</p>\n</li>\n<li><p>路由默认跳转为 <code>wx.navigateTo</code> 静态跳转，调用其他跳转方式需传递相应参数</p>\n</li>\n</ul>\n<ul>\n<li>封装的跳转优先级：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.switchTab &gt;&gt; wx.reLaunch &gt;&gt; wx.navigateTo</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>路由拥有拦截器，分为全局拦截和针对指定页面根据 <code>path</code> 拦截。</li>\n</ul>\n<p><em>注意： 路由不支持指定 <code>wx.redireactTo</code> 跳转，此方法用于路由内部处理小程序堆栈溢出（当前小程序静态页面堆栈仅支持十层）</em></p>\n<p>下面我会由不同的需求以问答方式一步步完成整个路由的简单封装同时讲述各个部分可能遇到的问题</p>\n<h3 id=\"如何完成基本跳转功能\"><a href=\"#如何完成基本跳转功能\" class=\"headerlink\" title=\"如何完成基本跳转功能\"></a>如何完成基本跳转功能</h3><p><em>需求：页面内使用 <code>this.$router.push</code> 方法跳转页面</em></p>\n<p>首先就是新建 <code>index.js</code> 自定义一个最基本的 <code>push</code> 方法用来跳转页面</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; <span class=\"attr\">url</span>: location.path &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后为了让我们可以在页面中使用这个方法需要将 <code>push</code> 方法挂载在页面的实例上, 同时使用插件式调用在 <code>index.js</code> 文件中导出 <code>install</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">      mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">      push</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义描述符getter（也可直接赋值value）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">      get() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 挂载 (各凭喜好也可以直接赋值在prototype上）</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$router'</span>, $router)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来在项目入口文件注入上面 <code>index.js</code> 文件并执行 <code>Vue.use</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(router)</span><br></pre></td></tr></table></figure>\n<p>即可在任意页面使用 <code>this.$router.push</code> 方法并传入相应跳转方式和路径</p>\n<p>这里存在一个问题： 项目跳转为了更美观主要使用 <code>wx.navigateTo</code>， 而微信小程序最大页面堆栈只支持10层，所以说项目中如果页面跳转极多或者存在相互关联的页面互相跳转便容易导致堆栈溢出页面不跳转的情况，这个问题在完成路由基本功能后单独解释</p>\n<h3 id=\"页面之间如何读写参数\"><a href=\"#页面之间如何读写参数\" class=\"headerlink\" title=\"页面之间如何读写参数\"></a>页面之间如何读写参数</h3><p><em>需求： 页面内跳转通过路由参数 <code>query</code> 字段传参， 通过 <code>this.$route.query</code> 读取参数</em></p>\n<p>所以我们需要一个能够简单解析 <code>push</code> 方法参数的功能型函数 <code>parseUrl</code>，里面包括将所传的 <code>query</code> 字段以地址栏参数形式拼接在 <code>path</code> 后面的一个 <code>stringifyQuery</code> 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseUrl</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query &#125; = location</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queryStr = stringifyQuery(query)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;path&#125;</span><span class=\"subst\">$&#123;queryStr&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringifyQuery</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = obj</span><br><span class=\"line\">    ? <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">        .filter(<span class=\"built_in\">Boolean</span>)</span><br><span class=\"line\">        .map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> val = obj[key]</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ([<span class=\"built_in\">Array</span>, <span class=\"built_in\">Object</span>].includes(val.constructor)) &#123;</span><br><span class=\"line\">            val = <span class=\"built_in\">JSON</span>.stringify(obj[key])</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;val&#125;</span>`</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        .join(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? <span class=\"string\">`?<span class=\"subst\">$&#123;res&#125;</span>`</span> : <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 <code>parseUrl</code> 方法添加到上面的 <code>push</code> 方法，同时参数内部是支持小程序路由跳转过程的<code>success</code>, <code>fail</code>, <code>complete</code> 钩子的 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// location 为路由传参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// others 为用户可能传递的 `success`, `fail`, `complete`</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; path, query, ...others &#125; = location</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(&#123; path, query &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, ...others &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.redirect) &#123;</span><br><span class=\"line\">    wx.redirectTo(params)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上路由传参并解析部分已经完成，接下来读取参数的控制需要定义一个 <code>$route</code> 对象与前面的 <code>$router</code> 一致挂载页面实例上</p>\n<p>这一层读mpvue的实例创建一个 <code>parseRoute</code> 函数简单处理一下数据即可</p>\n<p>此处遇到一个问题： 之前只是使用JSON.parse简单处理一下数据，当数据为长整型字符串（长度超过17位）会丢失精度转0<br>以下同时简单处理一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseRoute</span>(<span class=\"params\">$mp</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $mp 为mpvue实例root上挂载的对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _mp = $mp || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = _mp.page &amp;&amp; _mp.page.route</span><br><span class=\"line\">  <span class=\"keyword\">const</span> parseQuery = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tempQuery = _mp.query</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> tempQuery) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cur = tempQuery[k]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 解决长整型丢失精度</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> transfer = <span class=\"built_in\">JSON</span>.parse(tempQuery[k])</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(<span class=\"keyword\">typeof</span> transfer === <span class=\"string\">'number'</span>)) &#123;</span><br><span class=\"line\">        cur = transfer</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parseQuery[k] = cur</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    parseQuery</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终挂载在页面实例上，由于路由参数每次跳转都要更新所以挂载在小程序 <code>onShow</code> 钩子上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _route = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.mixin(&#123;</span><br><span class=\"line\">  onShow() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; $mp &#125; = <span class=\"keyword\">this</span>.$root</span><br><span class=\"line\"></span><br><span class=\"line\">    _route = parseRoute($mp)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $route = &#123;</span><br><span class=\"line\">  get() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _route</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Vue.prototype, <span class=\"string\">'$route'</span>, $route)</span><br></pre></td></tr></table></figure>\n<p>以上便完成路由参数的读写</p>\n<h3 id=\"解决上面提出的小程序堆栈限制问题\"><a href=\"#解决上面提出的小程序堆栈限制问题\" class=\"headerlink\" title=\"解决上面提出的小程序堆栈限制问题\"></a>解决上面提出的小程序堆栈限制问题</h3><p>小程序的基本功能已经实现了，下面就是堆栈的限制，解决办法也很简单，只需要跳转前监听当前堆栈的长度，栈满时改用重定向方法 <code>wx.redirectTo</code> 即可（其他时间项目中仅使用 <code>navigateTo</code> 即可）</p>\n<p>首先需要一个全局变量记录堆栈长度(微信提供一个getCurrentPages的方法)， 同时更改 <code>push</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前页面堆栈长度</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pageStackLen = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 堆栈限制</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxStackLen = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">location, success, ...ohters</span>) </span>&#123;</span><br><span class=\"line\">  pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 包装跳转成功的回调</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _success = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pageStackLen = getCurrentPages().length + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    success &amp;&amp; success()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123; url, <span class=\"attr\">success</span>: _success, ...ohters&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (location.isTab) &#123;</span><br><span class=\"line\">    wx.switchTab(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (location.reLaunch) &#123;</span><br><span class=\"line\">    wx.reLaunch(params)</span><br><span class=\"line\"></span><br><span class=\"line\">    pageStackLen = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pageStackLen &gt;= maxStackLen) &#123;</span><br><span class=\"line\">      wx.redirectTo(params)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wx.navigateTo(params)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上基本解决小程序堆栈限制问题</p>\n<h3 id=\"完善路由跳转功能\"><a href=\"#完善路由跳转功能\" class=\"headerlink\" title=\"完善路由跳转功能\"></a>完善路由跳转功能</h3><p>现在对路由的跳转做一些基本辅助功能的支持 <code>go</code>、 <code>back</code>, <code>replace</code> 等方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">location, ...others</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = parseUrl(location)</span><br><span class=\"line\"></span><br><span class=\"line\">  wx.redirectTo(&#123;</span><br><span class=\"line\">    url,</span><br><span class=\"line\">    ...others</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">delta</span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack(&#123;</span><br><span class=\"line\">    delta</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">back</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.navigateBack()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这些挂到 <code>$router</code> 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _router = &#123;</span><br><span class=\"line\">  mode: <span class=\"string\">'history'</span>,</span><br><span class=\"line\">  push,</span><br><span class=\"line\">  replace,</span><br><span class=\"line\">  go,</span><br><span class=\"line\">  back</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> $router = &#123;</span><br><span class=\"line\">  get() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _router</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有我们不需要页面之间传参时时push方法直接传字符串路径，路由公用路径省略，push调用传基本路径自动补齐, 单独导出 <code>push</code> 方法方便组件外部调用等优化</p>\n<p>最后我们还差路由拦截器功能的实现</p>\n<h3 id=\"路由拦截器\"><a href=\"#路由拦截器\" class=\"headerlink\" title=\"路由拦截器\"></a>路由拦截器</h3><p>需求： 对象形式配置自己路由规则</p>\n<ul>\n<li><code>[triggerAll]</code>： 所有路由跳转均会触发</li>\n<li><code>[triggerMatch]</code>： 匹配指定路由，其中可配置多个规则，以函数数组形式传入，数组中所有函数都会在被匹配时触发</li>\n</ul>\n<p>参数介绍：</p>\n<ul>\n<li><code>config</code>: 携带当前路由跳转信息（路由参数）</li>\n<li><code>to</code>: 控制跳转（调用 <code>to()</code> ）</li>\n</ul>\n<p>使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  triggerAll(config, to) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(config, <span class=\"string\">'enter interceptor'</span>)</span><br><span class=\"line\">    to()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  triggerMatch: &#123;</span><br><span class=\"line\">    <span class=\"string\">'/home/pages/categoryList'</span>: [</span><br><span class=\"line\">      (config, to) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*flag*/</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">          to()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本质上还是将之前封装的路由暴露出来的push方法再次封装一层，其中加入自己的逻辑达到目的</p>\n<p>新建 <code>interceptor.js</code></p>\n<p>首先引入之前的路由方便在实例上调用，定义 <code>triggerMatch</code> 的对象存储存入的函数 <code>key</code> 为当前路由的路径，<code>value</code> 为 中间件函数组成的数组</p>\n<p>关键： 将 <code>push</code> 方法当做单独的一个中间件并放在所有中间件的最后执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 挂载</span></span><br><span class=\"line\">Vue.use(router)</span><br><span class=\"line\"><span class=\"comment\">// 存匹配指定路由的业务函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> matchMiddlewares = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来要构建一个处理推入规则的业务函数（中间件）的 <code>compose</code> 函数</p>\n<p>这个函数的作用主要分为两个：</p>\n<ul>\n<li>依次派发推入拦截器的业务函数</li>\n<li>控制下一次派发的开始</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !middlewares[i]</span><br><span class=\"line\">      ? <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'no arguments'</span>)</span><br><span class=\"line\">      : <span class=\"built_in\">Promise</span>.resolve(</span><br><span class=\"line\">          middlewares[i](...args, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 派发下个调用</span></span><br><span class=\"line\">            <span class=\"comment\">// 此处即是拦截器中第二个实参 to 方法的函数体</span></span><br><span class=\"line\">            <span class=\"comment\">// 调动 to() 即开启下一次派发</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatch(++i)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 开启调用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个函数 <code>getMatchMiddlewares</code> 用来根据指定键值读取 <code>matchMiddlewares</code> 中中间件函数数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMatchMiddlewares</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> matchMiddlewares.hasOwnProperty(path) ? matchMiddlewares[path] : []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路由同样使用 <code>Vue.use</code> 方法注册，这里导出 <code>install</code> 方法, 在里面统一所有中间件函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 包装 push</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> $push</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushMiddware</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  $push(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  install(Vue, &#123; triggerAll, triggerMatch &#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储原 push 函数</span></span><br><span class=\"line\">    $push = Vue.prototype.$router.push</span><br><span class=\"line\">    <span class=\"comment\">// 接收传入的匹配函数</span></span><br><span class=\"line\">    matchMiddlewares = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, triggerMatch)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">    Vue.prototype.$router.push = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 合并</span></span><br><span class=\"line\">      compose([...getMatchMiddlewares(path), triggerAll, pushMiddware])(</span><br><span class=\"line\">        ...args</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后在入口文件中引入即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> interceptor <span class=\"keyword\">from</span> <span class=\"string\">'./interceptor.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(interceptor)</span><br></pre></td></tr></table></figure>\n<p>至此便完成了路由的所有功能的基本封装</p>\n<p>详细代码可以查看 <a href=\"http://git.yupaopao.com/fe/applet/iverson/tree/master/src/global/lib/router\" target=\"_blank\" rel=\"noopener\">小程序路由</a></p>\n<p>此篇文章已经发布在 <a href=\"http://doc.yupaopao.com/pages/viewpage.action?pageId=7176857\" target=\"_blank\" rel=\"noopener\">http://doc.yupaopao.com</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>路由基本功能的封装基本至此已经全部完成，基本满足日常开发需要。但由于自身水平限制，会存在各类问题，希望大家指出一起讨论，共同进步</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>po一下前端生涯的完成的第一个小程序的码，使用美团的mpvue：</p>\n<p><img src=\"https://yphoto.eryufm.cn/gh_3192acdd1484_258.jpg\" alt=\"比心小程序\"></p>"},{"title":"JS/Node的事件循环","date":"2019-03-07T03:21:00.000Z","_content":"\nJS特色之一是单线程，那所谓的基于事件的异步机制是什么？\n<!--more-->\n# JS是单线程\nAll we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8\n另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因\n\n另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步\n\n那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列\n\n# JS事件循环\n类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数\n\n一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行\n\n在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中\n\n每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环\n\n### 宏任务（Macrotask）\n- 整体代码(script)\n- setTimeout\n- setInterval\n- setImmediate（node）\n- I/O\n- UI rendering\n- requestAnimationFrame（浏览器）\n\n### 微任务（Microtask）\n- process.nextTick（node）\n- Promise.then catch finally\n- Object.observe（已废弃）\n- MutationObserver（浏览器）\n\n*括号内表示支持的环境*\n\n### 案例分析\n```js\n// 全局scripts macrotask\nconsole.log('macrotask scripts start')\n\n// macrotask\nsetTimeout(() => {\n  Promise.resolve().then(() => console.log('macrotask 1 inner: microtask'))\n\n  console.log('macrotask 1')\n}, 0)\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 1'))\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 2'))\n\nconsole.log('macrotask scripts end')\n\n// output:\n\n// VM322:1  macrotask scripts start\n// VM322:16 macrotask scripts end\n// VM322:11 microtask 1\n// VM322:14 microtask 2\n// VM322:7  macrotask 1\n// VM322:5  macrotask 1 inner: microtask\n```\n\n首先进入 **全局scripts macrotask**\n  - 执行当前 macrotask 中所有同步代码\n    - // VM322:1  macrotask scripts start\n    - // VM322:16 macrotask scripts end\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:11 microtask 1\n    - // VM322:14 microtask 2\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n  - 新一轮循环执行当前 macrotask 中所有同步代码\n    - // VM322:7  macrotask 1\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:5  macrotask 1 inner: microtask\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n    - 执行完毕结束循环\n\n### 误解\n面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”\n\n- 一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列\n- 键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列\n- setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队\n- ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队\n\n# Node的事件循环\nnode是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行\n\n当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环\n\n与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：\n- timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调\n  * 检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调\n  * 检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- idle, prepare：仅系统内部使用\n- Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒\n首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。\n  * 第一种情况：\n    - 如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调\n    - 检查是否有 process.nextTick 回调，如果有，全部执行\n    - 检查是否有 microtaks，如果有，全部执行\n    - 退出该阶段\n  * 第二种情况：\n    - 如果没有可用回调\n    - 检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知\n    - 如果不存在尚未完成的回调，退出poll阶段\n- Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 check 阶段\n- Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on('close', ...). 用于资源清理\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 closing 阶段\n一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序\n\n事件循环过程如下图示意*每个框内代表一个阶段*：\n\n```js\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n```\n每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段\n\n由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值\n\n在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净\n\n补充：\n1. setImmediate 对比 setTimeout\nsetImmediate 和 setTimeout 很类似，但何时调用行为完全不同\n  - setImmediate 设计为在当前 轮询 阶段完成后执行脚本\n  - setTimeout 计划在毫秒的最小阈值经过后运行的脚本\n执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）\n\n2. process.nextTick\nprocess.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码\n任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段\n\n以上简要介绍JS/Node的事件循环，存在相关错误请指出😄\n\nLink：\n  - [The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)\n  - [深入分析Node.js事件循环](https://blog.csdn.net/i10630226/article/details/81369841)\n\n**end**\n","source":"_posts/writeSomething/EventLoop.md","raw":"---\ntitle: JS/Node的事件循环\ntags:\n  - 事件循环\n  - 任务队列\ndate: 2019-03-07 11:21:00\ncategories: 你应该知道的\n---\n\nJS特色之一是单线程，那所谓的基于事件的异步机制是什么？\n<!--more-->\n# JS是单线程\nAll we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8\n另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因\n\n另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步\n\n那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列\n\n# JS事件循环\n类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数\n\n一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行\n\n在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中\n\n每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环\n\n### 宏任务（Macrotask）\n- 整体代码(script)\n- setTimeout\n- setInterval\n- setImmediate（node）\n- I/O\n- UI rendering\n- requestAnimationFrame（浏览器）\n\n### 微任务（Microtask）\n- process.nextTick（node）\n- Promise.then catch finally\n- Object.observe（已废弃）\n- MutationObserver（浏览器）\n\n*括号内表示支持的环境*\n\n### 案例分析\n```js\n// 全局scripts macrotask\nconsole.log('macrotask scripts start')\n\n// macrotask\nsetTimeout(() => {\n  Promise.resolve().then(() => console.log('macrotask 1 inner: microtask'))\n\n  console.log('macrotask 1')\n}, 0)\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 1'))\n\n// microtask\nPromise.resolve().then(() => console.log('microtask 2'))\n\nconsole.log('macrotask scripts end')\n\n// output:\n\n// VM322:1  macrotask scripts start\n// VM322:16 macrotask scripts end\n// VM322:11 microtask 1\n// VM322:14 microtask 2\n// VM322:7  macrotask 1\n// VM322:5  macrotask 1 inner: microtask\n```\n\n首先进入 **全局scripts macrotask**\n  - 执行当前 macrotask 中所有同步代码\n    - // VM322:1  macrotask scripts start\n    - // VM322:16 macrotask scripts end\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:11 microtask 1\n    - // VM322:14 microtask 2\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n  - 新一轮循环执行当前 macrotask 中所有同步代码\n    - // VM322:7  macrotask 1\n  - 执行完毕后按先进先出的顺序执行 microtask 队列\n    - // VM322:5  macrotask 1 inner: microtask\n  - 当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环\n    - 执行完毕结束循环\n\n### 误解\n面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”\n\n- 一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列\n- 键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列\n- setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队\n- ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队\n\n# Node的事件循环\nnode是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行\n\n当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环\n\n与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：\n- timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调\n  * 检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调\n  * 检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段\n  * 检查是否有 process.nextTick 任务，如果有，全部执行\n  * 检查是否有microtask，如果有，全部执行\n  * 退出该阶段\n- idle, prepare：仅系统内部使用\n- Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒\n首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。\n  * 第一种情况：\n    - 如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调\n    - 检查是否有 process.nextTick 回调，如果有，全部执行\n    - 检查是否有 microtaks，如果有，全部执行\n    - 退出该阶段\n  * 第二种情况：\n    - 如果没有可用回调\n    - 检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知\n    - 如果不存在尚未完成的回调，退出poll阶段\n- Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 check 阶段\n- Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on('close', ...). 用于资源清理\n  * 如果有immediate回调，则执行所有immediate回调\n  * 检查是否有 process.nextTick 回调，如果有，全部执行\n  * 检查是否有 microtaks，如果有，全部执行\n  * 退出 closing 阶段\n一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序\n\n事件循环过程如下图示意*每个框内代表一个阶段*：\n\n```js\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n```\n每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段\n\n由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值\n\n在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净\n\n补充：\n1. setImmediate 对比 setTimeout\nsetImmediate 和 setTimeout 很类似，但何时调用行为完全不同\n  - setImmediate 设计为在当前 轮询 阶段完成后执行脚本\n  - setTimeout 计划在毫秒的最小阈值经过后运行的脚本\n执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）\n\n2. process.nextTick\nprocess.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码\n任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段\n\n以上简要介绍JS/Node的事件循环，存在相关错误请指出😄\n\nLink：\n  - [The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)\n  - [深入分析Node.js事件循环](https://blog.csdn.net/i10630226/article/details/81369841)\n\n**end**\n","slug":"writeSomething/EventLoop","published":1,"updated":"2019-03-07T08:55:50.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt2pem1c000df748vbjgvecp","content":"<p>JS特色之一是单线程，那所谓的基于事件的异步机制是什么？<br><a id=\"more\"></a></p>\n<h1 id=\"JS是单线程\"><a href=\"#JS是单线程\" class=\"headerlink\" title=\"JS是单线程\"></a>JS是单线程</h1><p>All we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8<br>另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因</p>\n<p>另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步</p>\n<p>那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列</p>\n<h1 id=\"JS事件循环\"><a href=\"#JS事件循环\" class=\"headerlink\" title=\"JS事件循环\"></a>JS事件循环</h1><p>类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数</p>\n<p>一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行</p>\n<p>在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中</p>\n<p>每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环</p>\n<h3 id=\"宏任务（Macrotask）\"><a href=\"#宏任务（Macrotask）\" class=\"headerlink\" title=\"宏任务（Macrotask）\"></a>宏任务（Macrotask）</h3><ul>\n<li>整体代码(script)</li>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate（node）</li>\n<li>I/O</li>\n<li>UI rendering</li>\n<li>requestAnimationFrame（浏览器）</li>\n</ul>\n<h3 id=\"微任务（Microtask）\"><a href=\"#微任务（Microtask）\" class=\"headerlink\" title=\"微任务（Microtask）\"></a>微任务（Microtask）</h3><ul>\n<li>process.nextTick（node）</li>\n<li>Promise.then catch finally</li>\n<li>Object.observe（已废弃）</li>\n<li>MutationObserver（浏览器）</li>\n</ul>\n<p><em>括号内表示支持的环境</em></p>\n<h3 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局scripts macrotask</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts start'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// macrotask</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1 inner: microtask'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 1'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 2'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts end'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VM322:1  macrotask scripts start</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:16 macrotask scripts end</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:11 microtask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:14 microtask 2</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:7  macrotask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:5  macrotask 1 inner: microtask</span></span><br></pre></td></tr></table></figure>\n<p>首先进入 <strong>全局scripts macrotask</strong></p>\n<ul>\n<li>执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:1  macrotask scripts start</li>\n<li>// VM322:16 macrotask scripts end</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:11 microtask 1</li>\n<li>// VM322:14 microtask 2</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环</li>\n<li>新一轮循环执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:7  macrotask 1</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:5  macrotask 1 inner: microtask</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环<ul>\n<li>执行完毕结束循环</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"误解\"><a href=\"#误解\" class=\"headerlink\" title=\"误解\"></a>误解</h3><p>面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”</p>\n<ul>\n<li>一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列</li>\n<li>键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列</li>\n<li>setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队</li>\n<li>ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队</li>\n</ul>\n<h1 id=\"Node的事件循环\"><a href=\"#Node的事件循环\" class=\"headerlink\" title=\"Node的事件循环\"></a>Node的事件循环</h1><p>node是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行</p>\n<p>当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环</p>\n<p>与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：</p>\n<ul>\n<li>timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调<ul>\n<li>检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调<ul>\n<li>检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>idle, prepare：仅系统内部使用</li>\n<li>Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒<br>首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。<ul>\n<li>第一种情况：<ul>\n<li>如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>第二种情况：<ul>\n<li>如果没有可用回调</li>\n<li>检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知</li>\n<li>如果不存在尚未完成的回调，退出poll阶段</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 check 阶段</li>\n</ul>\n</li>\n<li>Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on(‘close’, …). 用于资源清理<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 closing 阶段<br>一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序</li>\n</ul>\n</li>\n</ul>\n<p>事件循环过程如下图示意<em>每个框内代表一个阶段</em>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   ┌───────────────────────────┐</span><br><span class=\"line\">┌─&gt;│           timers          │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │     pending callbacks     │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │       idle, prepare       │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class=\"line\">│  │           poll            │&lt;─────┤  connections, │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class=\"line\">│  │           check           │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">└──┤      close callbacks      │</span><br><span class=\"line\">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>\n<p>每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段</p>\n<p>由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值</p>\n<p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净</p>\n<p>补充：</p>\n<ol>\n<li><p>setImmediate 对比 setTimeout<br>setImmediate 和 setTimeout 很类似，但何时调用行为完全不同</p>\n<ul>\n<li>setImmediate 设计为在当前 轮询 阶段完成后执行脚本</li>\n<li>setTimeout 计划在毫秒的最小阈值经过后运行的脚本<br>执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）</li>\n</ul>\n</li>\n<li><p>process.nextTick<br>process.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码<br>任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段</p>\n</li>\n</ol>\n<p>以上简要介绍JS/Node的事件循环，存在相关错误请指出😄</p>\n<p>Link：</p>\n<ul>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"noopener\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n<li><a href=\"https://blog.csdn.net/i10630226/article/details/81369841\" target=\"_blank\" rel=\"noopener\">深入分析Node.js事件循环</a></li>\n</ul>\n<p><strong>end</strong></p>\n","site":{"data":{}},"excerpt":"<p>JS特色之一是单线程，那所谓的基于事件的异步机制是什么？<br></p>","more":"<p></p>\n<h1 id=\"JS是单线程\"><a href=\"#JS是单线程\" class=\"headerlink\" title=\"JS是单线程\"></a>JS是单线程</h1><p>All we know, JS是一种动态类型、弱类型、基于原型的脚本语言，浏览器上有着JS专属的引擎作为其解释器，V8<br>另外，JS是单线程语言，为何如此设计呢？其实原因很简单，JS是被用来设计在浏览器中使用，支持操作页面dom元素，假设同时有多个进程同时对同一dom元素进行crud，浏览器如何执行呢？所以这就是原因</p>\n<p>另外JS虽然是单线程运行，但是在主线程运行之外还是有其他的侦听线程作为辅助的如事件触发线程、Http请求线程等，所以JS所谓的单线程并不孤单。浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步</p>\n<p>那单线程却能执行异步任务为何？主要是因为JS中存在事件循环(Event Loop)和任务队列(Task Queue)也叫事件队列</p>\n<h1 id=\"JS事件循环\"><a href=\"#JS事件循环\" class=\"headerlink\" title=\"JS事件循环\"></a>JS事件循环</h1><p>类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数</p>\n<p>一个浏览器环境只能有一个事件循环，而一个事件循环主要包含 macrotask 和 microtask 两个事件队列（macrotask 和 microtask 是异步任务的两种分类），每个任务都有一个任务源（Task source）。同一个任务队列中的任务必须按先进先出的顺序执行</p>\n<p>在挂起任务时，JS 引擎会将所有任务按照类别分到macrotask 和 microtask这两个队列中</p>\n<p>每一次事件循环，只处理一个 macrotask，待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完后开始执行下一个 macrotask 开启新一轮事件循环</p>\n<h3 id=\"宏任务（Macrotask）\"><a href=\"#宏任务（Macrotask）\" class=\"headerlink\" title=\"宏任务（Macrotask）\"></a>宏任务（Macrotask）</h3><ul>\n<li>整体代码(script)</li>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate（node）</li>\n<li>I/O</li>\n<li>UI rendering</li>\n<li>requestAnimationFrame（浏览器）</li>\n</ul>\n<h3 id=\"微任务（Microtask）\"><a href=\"#微任务（Microtask）\" class=\"headerlink\" title=\"微任务（Microtask）\"></a>微任务（Microtask）</h3><ul>\n<li>process.nextTick（node）</li>\n<li>Promise.then catch finally</li>\n<li>Object.observe（已废弃）</li>\n<li>MutationObserver（浏览器）</li>\n</ul>\n<p><em>括号内表示支持的环境</em></p>\n<h3 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局scripts macrotask</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts start'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// macrotask</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1 inner: microtask'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask 1'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 1'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// microtask</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'microtask 2'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'macrotask scripts end'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VM322:1  macrotask scripts start</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:16 macrotask scripts end</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:11 microtask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:14 microtask 2</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:7  macrotask 1</span></span><br><span class=\"line\"><span class=\"comment\">// VM322:5  macrotask 1 inner: microtask</span></span><br></pre></td></tr></table></figure>\n<p>首先进入 <strong>全局scripts macrotask</strong></p>\n<ul>\n<li>执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:1  macrotask scripts start</li>\n<li>// VM322:16 macrotask scripts end</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:11 microtask 1</li>\n<li>// VM322:14 microtask 2</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环</li>\n<li>新一轮循环执行当前 macrotask 中所有同步代码<ul>\n<li>// VM322:7  macrotask 1</li>\n</ul>\n</li>\n<li>执行完毕后按先进先出的顺序执行 microtask 队列<ul>\n<li>// VM322:5  macrotask 1 inner: microtask</li>\n</ul>\n</li>\n<li>当前 macrotask 执行完毕查找当前 macrotask 队列，若已经清空则结束事件循环，否则开启下一轮循环<ul>\n<li>执行完毕结束循环</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"误解\"><a href=\"#误解\" class=\"headerlink\" title=\"误解\"></a>误解</h3><p>面试过很多人发现他们在回答相关问题时总会有各种误解：“Promise是微任务，解析执行代码时遇到promise会将其推入微任务队列等”</p>\n<ul>\n<li>一些人说Promise是微任务，其实Promsie只是普通的构造函数的初始化，.then等钩子才是微任务，触发.then的时候才会将.then的回调推入任务队列</li>\n<li>键盘事件由webcore的 DOM Binding 模块来处理，当事件触发时将监听事件的回调函数推入任务队列</li>\n<li>setTimeout由webcore的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数推入任务队</li>\n<li>ajax 则会由webcore的 network 模块来处理，在网络请求完成返回之后，才会将回调函数推入任务队</li>\n</ul>\n<h1 id=\"Node的事件循环\"><a href=\"#Node的事件循环\" class=\"headerlink\" title=\"Node的事件循环\"></a>Node的事件循环</h1><p>node是js的一个runtime，所以事件循环同样是 Node.js 处理非阻塞 I/O 操作的机制。由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行</p>\n<p>当 Node.js 启动后，它会初始化事件轮询；处理已提供的输入脚本（或丢入 REPL），它可能会调用一些异步的 API 函数调用，安排任务处理事件，或者调用 process.nextTick，然后开始处理事件循环</p>\n<p>与浏览器端的事件循环相比有很大不同，node的事件循环主要分为六个阶段（Phase），每个阶段都会有一个类似于队列的结构, 存储着该阶段需要处理的回调函数：</p>\n<ul>\n<li>timer：用一个 for 循环处理所有 setTimeout 和 setInterval 的回调<ul>\n<li>检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>Pending I/O Callback Phase：执行你的 fs.read, socket 等 IO 操作的回调函数, 同时也包括各种 error 的回调<ul>\n<li>检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段</li>\n<li>检查是否有 process.nextTick 任务，如果有，全部执行</li>\n<li>检查是否有microtask，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>idle, prepare：仅系统内部使用</li>\n<li>Poll Phase：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate 排定的之外），其余情况 node 将在此处阻塞，循环中最重要的一个 Phase, 作用是等待异步请求和数据，最重要是因为它支撑了整个消息循环机制，Poll Phase 首先会执行 watch_queue 队列中的 IO 请求, 一旦 watch_queue 队列空, 则整个消息循环就会进入 sleep , 从而等待被内核事件唤醒<br>首先检查是否存在尚未完成的回调，如果存在，那么分两种情况。<ul>\n<li>第一种情况：<ul>\n<li>如果有可用回调（可用回调包含到期的定时器还有一些IO事件等），执行所有可用回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出该阶段</li>\n</ul>\n</li>\n<li>第二种情况：<ul>\n<li>如果没有可用回调</li>\n<li>检查是否有 immediate 回调，如果有，退出 poll 阶段。如果没有，阻塞在此阶段，等待新的事件通知</li>\n<li>如果不存在尚未完成的回调，退出poll阶段</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Check Phase：这个阶段只处理 setImmediate 的回调函数（因为 Poll Phase 阶段可能设置一些回调, 希望在 Poll Phase 后运行. 所以在 Poll Phase 后面增加了这个 Check Phase.）<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 check 阶段</li>\n</ul>\n</li>\n<li>Close Callbacks Phase：专门处理一些 close 类型的回调. 比如 socket.on(‘close’, …). 用于资源清理<ul>\n<li>如果有immediate回调，则执行所有immediate回调</li>\n<li>检查是否有 process.nextTick 回调，如果有，全部执行</li>\n<li>检查是否有 microtaks，如果有，全部执行</li>\n<li>退出 closing 阶段<br>一轮循环结束后检查是否有活跃的 handles（定时器、IO等事件句柄）如果有就继续下一轮循环，如果没有则结束事件循环，退出程序</li>\n</ul>\n</li>\n</ul>\n<p>事件循环过程如下图示意<em>每个框内代表一个阶段</em>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   ┌───────────────────────────┐</span><br><span class=\"line\">┌─&gt;│           timers          │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │     pending callbacks     │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">│  │       idle, prepare       │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class=\"line\">│  │           poll            │&lt;─────┤  connections, │</span><br><span class=\"line\">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class=\"line\">│  │           check           │</span><br><span class=\"line\">│  └─────────────┬─────────────┘</span><br><span class=\"line\">│  ┌─────────────┴─────────────┐</span><br><span class=\"line\">└──┤      close callbacks      │</span><br><span class=\"line\">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>\n<p>每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段</p>\n<p>由于这些操作中的任何一个都可能计划 更多的 操作，并且在 轮询 阶段处理的新事件由内核排队，因此在处理轮询事件时，轮询事件可以排队。因此，长时间运行回调可以允许轮询阶段运行大量长于计时器的阈值</p>\n<p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净</p>\n<p>补充：</p>\n<ol>\n<li><p>setImmediate 对比 setTimeout<br>setImmediate 和 setTimeout 很类似，但何时调用行为完全不同</p>\n<ul>\n<li>setImmediate 设计为在当前 轮询 阶段完成后执行脚本</li>\n<li>setTimeout 计划在毫秒的最小阈值经过后运行的脚本<br>执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时将受进程性能的约束（这可能会受到计算机上运行的其它应用程序的影响）</li>\n</ul>\n</li>\n<li><p>process.nextTick<br>process.nextTick 在技术上不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码<br>任何时候在给定的阶段中调用 process.nextTick，所有传递到 process.nextTick 的回调将在事件循环继续之前得到解决。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick 来“饿死”您的 I/O 调用，阻止事件循环到达 轮询 阶段</p>\n</li>\n</ol>\n<p>以上简要介绍JS/Node的事件循环，存在相关错误请指出😄</p>\n<p>Link：</p>\n<ul>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"noopener\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n<li><a href=\"https://blog.csdn.net/i10630226/article/details/81369841\" target=\"_blank\" rel=\"noopener\">深入分析Node.js事件循环</a></li>\n</ul>\n<p><strong>end</strong></p>"},{"title":"十行代码实现Koa2洋葱模型","date":"2019-02-22T11:00:00.000Z","_content":"\n十行代码实现 `koa2` 洋葱模型\n\n<!--more-->\n\n#### 洋葱图模型\n![avatar](/onion.png)\n\nkoa2上独特的中间件流程控制，是一个典型的洋葱模型\n\n# 运行 koa2 demo\n```js\nconst Koa = require('koa2')\n\nconst app = new Koa()\n\napp.use(async (ctx, next)=>{\n    console.log(1, ' start')\n    await next()\n    console.log(1, ' end')\n})\n\napp.use(async (ctx, next) => {\n    console.log(2, ' start')\n    await next()\n    console.log(2, ' end')\n})\napp.use(async (ctx, next) => {\n    console.log(3, ' start')\n    await next()\n    console.log(3, ' end')\n})\n\napp.listen(3000)\n```\n输出结果：\n```bash\n1 start\n2 start\n3 start\n3 end\n2 end\n1 end\n```\n\n展现如上图洋葱式的输出结果\n\n# 归纳\n\n接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：\n- 首先变为最简case：只有两个中间件函数\n- 那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 `1 start -> 2 start -> 2 end -> 1 end` 的结果\n- 同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n和之前的一篇 [动态规划和递归：从虎羊草开始](http://localhost:4000/2019/02/21/do%20something/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E9%80%92%E5%BD%92%EF%BC%9A%E4%BB%8E%E8%99%8E%E7%BE%8A%E8%8D%89%E5%BC%80%E5%A7%8B/#%E4%BB%8E%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%83%85%E5%86%B5%E5%85%A5%E6%89%8B) 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码\n\n# 三步完成封装\n\n第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n```\n\n第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -> 2 -> 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：\n```js\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n```\n\n第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：\n```js\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n```\n\n以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试\n\n# 测试\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n\nconst app = new App\n\napp.use(async function m1(next) {\n  console.log('m1')\n  await next()\n  console.log('m1 end')\n})\n\napp.use(async function m2(next) {\n  console.log('m2')\n  await next()\n  console.log('m2 end')\n})\n\napp.use(async function m3(next) {\n  console.log('m3')\n  await next()\n  console.log('m3 end')\n})\n\n\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n\ncompose(app.middleware)()\n\n// output:\n// m1\n// m2\n// m3\n// m3 end\n// m2 end\n// m1 end\n```\n\n达到预期结果ahhhhh💐\n\n# summary\n\n当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2","source":"_posts/writeSomething/koa2OnionModel.md","raw":"---\ntitle: 十行代码实现Koa2洋葱模型\ntags:\n  - 封装\n  - koa\n  - 洋葱模型\ndate: 2019-02-22 19:00:00\ncategories: 封装\n---\n\n十行代码实现 `koa2` 洋葱模型\n\n<!--more-->\n\n#### 洋葱图模型\n![avatar](/onion.png)\n\nkoa2上独特的中间件流程控制，是一个典型的洋葱模型\n\n# 运行 koa2 demo\n```js\nconst Koa = require('koa2')\n\nconst app = new Koa()\n\napp.use(async (ctx, next)=>{\n    console.log(1, ' start')\n    await next()\n    console.log(1, ' end')\n})\n\napp.use(async (ctx, next) => {\n    console.log(2, ' start')\n    await next()\n    console.log(2, ' end')\n})\napp.use(async (ctx, next) => {\n    console.log(3, ' start')\n    await next()\n    console.log(3, ' end')\n})\n\napp.listen(3000)\n```\n输出结果：\n```bash\n1 start\n2 start\n3 start\n3 end\n2 end\n1 end\n```\n\n展现如上图洋葱式的输出结果\n\n# 归纳\n\n接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：\n- 首先变为最简case：只有两个中间件函数\n- 那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 `1 start -> 2 start -> 2 end -> 1 end` 的结果\n- 同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n和之前的一篇 [动态规划和递归：从虎羊草开始](http://localhost:4000/2019/02/21/do%20something/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E9%80%92%E5%BD%92%EF%BC%9A%E4%BB%8E%E8%99%8E%E7%BE%8A%E8%8D%89%E5%BC%80%E5%A7%8B/#%E4%BB%8E%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%83%85%E5%86%B5%E5%85%A5%E6%89%8B) 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码\n\n# 三步完成封装\n\n第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n```\n\n第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -> 2 -> 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：\n```js\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n```\n\n第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：\n```js\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n```\n\n以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试\n\n# 测试\n```js\nclass App {\n  constructor() {\n    this.middleware = []\n  }\n  use(fn) {\n    this.middleware.push(fn)\n  }\n}\n\nconst app = new App\n\napp.use(async function m1(next) {\n  console.log('m1')\n  await next()\n  console.log('m1 end')\n})\n\napp.use(async function m2(next) {\n  console.log('m2')\n  await next()\n  console.log('m2 end')\n})\n\napp.use(async function m3(next) {\n  console.log('m3')\n  await next()\n  console.log('m3 end')\n})\n\n\nconst createNext = (middleware, oldNext) =>\n  async () =>\n    await middleware(oldNext)\n\nconst compose = middlewares =>\n  middlewares.reduceRight((oldNext, fn) =>\n    createNext(fn, oldNext), async () => Promise.resolve())\n\ncompose(app.middleware)()\n\n// output:\n// m1\n// m2\n// m3\n// m3 end\n// m2 end\n// m1 end\n```\n\n达到预期结果ahhhhh💐\n\n# summary\n\n当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2","slug":"writeSomething/koa2OnionModel","published":1,"updated":"2019-02-24T02:52:53.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt2pem1f000ef748ydswvkkf","content":"<p>十行代码实现 <code>koa2</code> 洋葱模型</p>\n<a id=\"more\"></a>\n<h4 id=\"洋葱图模型\"><a href=\"#洋葱图模型\" class=\"headerlink\" title=\"洋葱图模型\"></a>洋葱图模型</h4><p><img src=\"/2019/02/22/writeSomething/koa2OnionModel/onion.png\" alt=\"avatar\"></p>\n<p>koa2上独特的中间件流程控制，是一个典型的洋葱模型</p>\n<h1 id=\"运行-koa2-demo\"><a href=\"#运行-koa2-demo\" class=\"headerlink\" title=\"运行 koa2 demo\"></a>运行 koa2 demo</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 start</span><br><span class=\"line\">2 start</span><br><span class=\"line\">3 start</span><br><span class=\"line\">3 end</span><br><span class=\"line\">2 end</span><br><span class=\"line\">1 end</span><br></pre></td></tr></table></figure></p>\n<p>展现如上图洋葱式的输出结果</p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><p>接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：</p>\n<ul>\n<li>首先变为最简case：只有两个中间件函数</li>\n<li>那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 <code>1 start -&gt; 2 start -&gt; 2 end -&gt; 1 end</code> 的结果</li>\n<li>同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调</li>\n</ul>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.<br>和之前的一篇 <a href=\"http://localhost:4000/2019/02/21/do%20something/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E9%80%92%E5%BD%92%EF%BC%9A%E4%BB%8E%E8%99%8E%E7%BE%8A%E8%8D%89%E5%BC%80%E5%A7%8B/#%E4%BB%8E%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%83%85%E5%86%B5%E5%85%A5%E6%89%8B\" target=\"_blank\" rel=\"noopener\">动态规划和递归：从虎羊草开始</a> 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码</p>\n<h1 id=\"三步完成封装\"><a href=\"#三步完成封装\" class=\"headerlink\" title=\"三步完成封装\"></a>三步完成封装</h1><p>第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -&gt; 2 -&gt; 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></p>\n<p>第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> App</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m3</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br><span class=\"line\"></span><br><span class=\"line\">compose(app.middleware)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// m1</span></span><br><span class=\"line\"><span class=\"comment\">// m2</span></span><br><span class=\"line\"><span class=\"comment\">// m3</span></span><br><span class=\"line\"><span class=\"comment\">// m3 end</span></span><br><span class=\"line\"><span class=\"comment\">// m2 end</span></span><br><span class=\"line\"><span class=\"comment\">// m1 end</span></span><br></pre></td></tr></table></figure>\n<p>达到预期结果ahhhhh💐</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2</p>\n","site":{"data":{}},"excerpt":"<p>十行代码实现 <code>koa2</code> 洋葱模型</p>","more":"<h4 id=\"洋葱图模型\"><a href=\"#洋葱图模型\" class=\"headerlink\" title=\"洋葱图模型\"></a>洋葱图模型</h4><p><img src=\"/2019/02/22/writeSomething/koa2OnionModel/onion.png\" alt=\"avatar\"></p>\n<p>koa2上独特的中间件流程控制，是一个典型的洋葱模型</p>\n<h1 id=\"运行-koa2-demo\"><a href=\"#运行-koa2-demo\" class=\"headerlink\" title=\"运行 koa2 demo\"></a>运行 koa2 demo</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>, <span class=\"string\">' end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 start</span><br><span class=\"line\">2 start</span><br><span class=\"line\">3 start</span><br><span class=\"line\">3 end</span><br><span class=\"line\">2 end</span><br><span class=\"line\">1 end</span><br></pre></td></tr></table></figure></p>\n<p>展现如上图洋葱式的输出结果</p>\n<h1 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h1><p>接下来我们开始封装，要想达成洋葱模型式的流程控制，主要看上面demo中 callback 的第二个参数 next 方法（ctx暂时和本文内容无关），一步一步来按照以下顺序思考：</p>\n<ul>\n<li>首先变为最简case：只有两个中间件函数</li>\n<li>那么如果想要第一个函数执行next方法时，我们若是把next方法本身就是作为第二个中间件函数进行调用就会得到 <code>1 start -&gt; 2 start -&gt; 2 end -&gt; 1 end</code> 的结果</li>\n<li>同理如果是三个中间件函数，我们只需要将第三个中间件当做第二个中间件的 next 方法，再把第二个中间件当做第一个中间件的 next 回调</li>\n</ul>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.<br>和之前的一篇 <a href=\"http://localhost:4000/2019/02/21/do%20something/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E9%80%92%E5%BD%92%EF%BC%9A%E4%BB%8E%E8%99%8E%E7%BE%8A%E8%8D%89%E5%BC%80%E5%A7%8B/#%E4%BB%8E%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%83%85%E5%86%B5%E5%85%A5%E6%89%8B\" target=\"_blank\" rel=\"noopener\">动态规划和递归：从虎羊草开始</a> 类似进行简单的归纳之后得出思路，最关键的流程控制问题既然有了思路下面开始封装代码</p>\n<h1 id=\"三步完成封装\"><a href=\"#三步完成封装\" class=\"headerlink\" title=\"三步完成封装\"></a>三步完成封装</h1><p>第一步：首先构造一个基本的App构造类进行方法挂载依赖收集等, 拥有一个 use 方法对中间件函数进行依赖收集，建立一个存储栈 middleware 用来存放收集的依赖，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：接下来我们需要构建一个 compose 函数 对收集到的依赖进行处理，参数是收集的依赖栈，返回一个通过一层层中间件函数包装的新函数，数组有个 reduce 方法可以很轻易的帮我们做到这件事情，但是由于我们是需要按照收集的中间件的顺序执行每一个中间件函数，按照我们上面的归纳如果按1 -&gt; 2 -&gt; 3的流程顺序遍历显然就会将最早收集的依赖包装在最内层，不过我们还有 reduceRight😄， 代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br></pre></td></tr></table></figure></p>\n<p>第三步：显然接下来最关键的就是对上面 compose 函数中的 createNext 方法进行封装，我们需要两个参数，上面已经说过，next方法是对下一个中间件函数的处理，一个参数是中间件函数，而另一个显然就是那个next方法，包装调用后返回一个新的next函数传递到下一层包装，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br></pre></td></tr></table></figure></p>\n<p>以上基本的封装已经完成，核心代码只有 middlewares 和 createNext 两个函数，只有6行，下面对上面整个流程进行聚合测试</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  use(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middleware.push(fn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> App</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m1 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m2 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m3</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'m3 end'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createNext = <span class=\"function\">(<span class=\"params\">middleware, oldNext</span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> () =&gt;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> middleware(oldNext)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\"><span class=\"params\">middlewares</span> =&gt;</span></span><br><span class=\"line\">  middlewares.reduceRight(<span class=\"function\">(<span class=\"params\">oldNext, fn</span>) =&gt;</span></span><br><span class=\"line\">    createNext(fn, oldNext), <span class=\"keyword\">async</span> () =&gt; <span class=\"built_in\">Promise</span>.resolve())</span><br><span class=\"line\"></span><br><span class=\"line\">compose(app.middleware)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// m1</span></span><br><span class=\"line\"><span class=\"comment\">// m2</span></span><br><span class=\"line\"><span class=\"comment\">// m3</span></span><br><span class=\"line\"><span class=\"comment\">// m3 end</span></span><br><span class=\"line\"><span class=\"comment\">// m2 end</span></span><br><span class=\"line\"><span class=\"comment\">// m1 end</span></span><br></pre></td></tr></table></figure>\n<p>达到预期结果ahhhhh💐</p>\n<h1 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h1><p>当然这里只是简单的封装一下，关于上下文传递错误捕获之类都没做，但是已经完成一个标准的洋葱模型的流程控制了，下次有机会讲解完整的封装 koa2</p>"},{"title":"JS常用的设计模式","date":"2019-02-24T14:52:00.000Z","_content":"持续更新\nJS常用的设计模式以及应用场景\n<!-- more -->\n*以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝*\n\n# 何谓设计模式\n\n没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多\n\n抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位\n\n定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案\n\n补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题\n\n软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍\n\n# 设计原则\n在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：\n- 单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度\n\n- 最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理\n\n- 开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定\n\n\n\n# 从最简单的单体/单例模式开始\n\n### 定义：\n\n单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象\n\n单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例\n*在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供*\n\n### 优点:\n- 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例\n- 因为类控制了实例化过程，所以类可以灵活更改实例化过程\n- 单体可以控制局部变量污染\n\n### 应用场景：\n- 可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存\n- 借助单例模式，可以把代码组织的更为一致\n\n#### 最基本的单体模式\n直接导出一个方法属性集合的对象\n```js\n// commonjs 导出\nmodule.exports = {\n  getSingleton() {\n    return this \n  }\n}\n```\n#### 用闭包来实现单例\n```js\nconst Ins1 = (function() {\n  let instance = null\n  // 利用闭包特性保证实例私有化\n  return function(opt) {\n    if (instance === null) {\n      instance = this\n    }\n\n    for(let k in opt) {\n      instance[k] = opt[k]\n    }\n\n    return instance\n  }\n})()\n```\n测试：\n```js\nconst i1 = new Ins1({ name: 'i1' })\n\nconst i2 = new Ins1({ name: 'i2' })\n\nconsole.log(i1 === i2) // true\n\nconsole.log(i1.name) // i2\n```\n补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： `class T {} export default new T` 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化\n\n# 策略模式\n\n### 定义：\n就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则\n\n### 优点：\n- 减少`command c & command v`, 提高复用性\n- 遵循开闭原则，算法独立易于切换、理解、拓展\n\n### 应用场景：\n针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试\n\n#### 最简单的执行\n```js\nfunction closure() {\n  // 定义\n  const strategies = {\n      plus10: function(arg) {\n        return arg + 10\n      },\n      plus100: function(arg) {\n        return arg + 100\n      }\n  }\n  // 执行\n  return function(plus, base){\n    return strategies[plus](base);\n  }\n}\nconst strategy = closure()\n\nconsole.log(strategy('plus10', 1)) // 11\nconsole.log(strategy('plus100', 1)) // 101\n```\n#### 对比分析\neg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额\n\n意大利逻辑:\n\n```js\nfunction context (name, type, price) {\n  if (type === 'vip') {\n    return price * 0.5\n  } else if (type === 'vip') {\n    return price * 0.8\n  } else {\n    return price\n  }\n}\n```\n如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:\n``` js\nclass Vip {\n  constructor () {\n    this.discount = 0.5\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Old {\n  constructor () {\n    this.discount = 0.8\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Others {\n  constructor () {\n  }\n  getPrice (price) {\n    return price\n  }\n}\n\nclass Context {\n  constructor () {\n    this.name = ''\n    this.strategy = null\n    this.price = 0\n  }\n  setPrice (name, strategy, price) {\n    this.name = name\n    this.strategy = strategy\n    this.price = price\n  }\n  getPrice () {\n    console.log(this.name, this.strategy.getPrice(this.price), '元')\n    return this.strategy.getPrice(this.price)\n  }\n}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Vip\nconst old = new Old\nconst other = new Others\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本\n\n补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：\n```js\n// 定义父类\nclass Handler {\n  constructor(discount) {\n    // 不传为原价\n    this.discount = discount || 1\n  }\n\n  getPrice(price) {\n    return this.discount === 1\n      ? price\n      : this.discount * price\n  }\n}\n\n// 声明子类\nclass Sub extends Handler {}\n\n// 可以自定义更多不同级别顾客不同需求\n// class Test extend Handler {\n//   getGifts() {\n//     if (this.discount < 1) {\n//       // 赠送赠品\n//     }\n//   }\n// }\n// const master = new Test(0.1)\n// master.getGifts()\n\n// Context类同上方便统一接口输出\nclass Context {}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Sub(0.5)\nconst old = new Sub(0.8)\nconst other = new Sub\n\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n测试结果一致\n\n# 代理模式\n\n### 定义：\n为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用\n著名的代理模式例子为引用计数（reference counting）指针对象\n另外代理模式还可分为：\n- 虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象\n- 保护代理：用于控制不同权限的对象对目标对象的访问\n- 缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果\n\n### 优点：\n独立职责归属，便于维护测试\n\n### 应用场景：\n比如图片的懒加载，数据缓存等\n\n#### 虚拟代理实现图片懒加载\n```js\nconst imgSet = (() => {\n  let node = new Image\n  document.body.append(node)\n\n  return function(src) {\n    node.src = src\n  }\n})()\n\nconst proxyImg = (() => {\n  let _img = new Image\n\n  _img.onload = function() {\n    setTimeout(imgSet, 2000, this.src)\n  }\n\n  return function(src) {\n    imgSet('https://yphoto.eryufm.cn/upload/assets/jump.gif')\n    _img.src = src\n  }\n})()\n// call\nproxyImg(`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1551174639&di=90b4757f68c9480f78c132c930c1df10&src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`)\n```\n\n#### 保护代理\n对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发\n```js\n// filter some no use or unneed requestions or data\n// A  ---> B(proxy) ----> C\nconst a = {\n  name: 'a',\n  send (target, info) {\n    target.receive(info)\n  }\n}\nconst c = {\n  name: 'c',\n  receive (target, info) {\n    console.log('c receive ', info, ' from ', target.name)\n  }\n}\nconst b = {\n  name: 'b',\n  receive (info) {\n    if (info) {\n      c.receive(this, info)\n    }\n  }\n}\na.send(b, 'good morning')\na.send(b, '')\na.send(b, 'send again')\n\n// output:\n// c receive good morning from b\n// c receive send again from b\n```\n上面表示一个最简单的保护代理\n\n#### 缓存代理\n顾名思义就是缓存相关的代理\n\n有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存\n```js\n// 存储所有标签\nlet tags\n\nconst sendApiGetTags = index => {\n  // ajax.get('/api', { index })\n}\nlet proxyCache = (async () => {\n  const allTagsCache = {}\n  const number = 5\n  const all = []\n  const params = {}\n\n  for (let index = 0; index < number; index++) {\n    all.push(sendApiGetTags({\n      ...params,\n      index\n    }))\n  }\n  const list = await Promise.all(all)\n\n  list.forEach((res, i) => allTagsCache[i] = res)\n\n  return allTagsCache\n})()\n\nlet setTags = async index => {\n  // 缓存中有直接拿\n  if (proxyCache[index]) {\n    tags = proxyCache[index]\n  } else {\n  // 缓存中没有则重发请求\n    tags = await sendApiGetTags(index)\n  }\n}\n```\n\n\n\n# 发布订阅模式\n\n### 定义：\n一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。\n至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法\n\n### 优点：\n订阅者可以根据自己需求当某种Action被触发时完成自己的调度\n\n### 应用场景：\nAngularJs的广播、vue的eventbus等\n\n#### 根据主体构建发布订阅的基类\n构造发布者基类\n```js\nclass Publisher {\n  constructor () {\n    // 订阅发布者的队列 存储每个订阅者\n    this.subscribers = []\n  }\n  deliver (data) {\n    // 发布消息 调用订阅者的回调 告知订阅者\n    this.subscribers.forEach(fn => fn.shot(data))\n\n    return this\n  }\n}\n```\n构造订阅者基类\n```js\nclass Observer {\n  constructor (call) {\n    // 传入订阅回调\n    this.shot = call\n  }\n  subscribe (publisher) {\n    if (!publisher.subscribers.some(v => v.shot === this.shot)) {\n      console.log('订阅该消息')\n      // 判断当前订阅者是否订阅\n      publisher.subscribers.push(this)\n    }\n    return this\n  }\n  unsubscribe (publisher) {\n    // 移除当前订阅者\n    console.log('取消订阅')\n\n    publisher.subscribers = publisher.subscribers.filter(v => v.shot !== this.shot)\n\n    return this\n  }\n}\n```\n测试：\n```js\nconst pub = new Publisher\nconst pub2 = new Publisher\nconst obs = new Observer(deliver => console.log(deliver))\n\nobs.subscribe(pub) // 订阅该消息\nobs.subscribe(pub2) // 订阅该消息\n\npub.deliver('pub deliver first message') // pub deliver first message\npub2.deliver('pub2 deliver first message') // pub2 deliver first message\n\nobs.unsubscribe(pub) // 取消订阅\npub.deliver('pub deliver second message') //\n```\n\n# 装饰者模式\n\n### 定义：\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能\n\n### 优点：\n- 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互\n- 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展\n\n### 应用场景：\n- 需要扩展一个类的功能，或给一个类添加附加职责\n- 需要动态的给一个对象添加功能，这些功能可以再动态的撤销\n- 不必改动原本的逻辑造成不可知问题\n\n#### 给所有的函数调用添加调用前和调用后的钩子\n\n普通函数：\n```js\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nfn('let go') // lets go right now\n```\n我们知道JS中所有的函数都是基于父类 `Function` 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：\n```js\n// 执行前\nFunction.prototype.before = function (call) {\n  const fn = this\n  \n  // 返回体本身也是函数所以支持继续调用钩子\n  return function () {\n    // 调用钩子，同时参数传递到钩子内\n    call.apply(this, arguments)\n    // 调用自身\n    return fn.apply(this, arguments)\n  }\n}\n// 执行后\n// 和 before 同理\nFunction.prototype.after = function (call) {\n  const fn = this\n\n  return function () {\n    const res = fn.apply(this, arguments)\n\n    call.apply(this, arguments)\n\n    // 返回自身的返回值\n    return res\n  }\n}\n```\n测试：\n```js\n// 重新包装 fn\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nconst decoratorFn = fn.before(function (msg) {\n  console.log('when we go,', msg)\n}).after(function (msg){\n  console.log('had to go', msg)\n})\n\ndecoratorFn('lets go')\n\n// out put:\n// when we go, right now\n// lets go, right now\n// had to go, right now\n```\n# 职责链（责任链）模式\n\n### 定义：\n它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求\n\n### 优点：\n职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了\n\n### 应用场景：\nJS 中的事件冒泡（事件委托）就是经典案例\n\n#### 实例分析\n\n部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购\n下面分别抽象处理者构造基类\n\n责任链调度中心：\n```js\nclass Handler {\n  constructor() {\n    this.next = null\n  }\n  setNext(_handler) {\n    this.next = _handler\n  }\n  handleRequest(money) {}\n}\n\n\n```\n\n采购部经理：\n```js\nclass CGBHandler extends Handler {\n  handleRequest(money) {\n    // 1w\n    if (money < 10000){\n      console.log('1w以内，同意')\n    } else {\n      console.log('金额太大，只能处理1w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n总经理：\n```js\nclass ZJLHandler extends Handler {\n  handleRequest(money) {\n    // 10w\n    if (money < 100000){\n      console.log('10w以内，同意')\n    } else {\n      console.log('金额太大，只能处理10w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n董事长：\n```js\nclass DSZHandler extends Handler {\n  handleRequest(money) {\n    // 100w\n    if (money >= 100000){\n      console.log('10万以上的我来处理')\n      //处理其他逻辑\n    } \n  }\n}\n```\n\n封装客户端接口：\n```js\nconst dispatch = (function client() {\n  const cgb = new CGBHandler()\n  const zjl = new ZJLHandler()\n  const dsz = new DSZHandler()\n\n  cgb.setNext(zjl)\n  zjl.setNext(dsz)\n\n  return cgb.handleRequest.bind(cgb)\n})()\n```\n测试：\n```js\n\ndispath(800000)\n// output:\n// 金额太大，只能处理1w以内的采购\n// 金额太大，只能处理10w以内的采购\n// 10万以上的我来处理\n\ndispath(7000)\n// output:\n// 1w以内，同意\n\n```\n补充：\n- 纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理\n\n- 不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理\n\n.\n.\n.\n.\n.\n.\n未完待续...👏\n","source":"_posts/writeSomething/jsDesignPattern.md","raw":"---\ntitle: JS常用的设计模式\ntags:\n  - 设计模式\n  - 算法\ndate: 2019-02-24 22:52:00\ncategories: 算法\n---\n持续更新\nJS常用的设计模式以及应用场景\n<!-- more -->\n*以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝*\n\n# 何谓设计模式\n\n没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多\n\n抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位\n\n定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案\n\n补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题\n\n软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍\n\n# 设计原则\n在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：\n- 单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度\n\n- 最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理\n\n- 开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定\n\n\n\n# 从最简单的单体/单例模式开始\n\n### 定义：\n\n单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象\n\n单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例\n*在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供*\n\n### 优点:\n- 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例\n- 因为类控制了实例化过程，所以类可以灵活更改实例化过程\n- 单体可以控制局部变量污染\n\n### 应用场景：\n- 可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存\n- 借助单例模式，可以把代码组织的更为一致\n\n#### 最基本的单体模式\n直接导出一个方法属性集合的对象\n```js\n// commonjs 导出\nmodule.exports = {\n  getSingleton() {\n    return this \n  }\n}\n```\n#### 用闭包来实现单例\n```js\nconst Ins1 = (function() {\n  let instance = null\n  // 利用闭包特性保证实例私有化\n  return function(opt) {\n    if (instance === null) {\n      instance = this\n    }\n\n    for(let k in opt) {\n      instance[k] = opt[k]\n    }\n\n    return instance\n  }\n})()\n```\n测试：\n```js\nconst i1 = new Ins1({ name: 'i1' })\n\nconst i2 = new Ins1({ name: 'i2' })\n\nconsole.log(i1 === i2) // true\n\nconsole.log(i1.name) // i2\n```\n补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： `class T {} export default new T` 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化\n\n# 策略模式\n\n### 定义：\n就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则\n\n### 优点：\n- 减少`command c & command v`, 提高复用性\n- 遵循开闭原则，算法独立易于切换、理解、拓展\n\n### 应用场景：\n针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试\n\n#### 最简单的执行\n```js\nfunction closure() {\n  // 定义\n  const strategies = {\n      plus10: function(arg) {\n        return arg + 10\n      },\n      plus100: function(arg) {\n        return arg + 100\n      }\n  }\n  // 执行\n  return function(plus, base){\n    return strategies[plus](base);\n  }\n}\nconst strategy = closure()\n\nconsole.log(strategy('plus10', 1)) // 11\nconsole.log(strategy('plus100', 1)) // 101\n```\n#### 对比分析\neg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额\n\n意大利逻辑:\n\n```js\nfunction context (name, type, price) {\n  if (type === 'vip') {\n    return price * 0.5\n  } else if (type === 'vip') {\n    return price * 0.8\n  } else {\n    return price\n  }\n}\n```\n如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:\n``` js\nclass Vip {\n  constructor () {\n    this.discount = 0.5\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Old {\n  constructor () {\n    this.discount = 0.8\n  }\n  getPrice (price) {\n    return this.discount * price\n  }\n}\n\nclass Others {\n  constructor () {\n  }\n  getPrice (price) {\n    return price\n  }\n}\n\nclass Context {\n  constructor () {\n    this.name = ''\n    this.strategy = null\n    this.price = 0\n  }\n  setPrice (name, strategy, price) {\n    this.name = name\n    this.strategy = strategy\n    this.price = price\n  }\n  getPrice () {\n    console.log(this.name, this.strategy.getPrice(this.price), '元')\n    return this.strategy.getPrice(this.price)\n  }\n}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Vip\nconst old = new Old\nconst other = new Others\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本\n\n补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：\n```js\n// 定义父类\nclass Handler {\n  constructor(discount) {\n    // 不传为原价\n    this.discount = discount || 1\n  }\n\n  getPrice(price) {\n    return this.discount === 1\n      ? price\n      : this.discount * price\n  }\n}\n\n// 声明子类\nclass Sub extends Handler {}\n\n// 可以自定义更多不同级别顾客不同需求\n// class Test extend Handler {\n//   getGifts() {\n//     if (this.discount < 1) {\n//       // 赠送赠品\n//     }\n//   }\n// }\n// const master = new Test(0.1)\n// master.getGifts()\n\n// Context类同上方便统一接口输出\nclass Context {}\n```\n测试：\n```js\nconst seller = new Context\nconst vip = new Sub(0.5)\nconst old = new Sub(0.8)\nconst other = new Sub\n\nseller.setPrice('zs', vip, 1000)\nseller.getPrice()\nseller.setPrice('ls', old, 1000)\nseller.getPrice()\nseller.setPrice('ww', other, 1000)\nseller.getPrice()\n\n// output:\n// zs 500 元\n// ls 800 元\n// ww 1000 元\n```\n测试结果一致\n\n# 代理模式\n\n### 定义：\n为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用\n著名的代理模式例子为引用计数（reference counting）指针对象\n另外代理模式还可分为：\n- 虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象\n- 保护代理：用于控制不同权限的对象对目标对象的访问\n- 缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果\n\n### 优点：\n独立职责归属，便于维护测试\n\n### 应用场景：\n比如图片的懒加载，数据缓存等\n\n#### 虚拟代理实现图片懒加载\n```js\nconst imgSet = (() => {\n  let node = new Image\n  document.body.append(node)\n\n  return function(src) {\n    node.src = src\n  }\n})()\n\nconst proxyImg = (() => {\n  let _img = new Image\n\n  _img.onload = function() {\n    setTimeout(imgSet, 2000, this.src)\n  }\n\n  return function(src) {\n    imgSet('https://yphoto.eryufm.cn/upload/assets/jump.gif')\n    _img.src = src\n  }\n})()\n// call\nproxyImg(`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1551174639&di=90b4757f68c9480f78c132c930c1df10&src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`)\n```\n\n#### 保护代理\n对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发\n```js\n// filter some no use or unneed requestions or data\n// A  ---> B(proxy) ----> C\nconst a = {\n  name: 'a',\n  send (target, info) {\n    target.receive(info)\n  }\n}\nconst c = {\n  name: 'c',\n  receive (target, info) {\n    console.log('c receive ', info, ' from ', target.name)\n  }\n}\nconst b = {\n  name: 'b',\n  receive (info) {\n    if (info) {\n      c.receive(this, info)\n    }\n  }\n}\na.send(b, 'good morning')\na.send(b, '')\na.send(b, 'send again')\n\n// output:\n// c receive good morning from b\n// c receive send again from b\n```\n上面表示一个最简单的保护代理\n\n#### 缓存代理\n顾名思义就是缓存相关的代理\n\n有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存\n```js\n// 存储所有标签\nlet tags\n\nconst sendApiGetTags = index => {\n  // ajax.get('/api', { index })\n}\nlet proxyCache = (async () => {\n  const allTagsCache = {}\n  const number = 5\n  const all = []\n  const params = {}\n\n  for (let index = 0; index < number; index++) {\n    all.push(sendApiGetTags({\n      ...params,\n      index\n    }))\n  }\n  const list = await Promise.all(all)\n\n  list.forEach((res, i) => allTagsCache[i] = res)\n\n  return allTagsCache\n})()\n\nlet setTags = async index => {\n  // 缓存中有直接拿\n  if (proxyCache[index]) {\n    tags = proxyCache[index]\n  } else {\n  // 缓存中没有则重发请求\n    tags = await sendApiGetTags(index)\n  }\n}\n```\n\n\n\n# 发布订阅模式\n\n### 定义：\n一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。\n至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法\n\n### 优点：\n订阅者可以根据自己需求当某种Action被触发时完成自己的调度\n\n### 应用场景：\nAngularJs的广播、vue的eventbus等\n\n#### 根据主体构建发布订阅的基类\n构造发布者基类\n```js\nclass Publisher {\n  constructor () {\n    // 订阅发布者的队列 存储每个订阅者\n    this.subscribers = []\n  }\n  deliver (data) {\n    // 发布消息 调用订阅者的回调 告知订阅者\n    this.subscribers.forEach(fn => fn.shot(data))\n\n    return this\n  }\n}\n```\n构造订阅者基类\n```js\nclass Observer {\n  constructor (call) {\n    // 传入订阅回调\n    this.shot = call\n  }\n  subscribe (publisher) {\n    if (!publisher.subscribers.some(v => v.shot === this.shot)) {\n      console.log('订阅该消息')\n      // 判断当前订阅者是否订阅\n      publisher.subscribers.push(this)\n    }\n    return this\n  }\n  unsubscribe (publisher) {\n    // 移除当前订阅者\n    console.log('取消订阅')\n\n    publisher.subscribers = publisher.subscribers.filter(v => v.shot !== this.shot)\n\n    return this\n  }\n}\n```\n测试：\n```js\nconst pub = new Publisher\nconst pub2 = new Publisher\nconst obs = new Observer(deliver => console.log(deliver))\n\nobs.subscribe(pub) // 订阅该消息\nobs.subscribe(pub2) // 订阅该消息\n\npub.deliver('pub deliver first message') // pub deliver first message\npub2.deliver('pub2 deliver first message') // pub2 deliver first message\n\nobs.unsubscribe(pub) // 取消订阅\npub.deliver('pub deliver second message') //\n```\n\n# 装饰者模式\n\n### 定义：\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能\n\n### 优点：\n- 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互\n- 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展\n\n### 应用场景：\n- 需要扩展一个类的功能，或给一个类添加附加职责\n- 需要动态的给一个对象添加功能，这些功能可以再动态的撤销\n- 不必改动原本的逻辑造成不可知问题\n\n#### 给所有的函数调用添加调用前和调用后的钩子\n\n普通函数：\n```js\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nfn('let go') // lets go right now\n```\n我们知道JS中所有的函数都是基于父类 `Function` 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：\n```js\n// 执行前\nFunction.prototype.before = function (call) {\n  const fn = this\n  \n  // 返回体本身也是函数所以支持继续调用钩子\n  return function () {\n    // 调用钩子，同时参数传递到钩子内\n    call.apply(this, arguments)\n    // 调用自身\n    return fn.apply(this, arguments)\n  }\n}\n// 执行后\n// 和 before 同理\nFunction.prototype.after = function (call) {\n  const fn = this\n\n  return function () {\n    const res = fn.apply(this, arguments)\n\n    call.apply(this, arguments)\n\n    // 返回自身的返回值\n    return res\n  }\n}\n```\n测试：\n```js\n// 重新包装 fn\nfunction fn(msg) {\n  console.log(msg, ' right now')\n}\n\nconst decoratorFn = fn.before(function (msg) {\n  console.log('when we go,', msg)\n}).after(function (msg){\n  console.log('had to go', msg)\n})\n\ndecoratorFn('lets go')\n\n// out put:\n// when we go, right now\n// lets go, right now\n// had to go, right now\n```\n# 职责链（责任链）模式\n\n### 定义：\n它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求\n\n### 优点：\n职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了\n\n### 应用场景：\nJS 中的事件冒泡（事件委托）就是经典案例\n\n#### 实例分析\n\n部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购\n下面分别抽象处理者构造基类\n\n责任链调度中心：\n```js\nclass Handler {\n  constructor() {\n    this.next = null\n  }\n  setNext(_handler) {\n    this.next = _handler\n  }\n  handleRequest(money) {}\n}\n\n\n```\n\n采购部经理：\n```js\nclass CGBHandler extends Handler {\n  handleRequest(money) {\n    // 1w\n    if (money < 10000){\n      console.log('1w以内，同意')\n    } else {\n      console.log('金额太大，只能处理1w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n总经理：\n```js\nclass ZJLHandler extends Handler {\n  handleRequest(money) {\n    // 10w\n    if (money < 100000){\n      console.log('10w以内，同意')\n    } else {\n      console.log('金额太大，只能处理10w以内的采购')\n      if (this.next) {\n        this.next.handleRequest(money)\n      }\n    }\n  }\n}\n```\n\n董事长：\n```js\nclass DSZHandler extends Handler {\n  handleRequest(money) {\n    // 100w\n    if (money >= 100000){\n      console.log('10万以上的我来处理')\n      //处理其他逻辑\n    } \n  }\n}\n```\n\n封装客户端接口：\n```js\nconst dispatch = (function client() {\n  const cgb = new CGBHandler()\n  const zjl = new ZJLHandler()\n  const dsz = new DSZHandler()\n\n  cgb.setNext(zjl)\n  zjl.setNext(dsz)\n\n  return cgb.handleRequest.bind(cgb)\n})()\n```\n测试：\n```js\n\ndispath(800000)\n// output:\n// 金额太大，只能处理1w以内的采购\n// 金额太大，只能处理10w以内的采购\n// 10万以上的我来处理\n\ndispath(7000)\n// output:\n// 1w以内，同意\n\n```\n补充：\n- 纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理\n\n- 不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理\n\n.\n.\n.\n.\n.\n.\n未完待续...👏\n","slug":"writeSomething/jsDesignPattern","published":1,"updated":"2019-03-05T08:28:36.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt2pem1h000jf748y1rfs3id","content":"<p>持续更新<br>JS常用的设计模式以及应用场景<br><a id=\"more\"></a><br><em>以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝</em></p>\n<h1 id=\"何谓设计模式\"><a href=\"#何谓设计模式\" class=\"headerlink\" title=\"何谓设计模式\"></a>何谓设计模式</h1><p>没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多</p>\n<p>抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位</p>\n<p>定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案</p>\n<p>补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题</p>\n<p>软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍</p>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><p>在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：</p>\n<ul>\n<li><p>单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度</p>\n</li>\n<li><p>最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理</p>\n</li>\n<li><p>开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定</p>\n</li>\n</ul>\n<h1 id=\"从最简单的单体-单例模式开始\"><a href=\"#从最简单的单体-单例模式开始\" class=\"headerlink\" title=\"从最简单的单体/单例模式开始\"></a>从最简单的单体/单例模式开始</h1><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象</p>\n<p>单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例<br><em>在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供</em></p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例</li>\n<li>因为类控制了实例化过程，所以类可以灵活更改实例化过程</li>\n<li>单体可以控制局部变量污染</li>\n</ul>\n<h3 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存</li>\n<li>借助单例模式，可以把代码组织的更为一致</li>\n</ul>\n<h4 id=\"最基本的单体模式\"><a href=\"#最基本的单体模式\" class=\"headerlink\" title=\"最基本的单体模式\"></a>最基本的单体模式</h4><p>直接导出一个方法属性集合的对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// commonjs 导出</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  getSingleton() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"用闭包来实现单例\"><a href=\"#用闭包来实现单例\" class=\"headerlink\" title=\"用闭包来实现单例\"></a>用闭包来实现单例</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Ins1 = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> instance = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"comment\">// 利用闭包特性保证实例私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opt</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> opt) &#123;</span><br><span class=\"line\">      instance[k] = opt[k]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> i1 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i1'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> i2 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i2'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1 === i2) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1.name) <span class=\"comment\">// i2</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： <code>class T {} export default new T</code> 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化</p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><h3 id=\"定义：-1\"><a href=\"#定义：-1\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>减少<code>command c &amp; command v</code>, 提高复用性</li>\n<li>遵循开闭原则，算法独立易于切换、理解、拓展</li>\n</ul>\n<h3 id=\"应用场景：-1\"><a href=\"#应用场景：-1\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试</p>\n<h4 id=\"最简单的执行\"><a href=\"#最简单的执行\" class=\"headerlink\" title=\"最简单的执行\"></a>最简单的执行</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> strategies = &#123;</span><br><span class=\"line\">      plus10: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">10</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      plus100: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">100</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plus, base</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strategies[plus](base);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> strategy = closure()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus10'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus100'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 101</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对比分析\"><a href=\"#对比分析\" class=\"headerlink\" title=\"对比分析\"></a>对比分析</h4><p>eg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额</p>\n<p>意大利逻辑:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">context</span> (<span class=\"params\">name, type, price</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vip</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Old</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Others</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setPrice (name, strategy, price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name, <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price), <span class=\"string\">'元'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Vip</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Old</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Others</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本</p>\n<p>补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义父类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(discount) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不传为原价</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = discount || <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice(price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount === <span class=\"number\">1</span></span><br><span class=\"line\">      ? price</span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以自定义更多不同级别顾客不同需求</span></span><br><span class=\"line\"><span class=\"comment\">// class Test extend Handler &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   getGifts() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     if (this.discount &lt; 1) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       // 赠送赠品</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// const master = new Test(0.1)</span></span><br><span class=\"line\"><span class=\"comment\">// master.getGifts()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Context类同上方便统一接口输出</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.5</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.8</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Sub</span><br><span class=\"line\"></span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>测试结果一致</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"定义：-2\"><a href=\"#定义：-2\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用<br>著名的代理模式例子为引用计数（reference counting）指针对象<br>另外代理模式还可分为：</p>\n<ul>\n<li>虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象</li>\n<li>保护代理：用于控制不同权限的对象对目标对象的访问</li>\n<li>缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</li>\n</ul>\n<h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>独立职责归属，便于维护测试</p>\n<h3 id=\"应用场景：-2\"><a href=\"#应用场景：-2\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>比如图片的懒加载，数据缓存等</p>\n<h4 id=\"虚拟代理实现图片懒加载\"><a href=\"#虚拟代理实现图片懒加载\" class=\"headerlink\" title=\"虚拟代理实现图片懒加载\"></a>虚拟代理实现图片懒加载</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> imgSet = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.append(node)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    node.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxyImg = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _img = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\"></span><br><span class=\"line\">  _img.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(imgSet, <span class=\"number\">2000</span>, <span class=\"keyword\">this</span>.src)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    imgSet(<span class=\"string\">'https://yphoto.eryufm.cn/upload/assets/jump.gif'</span>)</span><br><span class=\"line\">    _img.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">// call</span></span><br><span class=\"line\">proxyImg(<span class=\"string\">`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1551174639&amp;di=90b4757f68c9480f78c132c930c1df10&amp;src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h4><p>对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filter some no use or unneed requestions or data</span></span><br><span class=\"line\"><span class=\"comment\">// A  ---&gt; B(proxy) ----&gt; C</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  send (target, info) &#123;</span><br><span class=\"line\">    target.receive(info)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  receive (target, info) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c receive '</span>, info, <span class=\"string\">' from '</span>, target.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  receive (info) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (info) &#123;</span><br><span class=\"line\">      c.receive(<span class=\"keyword\">this</span>, info)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.send(b, <span class=\"string\">'good morning'</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">''</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">'send again'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// c receive good morning from b</span></span><br><span class=\"line\"><span class=\"comment\">// c receive send again from b</span></span><br></pre></td></tr></table></figure></p>\n<p>上面表示一个最简单的保护代理</p>\n<h4 id=\"缓存代理\"><a href=\"#缓存代理\" class=\"headerlink\" title=\"缓存代理\"></a>缓存代理</h4><p>顾名思义就是缓存相关的代理</p>\n<p>有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储所有标签</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sendApiGetTags = <span class=\"function\"><span class=\"params\">index</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ajax.get('/api', &#123; index &#125;)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyCache = <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">async</span> (</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allTagsCache = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> number = <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> all = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index = <span class=\"number\">0</span>; index &lt; number; index++) &#123;</span><br><span class=\"line\">    all.push(sendApiGetTags(&#123;</span><br><span class=\"line\">      ...params,</span><br><span class=\"line\">      index</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> list = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(all)</span><br><span class=\"line\"></span><br><span class=\"line\">  list.forEach(<span class=\"function\">(<span class=\"params\">res, i</span>) =&gt;</span> allTagsCache[i] = res)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> allTagsCache</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> setTags = <span class=\"keyword\">async</span> index =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中有直接拿</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (proxyCache[index]) &#123;</span><br><span class=\"line\">    tags = proxyCache[index]</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中没有则重发请求</span></span><br><span class=\"line\">    tags = <span class=\"keyword\">await</span> sendApiGetTags(index)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h1><h3 id=\"定义：-3\"><a href=\"#定义：-3\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。<br>至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法</p>\n<h3 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>订阅者可以根据自己需求当某种Action被触发时完成自己的调度</p>\n<h3 id=\"应用场景：-3\"><a href=\"#应用场景：-3\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>AngularJs的广播、vue的eventbus等</p>\n<h4 id=\"根据主体构建发布订阅的基类\"><a href=\"#根据主体构建发布订阅的基类\" class=\"headerlink\" title=\"根据主体构建发布订阅的基类\"></a>根据主体构建发布订阅的基类</h4><p>构造发布者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Publisher</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 订阅发布者的队列 存储每个订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  deliver (data) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布消息 调用订阅者的回调 告知订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn.shot(data))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造订阅者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (call) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入订阅回调</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.shot = call</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  subscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!publisher.subscribers.some(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot === <span class=\"keyword\">this</span>.shot)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'订阅该消息'</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 判断当前订阅者是否订阅</span></span><br><span class=\"line\">      publisher.subscribers.push(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  unsubscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 移除当前订阅者</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'取消订阅'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    publisher.subscribers = publisher.subscribers.filter(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot !== <span class=\"keyword\">this</span>.shot)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pub = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> pub2 = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> obs = <span class=\"keyword\">new</span> Observer(<span class=\"function\"><span class=\"params\">deliver</span> =&gt;</span> <span class=\"built_in\">console</span>.log(deliver))</span><br><span class=\"line\"></span><br><span class=\"line\">obs.subscribe(pub) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\">obs.subscribe(pub2) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\"></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver first message'</span>) <span class=\"comment\">// pub deliver first message</span></span><br><span class=\"line\">pub2.deliver(<span class=\"string\">'pub2 deliver first message'</span>) <span class=\"comment\">// pub2 deliver first message</span></span><br><span class=\"line\"></span><br><span class=\"line\">obs.unsubscribe(pub) <span class=\"comment\">// 取消订阅</span></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver second message'</span>) <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><h3 id=\"定义：-4\"><a href=\"#定义：-4\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能</p>\n<h3 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展</li>\n</ul>\n<h3 id=\"应用场景：-4\"><a href=\"#应用场景：-4\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>需要扩展一个类的功能，或给一个类添加附加职责</li>\n<li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销</li>\n<li>不必改动原本的逻辑造成不可知问题</li>\n</ul>\n<h4 id=\"给所有的函数调用添加调用前和调用后的钩子\"><a href=\"#给所有的函数调用添加调用前和调用后的钩子\" class=\"headerlink\" title=\"给所有的函数调用添加调用前和调用后的钩子\"></a>给所有的函数调用添加调用前和调用后的钩子</h4><p>普通函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"string\">'let go'</span>) <span class=\"comment\">// lets go right now</span></span><br></pre></td></tr></table></figure></p>\n<p>我们知道JS中所有的函数都是基于父类 <code>Function</code> 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行前</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.before = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 返回体本身也是函数所以支持继续调用钩子</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用钩子，同时参数传递到钩子内</span></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 调用自身</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 执行后</span></span><br><span class=\"line\"><span class=\"comment\">// 和 before 同理</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.after = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回自身的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重新包装 fn</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decoratorFn = fn.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'when we go,'</span>, msg)</span><br><span class=\"line\">&#125;).after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'had to go'</span>, msg)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">decoratorFn(<span class=\"string\">'lets go'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// out put:</span></span><br><span class=\"line\"><span class=\"comment\">// when we go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// lets go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// had to go, right now</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"职责链（责任链）模式\"><a href=\"#职责链（责任链）模式\" class=\"headerlink\" title=\"职责链（责任链）模式\"></a>职责链（责任链）模式</h1><h3 id=\"定义：-5\"><a href=\"#定义：-5\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求</p>\n<h3 id=\"优点：-4\"><a href=\"#优点：-4\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了</p>\n<h3 id=\"应用场景：-5\"><a href=\"#应用场景：-5\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>JS 中的事件冒泡（事件委托）就是经典案例</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购<br>下面分别抽象处理者构造基类</p>\n<p>责任链调度中心：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setNext(_handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = _handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleRequest(money) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采购部经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CGBHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'1w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理1w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZJLHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 10w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理10w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>董事长：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DSZHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 100w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &gt;= <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10万以上的我来处理'</span>)</span><br><span class=\"line\">      <span class=\"comment\">//处理其他逻辑</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>封装客户端接口：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dispatch = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">client</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cgb = <span class=\"keyword\">new</span> CGBHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> zjl = <span class=\"keyword\">new</span> ZJLHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dsz = <span class=\"keyword\">new</span> DSZHandler()</span><br><span class=\"line\"></span><br><span class=\"line\">  cgb.setNext(zjl)</span><br><span class=\"line\">  zjl.setNext(dsz)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cgb.handleRequest.bind(cgb)</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">800000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理1w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理10w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 10万以上的我来处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">7000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 1w以内，同意</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：</p>\n<ul>\n<li><p>纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理</p>\n</li>\n<li><p>不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理</p>\n</li>\n</ul>\n<p>.<br>.<br>.<br>.<br>.<br>.<br>未完待续…👏</p>\n","site":{"data":{}},"excerpt":"<p>持续更新<br>JS常用的设计模式以及应用场景<br></p>","more":"<br><em>以下内容为个人简单理解，部分demo由网上案例简单改写，有错误请在下方评论指出😝</em><p></p>\n<h1 id=\"何谓设计模式\"><a href=\"#何谓设计模式\" class=\"headerlink\" title=\"何谓设计模式\"></a>何谓设计模式</h1><p>没必要被高大上的名词所吓倒，日常coding中或许一个不了解各种设计模式的程序员可能自己其实已经用到了很多</p>\n<p>抛开官方的定义在我看来简单来说就是一个简单的思想被统一为规范，按照这个规范可以写出更优雅可控亦或性能更佳的代码，像是框架的单位</p>\n<p>定义：在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案</p>\n<p>补充：并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题</p>\n<p>软件设计模式有很多，常规的有23种，本文针对其中常用的几种进行简要介绍</p>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><p>在列举具体的设计模式之前，我们要先知道设计模式本身的规范是什么，这就是设计原则，主要以下三种：</p>\n<ul>\n<li><p>单一职责原则（SRP）：一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。应该把对象或方法划分成较小的粒度</p>\n</li>\n<li><p>最少知识原则（LKP）：一个软件实体应当 尽可能少地与其他实体发生相互作用，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理</p>\n</li>\n<li><p>开放-封闭原则（OCP）：软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改，当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定</p>\n</li>\n</ul>\n<h1 id=\"从最简单的单体-单例模式开始\"><a href=\"#从最简单的单体-单例模式开始\" class=\"headerlink\" title=\"从最简单的单体/单例模式开始\"></a>从最简单的单体/单例模式开始</h1><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>单体：一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象</p>\n<p>单例：顾名仅可以可以被实例化一次：在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例<br><em>在java中单例的定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供</em></p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例</li>\n<li>因为类控制了实例化过程，所以类可以灵活更改实例化过程</li>\n<li>单体可以控制局部变量污染</li>\n</ul>\n<h3 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>可以用单例来划分命名空间: 一些对象我们往往只需要一个，如某些数据的缓存</li>\n<li>借助单例模式，可以把代码组织的更为一致</li>\n</ul>\n<h4 id=\"最基本的单体模式\"><a href=\"#最基本的单体模式\" class=\"headerlink\" title=\"最基本的单体模式\"></a>最基本的单体模式</h4><p>直接导出一个方法属性集合的对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// commonjs 导出</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  getSingleton() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"用闭包来实现单例\"><a href=\"#用闭包来实现单例\" class=\"headerlink\" title=\"用闭包来实现单例\"></a>用闭包来实现单例</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Ins1 = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> instance = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"comment\">// 利用闭包特性保证实例私有化</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opt</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> opt) &#123;</span><br><span class=\"line\">      instance[k] = opt[k]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> i1 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i1'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> i2 = <span class=\"keyword\">new</span> Ins1(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'i2'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1 === i2) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i1.name) <span class=\"comment\">// i2</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：在node中一个文件就是一个独立模块，若在某个js文件中导出一个类： <code>class T {} export default new T</code> 之后在其他任何外部文件多次引入其实都是保证了 T 类只被实例化了一次而不会被多次初始化。这是因为node遵循了commonjs的规范，所有文件模块在被引用时都会先去模块系统的缓存中查看这个文件是否存在，如果存在就返回缓存否则才会重新创建一个模块，而这个缓存其实也就限制了模块内脚本的多次初始化</p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><h3 id=\"定义：-1\"><a href=\"#定义：-1\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>就是解耦，何为策略解耦： 指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体。如大量的if else或者switch case判断当需求更改时需要添加和更改判断，这违背了设计模式的对修改关闭，对扩展开放的原则</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>减少<code>command c &amp; command v</code>, 提高复用性</li>\n<li>遵循开闭原则，算法独立易于切换、理解、拓展</li>\n</ul>\n<h3 id=\"应用场景：-1\"><a href=\"#应用场景：-1\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>针对代码多种行为设置大量的条件判断时将每一个行为划分为多个独立的对象。每一个对象被称为一个策略。设置多个这种策略对象，可以改进我们的代码质量，也更好的进行单元测试</p>\n<h4 id=\"最简单的执行\"><a href=\"#最简单的执行\" class=\"headerlink\" title=\"最简单的执行\"></a>最简单的执行</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> strategies = &#123;</span><br><span class=\"line\">      plus10: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">10</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      plus100: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arg + <span class=\"number\">100</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 执行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plus, base</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strategies[plus](base);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> strategy = closure()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus10'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 11</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strategy(<span class=\"string\">'plus100'</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// 101</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对比分析\"><a href=\"#对比分析\" class=\"headerlink\" title=\"对比分析\"></a>对比分析</h4><p>eg.: 代码情景为超市促销，vip为5折，老客户3折，普通顾客没折，计算最后需要支付的金额</p>\n<p>意大利逻辑:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">context</span> (<span class=\"params\">name, type, price</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'vip'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果type类型非常多，内部逻辑分别也不只是简单的return一个val，那对后续的维护和测试就是灾难，下面拆分逻辑为独立单元:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vip</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.5</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Old</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = <span class=\"number\">0.8</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Others</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice (price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setPrice (name, strategy, price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.price = price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getPrice () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name, <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price), <span class=\"string\">'元'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.strategy.getPrice(<span class=\"keyword\">this</span>.price)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Vip</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Old</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Others</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>显然逻辑多而复杂时可以极大提高代码可读性以及减少维护成本</p>\n<p>补充：上述不断重复的代码片段看起来非常丑陋，其实可以通过继承来实现更简洁的写法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义父类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(discount) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不传为原价</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.discount = discount || <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice(price) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.discount === <span class=\"number\">1</span></span><br><span class=\"line\">      ? price</span><br><span class=\"line\">      : <span class=\"keyword\">this</span>.discount * price</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明子类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以自定义更多不同级别顾客不同需求</span></span><br><span class=\"line\"><span class=\"comment\">// class Test extend Handler &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   getGifts() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     if (this.discount &lt; 1) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       // 赠送赠品</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// const master = new Test(0.1)</span></span><br><span class=\"line\"><span class=\"comment\">// master.getGifts()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Context类同上方便统一接口输出</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> seller = <span class=\"keyword\">new</span> Context</span><br><span class=\"line\"><span class=\"keyword\">const</span> vip = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.5</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> old = <span class=\"keyword\">new</span> Sub(<span class=\"number\">0.8</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> other = <span class=\"keyword\">new</span> Sub</span><br><span class=\"line\"></span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'zs'</span>, vip, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ls'</span>, old, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\">seller.setPrice(<span class=\"string\">'ww'</span>, other, <span class=\"number\">1000</span>)</span><br><span class=\"line\">seller.getPrice()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// zs 500 元</span></span><br><span class=\"line\"><span class=\"comment\">// ls 800 元</span></span><br><span class=\"line\"><span class=\"comment\">// ww 1000 元</span></span><br></pre></td></tr></table></figure></p>\n<p>测试结果一致</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"定义：-2\"><a href=\"#定义：-2\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用<br>著名的代理模式例子为引用计数（reference counting）指针对象<br>另外代理模式还可分为：</p>\n<ul>\n<li>虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建，当对象在创建前或创建中时，由虚拟代理来扮演对象的替身；对象创建后，代理就会将请求直接委托给对象</li>\n<li>保护代理：用于控制不同权限的对象对目标对象的访问</li>\n<li>缓存代理: 缓存代理可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</li>\n</ul>\n<h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>独立职责归属，便于维护测试</p>\n<h3 id=\"应用场景：-2\"><a href=\"#应用场景：-2\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>比如图片的懒加载，数据缓存等</p>\n<h4 id=\"虚拟代理实现图片懒加载\"><a href=\"#虚拟代理实现图片懒加载\" class=\"headerlink\" title=\"虚拟代理实现图片懒加载\"></a>虚拟代理实现图片懒加载</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> imgSet = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.append(node)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    node.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxyImg = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _img = <span class=\"keyword\">new</span> Image</span><br><span class=\"line\"></span><br><span class=\"line\">  _img.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(imgSet, <span class=\"number\">2000</span>, <span class=\"keyword\">this</span>.src)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    imgSet(<span class=\"string\">'https://yphoto.eryufm.cn/upload/assets/jump.gif'</span>)</span><br><span class=\"line\">    _img.src = src</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">// call</span></span><br><span class=\"line\">proxyImg(<span class=\"string\">`https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1551174639&amp;di=90b4757f68c9480f78c132c930c1df10&amp;src=http://desk.fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/02/ChMkJ1bKxkmIObywAArTTfACinwAALHjACDZuIACtNl408.jpg`</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h4><p>对象a需要给对象c发送信息，为了保证a对c是不可见，可用对象b代理转发<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filter some no use or unneed requestions or data</span></span><br><span class=\"line\"><span class=\"comment\">// A  ---&gt; B(proxy) ----&gt; C</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  send (target, info) &#123;</span><br><span class=\"line\">    target.receive(info)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  receive (target, info) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c receive '</span>, info, <span class=\"string\">' from '</span>, target.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  receive (info) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (info) &#123;</span><br><span class=\"line\">      c.receive(<span class=\"keyword\">this</span>, info)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.send(b, <span class=\"string\">'good morning'</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">''</span>)</span><br><span class=\"line\">a.send(b, <span class=\"string\">'send again'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// c receive good morning from b</span></span><br><span class=\"line\"><span class=\"comment\">// c receive send again from b</span></span><br></pre></td></tr></table></figure></p>\n<p>上面表示一个最简单的保护代理</p>\n<h4 id=\"缓存代理\"><a href=\"#缓存代理\" class=\"headerlink\" title=\"缓存代理\"></a>缓存代理</h4><p>顾名思义就是缓存相关的代理</p>\n<p>有一个二级别联动的标签列表，第二级的各有自己所属的多个标签根据第一级的参数来发送指定请求来获取，如果想要达到点击第一级列表迅速展示出相关的第二级标签，我们可以在系统空闲时预先将所有标签全部获取并缓存<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储所有标签</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sendApiGetTags = <span class=\"function\"><span class=\"params\">index</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ajax.get('/api', &#123; index &#125;)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyCache = <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">async</span> (</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> allTagsCache = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> number = <span class=\"number\">5</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> all = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index = <span class=\"number\">0</span>; index &lt; number; index++) &#123;</span><br><span class=\"line\">    all.push(sendApiGetTags(&#123;</span><br><span class=\"line\">      ...params,</span><br><span class=\"line\">      index</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> list = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(all)</span><br><span class=\"line\"></span><br><span class=\"line\">  list.forEach(<span class=\"function\">(<span class=\"params\">res, i</span>) =&gt;</span> allTagsCache[i] = res)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> allTagsCache</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> setTags = <span class=\"keyword\">async</span> index =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中有直接拿</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (proxyCache[index]) &#123;</span><br><span class=\"line\">    tags = proxyCache[index]</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存中没有则重发请求</span></span><br><span class=\"line\">    tags = <span class=\"keyword\">await</span> sendApiGetTags(index)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a>发布订阅模式</h1><h3 id=\"定义：-3\"><a href=\"#定义：-3\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。<br>至于发布订阅模式和观察者模式是不是同一样东西不同的人各有看法</p>\n<h3 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>订阅者可以根据自己需求当某种Action被触发时完成自己的调度</p>\n<h3 id=\"应用场景：-3\"><a href=\"#应用场景：-3\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>AngularJs的广播、vue的eventbus等</p>\n<h4 id=\"根据主体构建发布订阅的基类\"><a href=\"#根据主体构建发布订阅的基类\" class=\"headerlink\" title=\"根据主体构建发布订阅的基类\"></a>根据主体构建发布订阅的基类</h4><p>构造发布者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Publisher</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 订阅发布者的队列 存储每个订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  deliver (data) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发布消息 调用订阅者的回调 告知订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subscribers.forEach(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn.shot(data))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造订阅者基类<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (call) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入订阅回调</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.shot = call</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  subscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!publisher.subscribers.some(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot === <span class=\"keyword\">this</span>.shot)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'订阅该消息'</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 判断当前订阅者是否订阅</span></span><br><span class=\"line\">      publisher.subscribers.push(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  unsubscribe (publisher) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 移除当前订阅者</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'取消订阅'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    publisher.subscribers = publisher.subscribers.filter(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.shot !== <span class=\"keyword\">this</span>.shot)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pub = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> pub2 = <span class=\"keyword\">new</span> Publisher</span><br><span class=\"line\"><span class=\"keyword\">const</span> obs = <span class=\"keyword\">new</span> Observer(<span class=\"function\"><span class=\"params\">deliver</span> =&gt;</span> <span class=\"built_in\">console</span>.log(deliver))</span><br><span class=\"line\"></span><br><span class=\"line\">obs.subscribe(pub) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\">obs.subscribe(pub2) <span class=\"comment\">// 订阅该消息</span></span><br><span class=\"line\"></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver first message'</span>) <span class=\"comment\">// pub deliver first message</span></span><br><span class=\"line\">pub2.deliver(<span class=\"string\">'pub2 deliver first message'</span>) <span class=\"comment\">// pub2 deliver first message</span></span><br><span class=\"line\"></span><br><span class=\"line\">obs.unsubscribe(pub) <span class=\"comment\">// 取消订阅</span></span><br><span class=\"line\">pub.deliver(<span class=\"string\">'pub deliver second message'</span>) <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><h3 id=\"定义：-4\"><a href=\"#定义：-4\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能</p>\n<h3 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展</li>\n</ul>\n<h3 id=\"应用场景：-4\"><a href=\"#应用场景：-4\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><ul>\n<li>需要扩展一个类的功能，或给一个类添加附加职责</li>\n<li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销</li>\n<li>不必改动原本的逻辑造成不可知问题</li>\n</ul>\n<h4 id=\"给所有的函数调用添加调用前和调用后的钩子\"><a href=\"#给所有的函数调用添加调用前和调用后的钩子\" class=\"headerlink\" title=\"给所有的函数调用添加调用前和调用后的钩子\"></a>给所有的函数调用添加调用前和调用后的钩子</h4><p>普通函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"string\">'let go'</span>) <span class=\"comment\">// lets go right now</span></span><br></pre></td></tr></table></figure></p>\n<p>我们知道JS中所有的函数都是基于父类 <code>Function</code> 生成的，所以会继承父类原型的方法，下面我们将函数的钩子挂在父类的原型上即可：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行前</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.before = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 返回体本身也是函数所以支持继续调用钩子</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用钩子，同时参数传递到钩子内</span></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 调用自身</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 执行后</span></span><br><span class=\"line\"><span class=\"comment\">// 和 before 同理</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.after = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">call</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    call.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回自身的返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重新包装 fn</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg, <span class=\"string\">' right now'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decoratorFn = fn.before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'when we go,'</span>, msg)</span><br><span class=\"line\">&#125;).after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'had to go'</span>, msg)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">decoratorFn(<span class=\"string\">'lets go'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// out put:</span></span><br><span class=\"line\"><span class=\"comment\">// when we go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// lets go, right now</span></span><br><span class=\"line\"><span class=\"comment\">// had to go, right now</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"职责链（责任链）模式\"><a href=\"#职责链（责任链）模式\" class=\"headerlink\" title=\"职责链（责任链）模式\"></a>职责链（责任链）模式</h1><h3 id=\"定义：-5\"><a href=\"#定义：-5\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求</p>\n<h3 id=\"优点：-4\"><a href=\"#优点：-4\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><p>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了</p>\n<h3 id=\"应用场景：-5\"><a href=\"#应用场景：-5\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h3><p>JS 中的事件冒泡（事件委托）就是经典案例</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>部门采购物品不同金额需要走不同职位的流程审批，采购部经理可自主决定1w以内的采购，总经理可以决定10w以内的采购，董事长决定100w以内的采购<br>下面分别抽象处理者构造基类</p>\n<p>责任链调度中心：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setNext(_handler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = _handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  handleRequest(money) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采购部经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CGBHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'1w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理1w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总经理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZJLHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 10w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10w以内，同意'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'金额太大，只能处理10w以内的采购'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next.handleRequest(money)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>董事长：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DSZHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">  handleRequest(money) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 100w</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (money &gt;= <span class=\"number\">100000</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'10万以上的我来处理'</span>)</span><br><span class=\"line\">      <span class=\"comment\">//处理其他逻辑</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>封装客户端接口：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dispatch = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">client</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cgb = <span class=\"keyword\">new</span> CGBHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> zjl = <span class=\"keyword\">new</span> ZJLHandler()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dsz = <span class=\"keyword\">new</span> DSZHandler()</span><br><span class=\"line\"></span><br><span class=\"line\">  cgb.setNext(zjl)</span><br><span class=\"line\">  zjl.setNext(dsz)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cgb.handleRequest.bind(cgb)</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>测试：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">800000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理1w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 金额太大，只能处理10w以内的采购</span></span><br><span class=\"line\"><span class=\"comment\">// 10万以上的我来处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">dispath(<span class=\"number\">7000</span>)</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 1w以内，同意</span></span><br></pre></td></tr></table></figure></p>\n<p>补充：</p>\n<ul>\n<li><p>纯的责任链：要求请求在这些对象链中必须被处理，而且一个节点处理对象，要么只处理请求，要么把请求转发给下个节点对象处理</p>\n</li>\n<li><p>不纯的责任链：要求在责任链里不一定会有处理结构，而且一个节点对象，即可以处理部分请求，并把请求再转发下个节点处理</p>\n</li>\n</ul>\n<p>.<br>.<br>.<br>.<br>.<br>.<br>未完待续…👏</p>"}],"PostAsset":[{"_id":"source/_posts/writeSomething/koa2OnionModel/onion.png","slug":"onion.png","post":"cjt2pem1f000ef748ydswvkkf","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjt2pem110003f748bjjoe18c","category_id":"cjt2pem160005f7481jpjq83o","_id":"cjt2pem1g000gf748xvb78c9u"},{"post_id":"cjt2pem140004f748h3ne3hov","category_id":"cjt2pem160005f7481jpjq83o","_id":"cjt2pem1i000kf7486jfrwmj5"},{"post_id":"cjt2pem1h000jf748y1rfs3id","category_id":"cjt2pem1g000ff748wyylqpi0","_id":"cjt2pem1j000nf748lugk3urp"},{"post_id":"cjt2pem180007f74813o3qnu0","category_id":"cjt2pem1g000ff748wyylqpi0","_id":"cjt2pem1j000qf748gw8laur4"},{"post_id":"cjt2pem190008f748qoh62ppu","category_id":"cjt2pem1g000ff748wyylqpi0","_id":"cjt2pem1k000sf748bs7u8k01"},{"post_id":"cjt2pem1a0009f748mwhodoks","category_id":"cjt2pem1j000of748a03hpo9w","_id":"cjt2pem1k000wf748a0ffd8m7"},{"post_id":"cjt2pem1c000df748vbjgvecp","category_id":"cjt2pem1k000uf748pp8bhzn5","_id":"cjt2pem1l000zf748p6vq47gb"},{"post_id":"cjt2pem1f000ef748ydswvkkf","category_id":"cjt2pem1j000of748a03hpo9w","_id":"cjt2pem1l0011f748wci0w3x8"}],"PostTag":[{"post_id":"cjt2pem110003f748bjjoe18c","tag_id":"cjt2pem170006f748blsaet0o","_id":"cjt2pem1c000cf748sa1j5v0g"},{"post_id":"cjt2pem140004f748h3ne3hov","tag_id":"cjt2pem170006f748blsaet0o","_id":"cjt2pem1h000if7482rnekmb8"},{"post_id":"cjt2pem180007f74813o3qnu0","tag_id":"cjt2pem1g000hf7485kc27wyj","_id":"cjt2pem1j000rf748sh1tm6xr"},{"post_id":"cjt2pem180007f74813o3qnu0","tag_id":"cjt2pem1i000mf7485zku6tvr","_id":"cjt2pem1k000tf748knbnakb9"},{"post_id":"cjt2pem190008f748qoh62ppu","tag_id":"cjt2pem1g000hf7485kc27wyj","_id":"cjt2pem1l0013f748h3fg7ts9"},{"post_id":"cjt2pem190008f748qoh62ppu","tag_id":"cjt2pem1k000vf748s3n5p9dt","_id":"cjt2pem1m0014f7489yfor4qj"},{"post_id":"cjt2pem190008f748qoh62ppu","tag_id":"cjt2pem1k000yf7483z2ikax6","_id":"cjt2pem1m0016f748zp7q5n5q"},{"post_id":"cjt2pem190008f748qoh62ppu","tag_id":"cjt2pem1l0010f748kt1t1ba3","_id":"cjt2pem1m0017f748twejam8u"},{"post_id":"cjt2pem1a0009f748mwhodoks","tag_id":"cjt2pem1l0012f7484rl263nr","_id":"cjt2pem1n001bf748gdvz4x2r"},{"post_id":"cjt2pem1a0009f748mwhodoks","tag_id":"cjt2pem1m0015f748d6iiolu2","_id":"cjt2pem1n001cf748rcyfpaox"},{"post_id":"cjt2pem1a0009f748mwhodoks","tag_id":"cjt2pem1m0018f748cuq9g0j5","_id":"cjt2pem1n001ef748gvyt7qx1"},{"post_id":"cjt2pem1a0009f748mwhodoks","tag_id":"cjt2pem1m0019f748ulpttg11","_id":"cjt2pem1n001ff748oufipszs"},{"post_id":"cjt2pem1c000df748vbjgvecp","tag_id":"cjt2pem1m001af74834dkrdqd","_id":"cjt2pem1o001hf748pbfo3wu4"},{"post_id":"cjt2pem1c000df748vbjgvecp","tag_id":"cjt2pem1n001df748swrl0his","_id":"cjt2pem1o001if7483061t5do"},{"post_id":"cjt2pem1f000ef748ydswvkkf","tag_id":"cjt2pem1l0012f7484rl263nr","_id":"cjt2pem1p001mf7481rtft0gs"},{"post_id":"cjt2pem1f000ef748ydswvkkf","tag_id":"cjt2pem1o001jf748oq8ic49m","_id":"cjt2pem1p001nf748arcsnyl6"},{"post_id":"cjt2pem1f000ef748ydswvkkf","tag_id":"cjt2pem1o001kf748lnnvrwi3","_id":"cjt2pem1p001of7488mv4ei4a"},{"post_id":"cjt2pem1h000jf748y1rfs3id","tag_id":"cjt2pem1o001lf748tcyhx0fg","_id":"cjt2pem1p001pf748az96lnw3"},{"post_id":"cjt2pem1h000jf748y1rfs3id","tag_id":"cjt2pem1g000hf7485kc27wyj","_id":"cjt2pem1p001qf748uff832ex"}],"Tag":[{"name":"当我在扯淡","_id":"cjt2pem170006f748blsaet0o"},{"name":"算法","_id":"cjt2pem1g000hf7485kc27wyj"},{"name":"算法复杂度","_id":"cjt2pem1i000mf7485zku6tvr"},{"name":"动态规划","_id":"cjt2pem1k000vf748s3n5p9dt"},{"name":"递归","_id":"cjt2pem1k000yf7483z2ikax6"},{"name":"尾递归","_id":"cjt2pem1l0010f748kt1t1ba3"},{"name":"封装","_id":"cjt2pem1l0012f7484rl263nr"},{"name":"微信小程序","_id":"cjt2pem1m0015f748d6iiolu2"},{"name":"mpvue","_id":"cjt2pem1m0018f748cuq9g0j5"},{"name":"路由","_id":"cjt2pem1m0019f748ulpttg11"},{"name":"事件循环","_id":"cjt2pem1m001af74834dkrdqd"},{"name":"任务队列","_id":"cjt2pem1n001df748swrl0his"},{"name":"koa","_id":"cjt2pem1o001jf748oq8ic49m"},{"name":"洋葱模型","_id":"cjt2pem1o001kf748lnnvrwi3"},{"name":"设计模式","_id":"cjt2pem1o001lf748tcyhx0fg"}]}}